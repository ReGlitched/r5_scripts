/// =================== ///
///		Onboarding		///
/// =================== ///

/*
	Onboarding handles user interaction from joining until the enabled character selection outros have been completed.

	Everything after that is gamemode-specific.
	To handle onboarding completion in your gamemode code, use AddCallback_GameStateEnter for eGameState.Playing.

	Onboarding is controlled by playlist vars, define them in the gamemode spec to control.
	Available playlist vars:
		General:
			custom_onboarding							- Completely disable default onboarding sequences, leveraging onboarding on the gamemode.
		Waiting for players:
			waiting_for_players_min_wait 				- Minimal time to wait before checking for players.
			waiting_for_players_timeout_seconds 		- Maximum time to wait for connecting players.
			waiting_for_players_has_black_screen 		- Select whether the player should have a black background instead of a view of their current origin.
			waiting_for_players_spawning_enabled		- Select whether the player should be spawned (partial spawn since at this stage no settings have been assigned).
			waiting_for_players_countdown_seconds		- The countdown before the next onboarding stage.
			charselect_intro_music_start_time			- The offset from character selection unlock when the character selection music should be started.
		Character selection:
			charselect_enabled							- Select whether the default character selection logic should be used. If false, random legends will be assigned.
			charselect_intro_transition_duration		- The duration of transition from waiting for players to character selection.
			charselect_intro_countdown_duration			- The duration of the pre legend selection countdown (You choose N'nd).
			charselect_picking_delay_before_all 		- The duration of delay before the legend pick logic starts.
			charselect_picking_delay_on_first			- The duration of delay after the first player has picked their legend.
			character_select_time_min					- Minimal time for player to select their legend.
			character_select_time_max					- Maximum time for player to select their legend.
			charselect_picking_delay_after_each_lock	- The duration of delay after any player has picked their legend.
			charselect_picking_delay_after_all			- The duration of delay after all players have picked their legend.
			charselect_outro_scene_change_duration		- The duration of delay to switch the scene to next steps.
		Player squad overview:
			survival_enable_squad_intro					- Show player squad. If disabled, the player squad duration is skipped.
			charselect_outro_squad_present_duration		- The duration of player squad data being present on screen.
		Champion squad overview:
			survival_enable_gladiator_intros			- Show champion squad. If disabled, the champion squad duration is skipped.
			charselect_outro_champion_present_duration	- The duration of champion squad data being present on screen.
		End:
			charselect_outro_transition_duration		- The duration of transition from past steps to playing state.
*/
global function SV_CL_Onboarding_Init

#if SERVER
	global function TakeLoadoutRelatedWeapons
	global function GiveLoadoutRelatedWeapons
	global function GiveLoadoutRelatedWeapons_HaloMod
	
	global function DecideRespawnPlayer
	global function DecideRespawnPlayer_Retail

	global function PlayerStopSpectating

	global function UpdatePlayerCounts
	global function Flowstate_AssignUniqueCharacterForPlayer
	global function Flowstate_SetAssignedCustomModelToPlayer

	global function SetCallback_ObserverThreadOverride

	global function SetPlayerSettings
	global function Flowstate_ApplyModifiedMovementToPlayer
	
	#if DEVELOPER 
		global function DEV_SetMovement
	#endif
#endif

global function PreGame_GetWaitingForPlayersHasBlackScreen
global function PreGame_GetWaitingForPlayersSpawningEnabled
global function PreGame_GetWaitingForPlayersDelayMin
global function PreGame_GetWaitingForPlayersDelayMax
global function PreGame_GetWaitingForPlayersCountdown

global function CharSelect_GetIntroMusicStartTime
global function CharSelect_GetIntroTransitionDuration
global function CharSelect_GetIntroCountdownDuration

global function CharSelect_GetPickingDelayBeforeAll
global function CharSelect_GetPickingDelayOnFirst
global function CharSelect_GetPickingSingleDurationMax
global function CharSelect_GetPickingSingleDurationMin
global function CharSelect_GetPickingDelayAfterEachLock
global function CharSelect_GetPickingDelayAfterAll

global function CharSelect_GetOutroSceneChangeDuration
global function CharSelect_GetOutroSquadPresentDuration
global function CharSelect_GetOutroChampionPresentDuration
global function CharSelect_GetOutroTransitionDuration

global function Survival_GetCharacterSelectDuration
global function Survival_CharacterSelectEnabled
//So ideally, don't change this if you don't want prediction to be fucked. Open a PR on Flowstate repo if you have feedback for these vars <3 Cafe
global const table TRUE_TF2_SETTINGS = 
{
	//["acceleration"] = 10.0,
	["airacceleration"] = 500.0,
	//["airspeed"] = 60,
	["antiMultiJumpHeightFrac"] = 1.0,
	["automantle"] = 1.0,
	["automantle_enable"] = 1.0,
	["doublejump"] = 1.0,
	["gravityscale"] = 0.75,
	["impactSpeed"] = 380.0,
	["jumpheight"] = 60.0,
	["landslowdownduration"] = 0.0,
	["leech_range"] = 64.0,
	["skip_speed_reduce"] = 0.0,
	["Slidejumpheight"] = 90.0,
	["slideRequiredStartSpeed"] = 200.0,
	["slideSpeedBoostCap"] = 9999999.0,
	["slidedecel"] = 50.0,
	["slidevelocitydecay"] = 0.7,
	["stepheight"] = 18.0,
	["superjumpHorzSpeed"] = 180.0,
	["superjumpMaxHeight"] = 60.0,
	["superjumpMinHeight"] = 60.0,
	["wallrun"] = 1.0,
	["wallrunAccelerateHorizontal"] = 1400.0,
	["wallrunAccelerateVertical"] = 360.0,
	["wallrunJumpInputDirSpeed"] = 75.0,
	["wallrunJumpOutwardSpeed"] = 205.0,
	["wallrunJumpUpSpeed"] = 230.0,
	["wallrunMaxSpeedHorizontal"] = 340.0,
	["wallrunMaxSpeedVertical"] = 225.0,
	["wallrun_timeLimit"] = 1.75,
	["ziplineSpeed"] = 600.0,
	["skip_speed_retain"] = 99999.0,
	["slide_boost_cooldown"] = 2.0,
	["speed"] = 162.5,
	["sprintspeed"] = 243.0,
	["grapple_shootVel"] = 3000.0,
	["grapple_speedRampMax_human"] = 800.0,
	["wallrun_maxViewTilt"] = 15.0,
	["sprintViewOffset"] = -6.0,
	["sprintStartDelay"] = 0.2,
	["sprintStartDuration"] = 0.8,
	["sprintStartFastDuration"] = 0.2,
	["sprintEndDuration"] = 0.15,
	["sprinttiltMaxRoll"] = 2.0,
	["grapple_windowCheckDist"] = 150.0,
	["grapple_detachLengthMin"] = 33.0,
	["grapple_detachLengthMax"] = 50.0,
	["grapple_detachAwaySpeed"] = 500.0,
	["grapple_gravityFracMin"] = 0.25,
	["grapple_gravityFracMax"] = 0.7,
	["grapple_detachVerticalBoost"] = 200.0,
	["grapple_detachVerticalMaxSpeed"] = 200.0,
	["grapple_detachSpeedLoss"] = 300.0,
	["grapple_detachSpeedLossMin"] = 430.0,
	["grapple_detachLowSpeedThreshold"] = 250.0,
	["grapple_detachLowSpeedTime"] = 1.5,
	["grapple_detachLowSpeedWallTime"] = 1.2,
	["grapple_detachLowSpeedGroundTime"] = 0.7,
	["grapple_impactVerticalBoost"] = 300.0,
	["grapple_impactVerticalMaxSpeed"] = 300.0,
	["grapple_power_regen_delay"] = 3.0,
	["grapple_power_regen_rate"] = 3.0,
	["grapple_airSpeedMax"] = 420.0,
	["grapple_airAccel"] = 650.0,
	["wallrun_allowed_wall_dist"] = 13.0,
	["wallrun_allowed_wall_dist_wallhang"] = 18.0,
	["wallrun_gravityRampUpTime"] = 0.7,
	["wallrun_sameWallHeight"] = 0.0,
	["wallrun_upWallBoost"] = 250.0,
	["wallrun_hangTimeLimit"] = 25.0,
	["zipline_use_range"] = 120.0
}

global const table TRUE_TF2_SETTINGS_HIGH_AIRACCEL = 
{
	//["acceleration"] = 10.0,
	["airacceleration"] = 9000.0, //increase air accel
	//["airspeed"] = 60.0,
	["antiMultiJumpHeightFrac"] = 1.0,
	["automantle"] = 0.0, //disable auto mantle
	["automantle_enable"] = 0.0,
	["doublejump"] = 1.0,
	["gravityscale"] = 0.75,
	["impactSpeed"] = 380.0,
	["jumpheight"] = 60.0,
	["landslowdownduration"] = 0.0,
	["leech_range"] = 64.0,
	["skip_speed_reduce"] = 0.0,
	["Slidejumpheight"] = 90.0,
	["slideRequiredStartSpeed"] = 200.0,
	["slideSpeedBoostCap"] = 9999999.0,
	["slidedecel"] = 50.0,
	["slidevelocitydecay"] = 0.7,
	["stepheight"] = 18.0,
	["superjumpHorzSpeed"] = 180.0,
	["superjumpMaxHeight"] = 60.0,
	["superjumpMinHeight"] = 60.0,
	["wallrun"] = 1.0,
	["wallrunAccelerateHorizontal"] = 1400.0,
	["wallrunAccelerateVertical"] = 360.0,
	["wallrunJumpInputDirSpeed"] = 75.0,
	["wallrunJumpOutwardSpeed"] = 205.0,
	["wallrunJumpUpSpeed"] = 230.0,
	["wallrunMaxSpeedHorizontal"] = 340.0,
	["wallrunMaxSpeedVertical"] = 225.0,
	["wallrun_timeLimit"] = 1.75,
	["ziplineSpeed"] = 600.0,
	["skip_speed_retain"] = 99999.0,
	["slide_boost_cooldown"] = 2.0,
	["speed"] = 162.5,
	["sprintspeed"] = 243.0,
	["grapple_shootVel"] = 3000.0,
	["grapple_speedRampMax_human"] = 800.0,
	["wallrun_maxViewTilt"] = 15.0,
	["sprintViewOffset"] = -6.0,
	["sprintStartDelay"] = 0.2,
	["sprintStartDuration"] = 0.8,
	["sprintStartFastDuration"] = 0.2,
	["sprintEndDuration"] = 0.15,
	["sprinttiltMaxRoll"] = 2.0,
	["grapple_windowCheckDist"] = 150.0,
	["grapple_detachLengthMin"] = 33.0,
	["grapple_detachLengthMax"] = 50.0,
	["grapple_detachAwaySpeed"] = 500.0,
	["grapple_gravityFracMin"] = 0.25,
	["grapple_gravityFracMax"] = 0.7,
	["grapple_detachVerticalBoost"] = 200.0,
	["grapple_detachVerticalMaxSpeed"] = 200.0,
	["grapple_detachSpeedLoss"] = 300.0,
	["grapple_detachSpeedLossMin"] = 430.0,
	["grapple_detachLowSpeedThreshold"] = 250.0,
	["grapple_detachLowSpeedTime"] = 1.5,
	["grapple_detachLowSpeedWallTime"] = 1.2,
	["grapple_detachLowSpeedGroundTime"] = 0.7,
	["grapple_impactVerticalBoost"] = 300.0,
	["grapple_impactVerticalMaxSpeed"] = 300.0,
	["grapple_power_regen_delay"] = 3.0,
	["grapple_power_regen_rate"] = 3.0,
	["grapple_airSpeedMax"] = 420.0,
	["grapple_airAccel"] = 650.0,
	["wallrun_allowed_wall_dist"] = 13.0,
	["wallrun_allowed_wall_dist_wallhang"] = 18.0,
	["wallrun_gravityRampUpTime"] = 0.7,
	["wallrun_sameWallHeight"] = 0.0,
	["wallrun_upWallBoost"] = 250.0,
	["wallrun_hangTimeLimit"] = 25.0,
	["zipline_use_range"] = 120.0,
	["grapple_accel_human"] = 1800.0, //buff grapple
	["grapple_decel_human"] = 200.0, //buff grapple
	["grapple_speedRampMin_human"] = 400.0, //buff grapple
	["grapple_speedRampTime_human"] = 1.0 //buff grapple
}

global const table TRUE_TF2_SETTINGS_LOW_GRAV = 
{
	//["acceleration"] = 10,
	["airacceleration"] = 500.0,
	//["airspeed"] = 60.0,
	["antiMultiJumpHeightFrac"] = 1.0,
	["automantle"] = 1.0,
	["automantle_enable"] = 1.0,
	["doublejump"] = 1.0,
	["gravityscale"] = 0.4,
	["impactSpeed"] = 380.0,
	["jumpheight"] = 60.0,
	["landslowdownduration"] = 0.0,
	["leech_range"] = 64.0,
	["skip_speed_reduce"] = 0.0,
	["Slidejumpheight"] = 90.0,
	["slideRequiredStartSpeed"] = 200.0,
	["slideSpeedBoostCap"] = 9999999.0,
	["slidedecel"] = 50.0,
	["slidevelocitydecay"] = 0.7,
	["stepheight"] = 18.0,
	["superjumpHorzSpeed"] = 180.0,
	["superjumpMaxHeight"] = 60.0,
	["superjumpMinHeight"] = 60.0,
	["wallrun"] = 1.0,
	["wallrunAccelerateHorizontal"] = 1400.0,
	["wallrunAccelerateVertical"] = 360.0,
	["wallrunJumpInputDirSpeed"] = 75.0,
	["wallrunJumpOutwardSpeed"] = 205.0,
	["wallrunJumpUpSpeed"] = 230.0,
	["wallrunMaxSpeedHorizontal"] = 340.0,
	["wallrunMaxSpeedVertical"] = 225.0,
	["wallrun_timeLimit"] = 1.75,
	["ziplineSpeed"] = 600.0,
	["skip_speed_retain"] = 99999.0,
	["slide_boost_cooldown"] = 2.0,
	["speed"] = 162.5,
	["sprintspeed"] = 243.0,
	["grapple_shootVel"] = 3000.0,
	["grapple_speedRampMax_human"] = 800.0,
	["wallrun_maxViewTilt"] = 15.0,
	["sprintViewOffset"] = -6.0,
	["sprintStartDelay"] = 0.2,
	["sprintStartDuration"] = 0.8,
	["sprintStartFastDuration"] = 0.2,
	["sprintEndDuration"] = 0.15,
	["sprinttiltMaxRoll"] = 2.0,
	["grapple_windowCheckDist"] = 150.0,
	["grapple_detachLengthMin"] = 33.0,
	["grapple_detachLengthMax"] = 50.0,
	["grapple_detachAwaySpeed"] = 500.0,
	["grapple_gravityFracMin"] = 0.25,
	["grapple_gravityFracMax"] = 0.7,
	["grapple_detachVerticalBoost"] = 200.0,
	["grapple_detachVerticalMaxSpeed"] = 200.0,
	["grapple_detachSpeedLoss"] = 300.0,
	["grapple_detachSpeedLossMin"] = 430.0,
	["grapple_detachLowSpeedThreshold"] = 250.0,
	["grapple_detachLowSpeedTime"] = 1.5,
	["grapple_detachLowSpeedWallTime"] = 1.2,
	["grapple_detachLowSpeedGroundTime"] = 0.7,
	["grapple_impactVerticalBoost"] = 300.0,
	["grapple_impactVerticalMaxSpeed"] = 300.0,
	["grapple_power_regen_delay"] = 3.0,
	["grapple_power_regen_rate"] = 3.0,
	["grapple_airSpeedMax"] = 420.0,
	["grapple_airAccel"] = 650.0,
	["wallrun_allowed_wall_dist"] = 13.0,
	["wallrun_allowed_wall_dist_wallhang"] = 18.0,
	["wallrun_gravityRampUpTime"] = 0.7,
	["wallrun_sameWallHeight"] = 0.0,
	["wallrun_upWallBoost"] = 250.0,
	["wallrun_hangTimeLimit"] = 25.0,
	["zipline_use_range"] = 120.0
}

global const table CSGO_MOVEMENT = 
{
	["acceleration"] = 550.0,
	["airacceleration"] = 225.0,
	["airspeed"] = 30.0,
	["antiMultiJumpHeightFrac"] = 1.0,
	["automantle"] = 0.0,
	["automantle_enable"] = 0.0,
	["climbEnabled"] = 0.0,
	["climbheight"] = 0.1,
	["gravityscale"] = 1.25,
	["jumpheight"] = 55.0,
	["player_slideBoostEnabled"] = 0.0,
	["skip_speed_reduce"] = 0.0,
	["skip_time"] = 0.0,
	["slideRequiredStartSpeed"] = 9999999.0,
	["slideRequiredStartSpeedAir"] = 9999999.0,
	["slideSpeedBoost"] = 0.0,
	["slideSpeedBoostCap"] = 0.0,
	["slideVelocityDecay"] = 0.0,
	["superjumpMinHeight"] = 0.0,
	["wallrun"] = 0.0
}

global const table CSGO_MOVEMENT_HIGH_AIRACCEL = 
{
	["acceleration"] = 550.0,
	["airacceleration"] = 9000.0,
	["airspeed"] = 30.0,
	["antiMultiJumpHeightFrac"] = 1.0,
	["automantle"] = 0.0,
	["automantle_enable"] = 0.0,
	["climbEnabled"] = 0.0,
	["climbheight"] = 0.1,
	["gravityscale"] = 1.25,
	["jumpheight"] = 55.0,
	["player_slideBoostEnabled"] = 0.0,
	["skip_speed_reduce"] = 0.0,
	["skip_time"] = 0.0,
	["slideRequiredStartSpeed"] = 9999999.0,
	["slideRequiredStartSpeedAir"] = 9999999.0,
	["slideSpeedBoost"] = 0.0,
	["slideSpeedBoostCap"] = 0.0,
	["slideVelocityDecay"] = 0.0,
	["superjumpMinHeight"] = 0.0,
	["wallrun"] = 0.0
}

global const table SURF_SETTINGS = 
{
	["airacceleration"] = 6000.0,
	["acceleration"] = 550.0,
	["landslowdownduration"] = 0.0,
	["airspeed"] = 60.0
}

global const table HL1_MOVEMENT = 
{
	["acceleration"] = 550.0,
	["airacceleration"] = 1200.0,
	["airspeed"] = 30.0,
	["antiMultiJumpHeightFrac"] = 1.0,
	["automantle"] = 0.0,
	["automantle_enable"] = 0.0,
	["climbEnabled"] = 0.0,
	["climbheight"] = 0.1,
	["gravityscale"] = 1.25,
	["jumpheight"] = 55.0,
	["player_slideBoostEnabled"] = 0.0,
	["skip_speed_reduce"] = 0.0,
	["slideRequiredStartSpeed"] = 9999999.0,
	["slideRequiredStartSpeedAir"] = 9999999.0,
	["slideSpeedBoost"] = 0.0,
	["slideSpeedBoostCap"] = 0.0,
	["slideVelocityDecay"] = 0.0,
	["superjumpMinHeight"] = 0.0,
	["wallrun"] = 0.0
}

global const table HALO_MOVEMENT_NEW = 
{
	["antiMultiJumpHeightFrac"] = 1.0,
	
	["automantle"] = 0.0,
	["automantle_enable"] = 0.0,
	["climbEnabled"] = 0.0,
	["climbheight"] = 0.0,
	
	["gravityscale"] = 0.7,
	["jumpheight"] = 75.0,
	["landslowdownduration"] = 0.0,
	
	["player_slideBoostEnabled"] = 1.0,
	["slideRequiredStartSpeed"] = 200.0,
	["slideRequiredStartSpeedAir"] = 9999999.0,
	["slideSpeedBoost"] = 300.0,
	["slideSpeedBoostCap"] = 350.0,

	["wallrun"] = 0.0
}

global const table HALO_MOVEMENT = 
{
	["acceleration"] = 550.0,
	["airStrafeAcceleration"] = 0.0,
	["airStrafeEnabled"] = 0.0,
	["airStrafeTaperFinish"] = 0.01,
	["airStrafeTaperStart"] = 0.01,
	["airacceleration"] = 0.0,
	["airspeed"] = 0.0,
	["speed"] = 185.0,
	["antiMultiJumpHeightFrac"] = 1.0,
	["automantle"] = 0.0,
	["automantle_enable"] = 0.0,
	["climbEnabled"] = 0.0,
	["climbheight"] = 0.0,
	["glideEnabled"] = 0.0,
	["glideRedirectJumpHeightFinishOffset"] = 0.0,
	["glideRedirectJumpHeightStartOffset"] = 0.0,
	["glideRedirectSideways"] = 0.0,
	["glideStrafe"] = 0.0,
	["glideStrafeTaperFinish"] = 0.0,
	["glideStrafeTaperStart"] = 0.0,
	["gravityscale"] = 0.7,
	["jumpheight"] = 65.0,
	["landslowdownduration"] = 0.0,
	["player_slideBoostEnabled"] = 0.0,
	["skip_speed_reduce"] = 0.0,
	["skip_time"] = 0.0,
	["slideRequiredStartSpeed"] = 9999999.0,
	["slideRequiredStartSpeedAir"] = 9999999.0,
	["slideSpeedBoost"] = 0.0,
	["slideSpeedBoostCap"] = 0.0,
	["slideVelocityDecay"] = 0.0,
	["superjumpCanUseAfterWallrun"] = 0.0,
	["superjumpMinHeight"] = 0.0,
	["wallrun"] = 0.0
}

global const table SUPERGLIDE_BOOST_SETTINGS = 
{
	["airacceleration"] = 1000.0,
	["player_slideBoostEnabled"] = 1.0,
	["player_slideBoostCooldown"] = 0.01,
	["slideRequiredStartSpeedAir"] = 0.01,
	["slideRequiredStartSpeed"]= 0.01,
	["slideSpeedBoostCap"] = 2500.0,
	["slideSpeedBoost"] = 2500.0
}

global const table INSTAGIB_PLAYER_SETTINGS = 
{
	["acceleration"] = 550.0,
	["airacceleration"] = 1000.0,
	["airspeed"] = 150.0,
	["automantle_enable"] = 1.0,
	["doublejump"] = 0.0,
	["gravityscale"] = 0.85,
	["impactSpeed"] = 380.0,
	["jumpheight"] = 120.0,
	["landslowdownduration"] = 0.0,
	["leech_range"] = 64.0,
	["slidedecel"] = 50.0,
	["slidevelocitydecay"] = 0.7,
	["stepheight"] = 18.0,
	["superjumpHorzSpeed"] = 180.0,
	["superjumpMaxHeight"] = 60.0,
	["superjumpMinHeight"] = 60.0,
	["wallrun"] = 0.0,
	["wallrunAccelerateHorizontal"] = 1500.0,
	["wallrunAccelerateVertical"] = 360.0,
	["wallrunJumpInputDirSpeed"] = 80.0,
	["wallrunJumpOutwardSpeed"] = 205.0,
	["wallrunJumpUpSpeed"] = 230.0,
	["wallrunMaxSpeedHorizontal"] = 420.0,
	["wallrunMaxSpeedVertical"] = 225.0,
	["wallrun_timeLimit"] = 1.75,
	["ziplineSpeed"] = 600.0,
	["skip_time"] = 0.0,
	["antiMultiJumpHeightFrac"] = 1.0
}

global const table HAVEFUN_PLAYER_SETTINGS = 
{
	["airacceleration"] = 3000.0,
	["airspeed"] = 1000.0,
	["automantle_enable"] = 1.0,
	["doublejump"] = 0.0,
	["gravityscale"] = 0.35,
	["impactSpeed"] = 380.0,
	["jumpheight"] = 1000.0,
	["landslowdownduration"] = 0.0,
	["leech_range"] = 64.0,
	["stepheight"] = 18.0,
	["ziplineSpeed"] = 600.0,
	["wallrun"] = 0.0,
	["slidedecel"] = 50.0,
	["slidevelocitydecay"] = 0.7,
	["sprintspeed"] = 1000.0,
	["speed"] = 800.0,
	["superjumpMinHeight"] = 60.0,
	["superjumpMaxHeight"] = 60.0,
	["superjumpHorzSpeed"] = 180.0,
	["wallrun_timeLimit"] = 1.75,
	["wallrunJumpOutwardSpeed"] = 205.0,
	["wallrunJumpUpSpeed"] = 230.0,
	["wallrunJumpInputDirSpeed"] = 80.0,
	["wallrunMaxSpeedVertical"] = 225.0,
	["wallrunMaxSpeedHorizontal"] = 420.0,
	["wallrunAccelerateVertical"] = 360.0,
	["wallrunAccelerateHorizontal"] = 1500.0
}

global const table SPIES_SETTINGS = 
{
	// ["assetName"] = "settings/player/mp/pilot_survival_firesupport.rpak",
	// ["armsModel"] = $"mdl/Weapons/arms/pov_pilot_medium_bangalore.rmdl",
	// ["cockpitModel"] = $"mdl/weapons/arms/human_pov_cockpit.rmdl",
	// ["hatchModel"] = $"",
	// ["camera_lcd"] = $"",
	["printName"] = "",
	["voice"] = "",//"player_M1",
	["readymessage"] = "",
	["raceOrSex"] = "",//"race_human_male",
	["hud_follow_icon"] = "",
	["fx_hover_enemy"] = "",//"P_enemy_jet_hover_HLD",
	["sharedEnergyRegenSound"] = "",
	["footstep_type"] = "",//"bangalore",
	["rumbleOnWallrunTimeout"] = "",//"rumble_pilotOnWallrunTimeout",
	["rumbleOnZiplineDetach"] = "",//"rumble_pilotOnZiplineDetach",
	["landingImpactTable"] = "",//"pilot_landing",
	["footstepImpactTable"] = "",//"pilot_foostep",
	["slideEffectTable"] = "",//"pilot_slide",
	["generalClass"] = "2",
	["viewmodelfov"] = "70",
	["stepHeight"] = "22",
	["physicsMass"] = "100",
	["physicsSoftBelowMass"] = "100",
	["physicsPushSpeedLimit"] = "50",
	["airDrag"] = "0",
	["health"] = "100",
	["healthShield"] = "0",
	["healthPerSegment"] = "1500",
	["armorType"] = "0",
	["pitchMaxDown"] = "89",
	["slipSpeed"] = "150",
	["localGravityBlendDistanceMin"] = "100",
	["localGravityBlendDistanceMax"] = "200",
	["titan_regen_delay"] = "8",
	["jumpHeight"] = "56",
	["antiMultiJumpTimeMin"] = "0.15",
	["landSlowdownTimePower"] = "2",
	["viewkickFallDistMax"] = "70",
	["boostDuration"] = "0.5",
	["boostHorizontalDragDelay"] = "-1",
	["boostAutoJetpackMeterThreshold"] = "0.1",
	["boostRepeatedBoostMeterCost"] = "0",
	["jetpackJumpsToActivate"] = "2",
	["jetpackHeightToActivate"] = "-1",
	["jetpackHeightToActivateDelay"] = "0",
	["jetpackTightnessUp"] = "0.5",
	["jetpackTightnessForwardBack"] = "1",
	["jetpackStrafeTaperFinish"] = "300",
	["glideTightnessUp"] = "0",
	["glideStrafe"] = "600",
	["glideStrafeTaperStart"] = "150",
	["glideRedirectJumpHeightStartOffset"] = "200",
	["airStrafeAcceleration"] = "0",
	["hoverTightnessVertical"] = "0.02",
	["hoverSafety"] = "0.25",
	["fx_jetwash_frequency"] = "0.1",
	["climbFinalJumpUpHeight"] = "28",
	["climbAccel"] = "500",
	["wallrun_hangTimeLimit"] = "4",
	["wallrunAllowedWallDistanceWallHang"] = "18",
	["wallrunDecelerateVertical"] = "300",
	["wallrunAccelerateHorizontal"] = "200",
	["wallrunDecelerateHorizontal"] = "500",
	["wallrunJumpInputDirSpeed"] = "75",
	["wallrunSameWallHeight"] = "0",
	["wallrun_viewpunch_onStart_randomPitch"] = "0.5",
	["wallrun_viewpunch_onStart_randomYaw"] = "0.5",
	["wallrun_viewpunch_onTimeout_randomYaw"] = "0.5",
	["wallrun_viewpunch_onTimeout_randomRoll"] = "0.5",
	["dodgeDuration"] = "0",
	["dodgeHeight"] = "25",
	["dodgeHeightMax"] = "25",
	["slideDecel"] = "100",
	["slideRequiredStartSpeed"] = "200",
	["slideStopSpeed"] = "125",
	["slideFOVLerpInTime"] = "0.25",
	["grapple_detachOnGrappleDebounceTime"] = "0.5",
	["grapple_autoAimAngle"] = "10",
	["grapple_rollStrength"] = "1",
	["grapple_rollViewAngleMax"] = "65",
	["grapple_rollDistanceMin"] = "0",
	["grapple_detachHorizontalMaxSpeed"] = "600",
	["grapple_detachGravitySpeed"] = "200",
	["grapple_detachLengthMax"] = "50",
	["grapple_gravityFracMin"] = "0.25",
	["grapple_detachSpeedLossMin"] = "460",
	["grapple_detachLowSpeedThreshold"] = "250",
	["grapple_detachLowSpeedSwingThreshold"] = "1000",
	["grapple_detachLowSpeedGroundTime"] = "0.7",
	["grapple_detachLowSpeedMeleeTime"] = "1",
	["grapple_impactVerticalMaxSpeed"] = "300",
	["grapple_speedRampMin"] = "50",
	["grapple_swingingSpeedRampMax"] = "800",
	["grapple_accel"] = "1500",
	["grapple_power_regen_rate"] = "10",
	["grapple_airAccel"] = "650",
	["skydive_deceleration_min"] = "100",
	["skydive_yaw_smooth_time_min"] = "0.2",
	["skydive_anticipate_acceleration_min"] = "45",
	["skydive_anticipate_deceleration_min"] = "150",
	["skydive_anticipate_forward_acceleration"] = "500",
	["skydive_strafe_angle"] = "35",
	["skydive_strafe_acceleration_min"] = "7.5",
	["skydive_forward_pose_parameter_smooth_time"] = "0.6",
	["skydive_side_pose_parameter_smooth_time"] = "0.3",
	["skydive_slipAcceleration"] = "1000",
	["sharedEnergyRegenDelay"] = "0",
	["deathcamMinHeight"] = "30",
	["deathcamLookdownTime"] = "2",
	["deathcamLookdownPitch"] = "52",
	["chasecamMaxPitchUp"] = "-45",
	["useZiplineCooldown"] = "0.4",
	["ziplineAcceleration"] = "400",
	["ziplineJumpOnAcceleration"] = "1000",
	["ziplineJumpOffDampScale"] = "1",
	["ziplineRollMax"] = "25",
	["rodeoViewdriftPitchScaleMin"] = "0.5",
	["rodeoViewdriftYawSpeedMin"] = "0.5",
	["aimAngleBackwardEnd"] = "-120",
	["cockpitSwayMinAnglePitch"] = "-0.5",
	["cockpitSwayMinAngleRoll"] = "-0.5",
	["cockpitSwayMaxAnglePitch"] = "0.5",
	["cockpitSwayTurnAngleFactor"] = "-0.6",
	["cockpit_spring_originDamping"] = "9",
	["cockpit_spring_rollConstant"] = "65",
	["damageImpulseScale"] = "1",
	["damageImpulseSpeedBoostLimit"] = "1000",
	["titan_footstep_damage"] = "5000",
	["titan_footstep_damage_interval"] = "1",
	["titan_footstep_damage_dist_interval"] = "150",
	["aimassist_bounds_override"] = "-1",
	["aimassist_adspull_centerRadius"] = "11",
	["aimassist_adspull_headshotRadius"] = "13",
	["gibSpeed"] = "400",
	["landingNoiseDuration"] = "0", //1
	["hardLandingNoiseRadius"] = "0", //50
	["magneticRange"] = "0",
	["aiEnemy_priority"] = "10",
	["camera_lcdStartupTime"] = "0",
	["canJumpWhileCrouched"] = "0",
	["doFaceAnim"] = "1",
	["localGravityBlendWhileWallrunning"] = "1",
	["jump"] = "1",
	["automantle"] = "1",
	["mantlePitchLeveling"] = "0",
	["jetpackScriptToActivate"] = "0",
	["jetpackToggleOn"] = "0",
	["jetpackToggleOff"] = "1",
	["jetpackZeroVerticalVelocityOnActivation"] = "1",
	["jetpackAfterburnerIsSticky"] = "1",
	["fx_jetwash_enabled"] = "1",
	["climbEnabled"] = "1",
	["player_wallrunOneHanded"] = "1",
	["player_slideBoostEnabled"] = "1",
	["grapple_touchGroundOnDetach"] = "0",
	["grapple_swingSticky"] = "1",
	["sharedEnergyAllowOveruse"] = "0",
	["context_action_can_use"] = "1",
	["stealthSounds"] = "1", //0,
	//NEW
	["landingNoiseRadius"] = "0",
	["jumpNoiseDuration"] = "0",
	["jumpNoiseRadius"] = "0",
	["landSlowdownDuration"] = "0"
}

global const table NO_AUDIO_SETTINGS = 
{
	//All Sounds
	["sound_boost_body_1p"] = "",
	["sound_boost_body_3p"] = "",
	["sound_boost_finish_1p"] = "",
	["sound_boost_finish_3p"] = "",
	["sound_boost_meter_depleted_1p"] = "",
	["sound_boost_meter_depleted_3p"] = "",
	["sound_boost_meter_fail_1p"] = "",
	["sound_boost_meter_fail_3p"] = "",
	["sound_boost_meter_recharged_1p"] = "",
	["sound_boost_meter_recharged_3p"] = "",
	["sound_boost_short_1p"] = "",
	["sound_boost_short_3p"] = "",
	["sound_boost_start_1p"] = "",
	["sound_boost_start_3p"] = "",
	["sound_climb_body_1p"] = "",
	["sound_climb_body_3p"] = "",
	["sound_climb_finish_1p"] = "",
	["sound_climb_finish_3p"] = "",
	["sound_climb_start_1p"] = "",
	["sound_climb_start_3p"] = "",
	["sound_crouchToStand_1p"] = "",
	["sound_crouchToStand_3p"] = "",
	["sound_dodge_1p"] = "",
	["sound_dodge_3p"] = "",
	["sound_dodgeFail"] = "",
	["sound_freefall_body_1p"] = "",
	["sound_freefall_body_3p"] = "",
	["sound_freefall_finish_1p"] = "",
	["sound_freefall_finish_3p"] = "",
	["sound_freefall_start_1p"] = "",
	["sound_freefall_start_3p"] = "",
	["sound_glide_body_1p"] = "",
	["sound_glide_body_3p"] = "",
	["sound_glide_finish_1p"] = "",
	["sound_glide_finish_3p"] = "",
	["sound_glide_start_1p"] = "",
	["sound_glide_start_3p"] = "",
	["sound_grapple_fire_1p"] = "",
	["sound_grapple_fire_3p"] = "",
	["sound_grapple_reel_in_target_1p"] = "",
	["sound_grapple_reel_in_target_3p"] = "",
	["sound_grapple_reset_1p"] = "",
	["sound_grapple_reset_3p"] = "",
	["sound_grapple_retract_1p"] = "",
	["sound_grapple_retract_3p"] = "",
	["sound_grapple_swing_1p"] = "",
	["sound_grapple_swing_3p"] = "",
	["sound_grapple_traverse_1p"] = "",
	["sound_grapple_traverse_3p"] = "",
	["sound_groundImpact"] = "",
	["sound_hover_body_1p"] = "",
	["sound_hover_body_3p"] = "",
	["sound_hover_finish_1p"] = "",
	["sound_hover_finish_3p"] = "",
	["sound_hover_start_1p"] = "",
	["sound_hover_start_3p"] = "",
	["sound_jetpack_afterburner_body_1p"] = "",
	["sound_jetpack_afterburner_body_3p"] = "",
	["sound_jetpack_afterburner_finish_1p"] = "",
	["sound_jetpack_afterburner_finish_3p"] = "",
	["sound_jetpack_afterburner_start_1p"] = "",
	["sound_jetpack_afterburner_start_3p"] = "",
	["sound_jetpack_body_1p"] = "",
	["sound_jetpack_body_3p"] = "",
	["sound_jetpack_finish_1p"] = "",
	["sound_jetpack_finish_3p"] = "",
	["sound_jetpack_start_1p"] = "",
	["sound_jetpack_start_3p"] = "",
	["sound_jetwash_body_1p"] = "",
	["sound_jetwash_body_3p"] = "",
	["sound_jetwash_finish_1p"] = "",
	["sound_jetwash_finish_3p"] = "",
	["sound_jetwash_start_1p"] = "",
	["sound_jetwash_start_3p"] = "",
	["sound_jumpjet_jet_body_1p"] = "",
	["sound_jumpjet_jet_body_3p"] = "",
	["sound_jumpjet_jet_finish_1p"] = "",
	["sound_jumpjet_jet_finish_3p"] = "",
	["sound_jumpjet_jet_start_1p"] = "",
	["sound_jumpjet_jet_start_3p"] = "",
	["sound_jumpjet_jump_body_1p"] = "",
	["sound_jumpjet_jump_body_3p"] = "",
	["sound_jumpjet_jump_finish_1p"] = "",
	["sound_jumpjet_jump_finish_3p"] = "",
	["sound_jumpjet_jump_start_1p"] = "",
	["sound_jumpjet_jump_start_3p"] = "",
	["sound_jumpjet_slide_start_1p"] = "",
	["sound_jumpjet_slide_start_3p"] = "",
	["sound_jumpjet_wallrun_body_1p"] = "",
	["sound_jumpjet_wallrun_body_3p"] = "",
	["sound_jumpjet_wallrun_finish_1p"] = "",
	["sound_jumpjet_wallrun_finish_3p"] = "",
	["sound_jumpjet_wallrun_start_1p"] = "",
	["sound_jumpjet_wallrun_start_3p"] = "",
	["sound_pain_layer1_end"] = "",
	["sound_pain_layer1_loop"] = "",
	["sound_pain_layer2_loop"] = "",
	["sound_pain_layer2_start"] = "",
	["sound_pain_layer3_end"] = "",
	["sound_pain_layer3_loop"] = "",
	["sound_slide_prefix"] = "",
	["sound_standToCrouch_1p"] = "",
	["sound_standToCrouch_3p"] = "",
	["sound_superJump"] = "",
	["sound_superJumpFail"] = "",
	["sound_wallHangComplete_1p"] = "",
	["sound_wallHangComplete_3p"] = "",
	["sound_wallHangFall"] = "",
	["sound_wallHangSlip"] = "",
	["sound_wallHangStart"] = "",
	["sound_wallrunFall_1p"] = "",
	["sound_wallrunFall_3p"] = "",
	["sound_wallrunImpact_1p"] = "",
	["sound_wallrunImpact_3p"] = "",
	["sound_wallrunSlip"] = ""
}
global enum eMovementType
{
	DISABLED = 0,
	TRUE_TF2_SETTINGS,
	TRUE_TF2_SETTINGS_HIGH_AIRACCEL,
	TRUE_TF2_SETTINGS_LOW_GRAV,
	CSGO_MOVEMENT,
	CSGO_MOVEMENT_HIGH_AIRACCEL,
	SURF_SETTINGS,
	HL1_MOVEMENT,
	HALO_MOVEMENT,
	SUPERGLIDE_BOOST_SETTINGS,
	INSTAGIB_PLAYER_SETTINGS,
	HAVEFUN_PLAYER_SETTINGS,
	HALO_MOVEMENT_NEW
}

global bool script_bGiveskins = false

struct
{
	void functionref(entity player ) ObserverThreadOverrideCallback = null
	int flowstate_modified_movement
	
	#if SERVER
		bool use_r2_deathcam
	#endif
} file


void function SV_CL_Onboarding_Init()
{
	OnboardingPlaylistSettings_Init()
	
	#if SERVER
		SetAutoReloadState( false ) //(mk): let native know
		RegisterSignal( "Flowstate_RestartLv4MagazinesThread" )
		FlagInit( "MinPlayersReached", false )
		
		RespawnBehavior_Init()
		AddCallback_OnPlayerKilled( OnPlayerKilled )
		AddCallback_OnClientConnected( OnClientConnected )
		AddCallback_OnClientConnecting( OnClientConnectionStarted )
		
		AddCallback_OnClientDisconnected( OnClientDisconnected )

		AddCallback_ItemFlavorLoadoutSlotDidChange_AnyPlayer( Loadout_CharacterClass(), OnCharacterClassChanged )
		foreach ( character in GetAllCharacters() )
			AddCallback_ItemFlavorLoadoutSlotDidChange_AnyPlayer( Loadout_CharacterSkin( character ), OnCharacterSkinChanged )

		//SetGameState( eGameState.WaitingForPlayers )

		if ( OnboardingEnabled() )
			thread Sequence_WaitingForPlayers()
		
		if( Gamemode() == eGamemodes.SURVIVAL )
			AddCallback_GameStateEnter( eGameState.Postmatch, void function() : (){ SetAutoReloadState( true ) } ) //(mk): check for native reload
	#endif
}

#if SERVER
/*
	███████╗███████╗ ██████╗ ██╗   ██╗███████╗███╗   ██╗ ██████╗███████╗███████╗
	██╔════╝██╔════╝██╔═══██╗██║   ██║██╔════╝████╗  ██║██╔════╝██╔════╝██╔════╝
	███████╗█████╗  ██║   ██║██║   ██║█████╗  ██╔██╗ ██║██║     █████╗  ███████╗
	╚════██║██╔══╝  ██║▄▄ ██║██║   ██║██╔══╝  ██║╚██╗██║██║     ██╔══╝  ╚════██║
	███████║███████╗╚██████╔╝╚██████╔╝███████╗██║ ╚████║╚██████╗███████╗███████║
	╚══════╝╚══════╝ ╚══▀▀═╝  ╚═════╝ ╚══════╝╚═╝  ╚═══╝ ╚═════╝╚══════╝╚══════╝
	
	This part describes the onboarding sequences: threaded functions which control the onboarding.
*/

void function Sequence_WaitingForPlayers()
{
	// Wait the absolute minimum delay, if required (0 by default)
	wait PreGame_GetWaitingForPlayersDelayMin()

	// Start to wait for players.
	// Countdown will be reached when the minimum amount of players join, or when the maximum delay is reached (if enabled).
	float timeSpentWaitingForPlayers = 0.0
	float maximumTimeToSpendToWaitForPlayers = PreGame_GetWaitingForPlayersDelayMax() - PreGame_GetWaitingForPlayersDelayMin()

	// bool shouldNotWaitForever = maximumTimeToSpendToWaitForPlayers > 0.0 && !PreGame_GetWaitingForPlayersWaitForeverEnabled()

	const float LOOP_INTERVAL = 0.1
	while ( !Flag( "MinPlayersReached" ) )
	{
		timeSpentWaitingForPlayers += LOOP_INTERVAL
		wait LOOP_INTERVAL

		int connectedPlayerCount = GetPlayerArray().len()

		// if ( shouldNotWaitForever 
			// && timeSpentWaitingForPlayers >= maximumTimeToSpendToWaitForPlayers
			// && connectedPlayerCount > 0
			// )
			// break
	}

	// Update to make client aware of the countdown
	UpdateSequencedTimePoints( Time() )

	bool introCountdownEnabled = CharSelect_GetIntroCountdownDuration() > 0.0
	
	if( Gamemode() != eGamemodes.SURVIVAL)
		wait PreGame_GetWaitingForPlayersCountdown() + (introCountdownEnabled ? 0.0 : CharSelect_GetIntroMusicStartTime()) - 1
	else
		wait PreGame_GetWaitingForPlayersCountdown() + (introCountdownEnabled ? 0.0 : CharSelect_GetIntroMusicStartTime())
	
	if( Gamemode() == eGamemodes.fs_aimtrainer )
		return

	if( Gamemode() != eGamemodes.SURVIVAL && Gamemode() != eGamemodes.WINTEREXPRESS )
	{
		foreach( player in GetPlayerArray() )
		{
			if( !IsValid( player ) )
				continue
			
			if( Gamemode() != eGamemodes.CUSTOM_CTF )
			{
				ScreenCoverTransition_Player( player, Time() + CharSelect_GetIntroTransitionDuration() )
			} 
			else
			{
				ScreenFade( player, 0, 0, 0, 255, 1, 0, FFADE_OUT | FFADE_STAYOUT )
			}
		}
	}
	
	#if TRACKER //todo(mk): add OnWaitingForPlayersEnd callbacks
		if( bLog() && !Tracker_IsBatchStatsLoaded() && Flowstate_IsTrackerSupportedMode() )
			waitthread WaitSignalOrTimeout( tracker.signalEnt, Tracker_GetMaxWaitForBatchLoad(), "BatchFetchComplete" )
	
		WaitFrame()
	#endif

	if ( GetCurrentPlaylistVarBool( "survival_commentary_champion_enabled", true ) && GetPlayerArray().len() > 0 )
	{
		#if !TRACKER 
			entity champion = GetPlayerArray().getrandom()
			SetChampion( champion )
		#endif
	}

	if ( !introCountdownEnabled )
		PlayPickLoadoutMusic( false )
	
	thread Sequence_PickLoadout()
}

void function Sequence_PickLoadout()
{
	if ( Playlist() == ePlaylists.fs_scenarios || !Survival_CharacterSelectEnabled() || Gamemode() != eGamemodes.SURVIVAL || Playlist() == ePlaylists.fs_haloMod_survival || Gamemode() == eGamemodes.fs_snd || Gamemode() == eGamemodes.fs_spieslegends ) 
	{
		foreach ( player in GetPlayerArray() )
		{
			ItemFlavor musicPack = LoadoutSlot_GetItemFlavor( ToEHI( player ), Loadout_MusicPack() )
			string skydiveMusicID = MusicPack_GetSkydiveMusic( musicPack )
			StopMusicOnPlayer( player, skydiveMusicID )
			
			if( Playlist() == ePlaylists.fs_haloMod_survival )
			{
				CharacterSelect_AssignCharacter( player, GetItemFlavorByGUID( ConvertItemFlavorGUIDStringToGUID( "SAID00898565421" ) ) )
			}
		}

		thread Sequence_Prematch() 
		return
	}

	// Assign character selection order to teams
	AssignLockStepOrder()

	ScreenCoverTransition_AllPlayers( Time() + CharSelect_GetIntroTransitionDuration() )
	wait CharSelect_GetIntroTransitionDuration()

	SetGameState( eGameState.PickLoadout )

	// Update future time points now that the delays should be predictable
	UpdateSequencedTimePoints( Time() )

	bool introCountdownEnabled = CharSelect_GetIntroCountdownDuration() > 0.0

	// Signalize that character selection sequence should be started clientside
	SetGlobalNetBool( "characterSelectionReady", true )

	if ( introCountdownEnabled )
	{
		wait CharSelect_GetIntroCountdownDuration() + (CharSelect_GetIntroMusicStartTime() - CharSelect_GetIntroTransitionDuration())
		PlayPickLoadoutMusic( true )
	}

	wait CharSelect_GetPickingDelayBeforeAll()

	for ( int pickIndex = 0; pickIndex < MAX_TEAM_PLAYERS; pickIndex++ )
	{
		float startTime = Time()

		float timeSpentOnSelection = Survival_GetCharacterSelectDuration( pickIndex ) + CharSelect_GetPickingDelayAfterEachLock()
		if ( pickIndex == 0 )
			timeSpentOnSelection += CharSelect_GetPickingDelayOnFirst()

		float endTime = startTime + timeSpentOnSelection

		SetGlobalNetInt( "characterSelectLockstepIndex", pickIndex )
		SetGlobalNetTime( "characterSelectLockstepStartTime", startTime )
		SetGlobalNetTime( "characterSelectLockstepEndTime", endTime )
		
		//compare player pick with GetLoadoutSlotContentsIndexInternal( playerEHI, entry ) before setting a forced pick
		// if( pickIndex == 0 ) 
		// {
			foreach ( player in GetAllPlayersOfLockstepIndex( pickIndex ) )
			{
				Flowstate_AssignUniqueCharacterForPlayer(player, false)
			}
		// }
		
		wait timeSpentOnSelection

		foreach ( player in GetAllPlayersOfLockstepIndex( pickIndex ) )
		{
			ItemFlavor selectedCharacter = LoadoutSlot_GetItemFlavor( ToEHI( player ), Loadout_CharacterClass() )
			CharacterSelect_AssignCharacter( player, selectedCharacter )
		}

		wait CharSelect_GetPickingDelayAfterEachLock()
	}

	// Reset selection step to lock all character selection loadout slots
	SetGlobalNetInt( "characterSelectLockstepIndex", MAX_TEAM_PLAYERS )

	foreach ( player in GetPlayerArray() )
		if ( !player.GetPlayerNetBool( "hasLockedInCharacter" ) )
			Flowstate_AssignUniqueCharacterForPlayer(player, true) // Joined too late, assign a random legend so everything runs fine

	wait CharSelect_GetPickingDelayAfterAll()

	wait CharSelect_GetOutroTransitionDuration() + CharSelect_GetOutroSceneChangeDuration() / 3.5 - CharSelect_GetPickingDelayAfterEachLock() * MAX_TEAM_PLAYERS

	if ( CharSelect_PlayerSquadIntroEnabled() ) {
		if ( CharSelect_PostSelectionMusicEnabled() )
			foreach ( player in GetPlayerArray() )
			{
				string skydiveMusicID = MusicPack_GetSkydiveMusic( LoadoutSlot_GetItemFlavor( ToEHI( player ), Loadout_MusicPack() ) )
				EmitSoundOnEntityOnlyToPlayer( player, player, skydiveMusicID )
			}

		wait CharSelect_GetOutroSquadPresentDuration() - CharSelect_GetOutroSceneChangeDuration() / 3.5
	}

	thread Sequence_Prematch()
}

void function Flowstate_AssignUniqueCharacterForPlayer(entity player, bool lock)
{
	// Warning( "Flowstate_AssignUniqueCharacterForPlayer" )
	// DumpStack()
	
	array< ItemFlavor > characters = clone GetAllCharacters()

	for ( int i = characters.len() - 1; i >= 0; i-- )
	{
		int playlistOpinion = GetItemFlavorPlaylistOpinion( ItemFlavor_GetHumanReadableRef( characters[ i ] ) )

		if( playlistOpinion == eItemFlavorPlaylistOpinion.LOCKED )
			characters.remove( i )
	}
	
	bool quit
	for ( int i = characters.len() - 1; i >= 0; i-- )
	{
		quit = false
		foreach ( squadMate in GetPlayerArrayOfTeam( player.GetTeam() ) )
		{
			if( quit )
				continue

			if( squadMate == player )
				continue
			
			ItemFlavor mateCharacter = LoadoutSlot_GetItemFlavor( ToEHI( squadMate ), Loadout_CharacterClass() )
			if( mateCharacter == characters[ i ] )
			{
				characters.remove( i )
				quit = true
			}
		}
	}

	ItemFlavor initialCharacter
	
	if( characters.len() == 0) //Shouldn't happen, but just in case. (Teams of more than 10 players probably)
		initialCharacter = GetAllCharacters().getrandom()
	else
		initialCharacter = characters.getrandom()
	
	player.SetPlayerNetInt( "characterSelectFocusIndex", ConvertItemFlavorToLoadoutSlotContentsIndex( Loadout_CharacterClass(), initialCharacter ) )
	
	CharacterSelect_AssignCharacter( player, initialCharacter )
	
	if( !lock || IsDevGamemode() || Gamemode() == eGamemodes.WINTEREXPRESS )
		player.SetPlayerNetBool( "hasLockedInCharacter", false )
}

void function Sequence_Prematch()
{
	SetGameState( eGameState.Prematch )

	// Update future time points now that the delays should be predictable
	UpdateSequencedTimePoints( Time() )

	if ( CharSelect_ChampionSquadIntroEnabled() )
		wait CharSelect_GetOutroChampionPresentDuration()

	if( Gamemode() == eGamemodes.fs_snd || Gamemode() == eGamemodes.fs_spieslegends )
		return
	
	// The gamemode handles everything past this point
	SetGameState( eGameState.Playing )
}

// Custom logic for sequence orchestration
void function UpdateSequencedTimePoints( float referenceTime, int gameStateOverride = -1 )
{
	SetGlobalNetInt( "gameState", GetGameState() )

	if( Playlist() == ePlaylists.fs_scenarios )
		return

	switch ( gameStateOverride != -1 ? gameStateOverride : GetGameState() )
	{
		case eGameState.WaitingForPlayers:
			SetGlobalNetTime( "PreGameStartTime", referenceTime + PreGame_GetWaitingForPlayersCountdown() )
			SetGlobalNetTime( "pickLoadoutGamestateStartTime", referenceTime + PreGame_GetWaitingForPlayersCountdown() + CharSelect_GetIntroTransitionDuration() + CharSelect_GetIntroCountdownDuration() )
			break
		case eGameState.PickLoadout:
			float timeBeforeCharacterSelection = CharSelect_GetIntroCountdownDuration() + CharSelect_GetPickingDelayBeforeAll()
		
			float timeToSelectAllCharacters = CharSelect_GetPickingDelayOnFirst()
			for ( int pickIndex = 0; pickIndex < MAX_TEAM_PLAYERS; pickIndex++ )
				timeToSelectAllCharacters += Survival_GetCharacterSelectDuration( pickIndex ) + CharSelect_GetPickingDelayAfterEachLock()
		
			float timeAfterCharacterSelection = CharSelect_GetPickingDelayAfterAll() + CharSelect_GetOutroTransitionDuration()

			float timeBeforeChampionPresentation = CharSelect_PlayerSquadIntroEnabled() ? CharSelect_GetOutroSquadPresentDuration() : 0.0
			float timeAfterChampionPresentation = CharSelect_ChampionSquadIntroEnabled() ? CharSelect_GetOutroChampionPresentDuration() : 0.0
				
			SetGlobalNetTime( "squadPresentationStartTime", referenceTime + timeBeforeCharacterSelection + timeToSelectAllCharacters + timeAfterCharacterSelection )
			SetGlobalNetTime( "championSquadPresentationStartTime", referenceTime + timeBeforeCharacterSelection + timeToSelectAllCharacters + timeAfterCharacterSelection + timeBeforeChampionPresentation )
			SetGlobalNetTime( "pickLoadoutGamestateEndTime", referenceTime + timeBeforeCharacterSelection + timeToSelectAllCharacters + timeAfterCharacterSelection + timeBeforeChampionPresentation + timeAfterChampionPresentation )
			break
	}
}

void function PlayPickLoadoutMusic( bool introCountdownEnabled )
{
	if ( !Survival_CharacterSelectEnabled() )
		return

	foreach ( player in GetPlayerArray() )
	{
		string pickLoadoutMusicID = MusicPack_GetCharacterSelectMusic( LoadoutSlot_GetItemFlavor( ToEHI( player ), Loadout_MusicPack() ) )
		EmitSoundOnEntityOnlyToPlayer( player, player, pickLoadoutMusicID )
	}

	wait fabs( CharSelect_GetIntroMusicStartTime() )

	if ( introCountdownEnabled )
		wait CharSelect_GetIntroTransitionDuration()
}

#endif

#if SERVER
/*
	██████╗  █████╗ ███████╗███████╗    ██████╗ ███████╗███████╗██████╗  █████╗ ██╗    ██╗███╗   ██╗
	██╔══██╗██╔══██╗██╔════╝██╔════╝    ██╔══██╗██╔════╝██╔════╝██╔══██╗██╔══██╗██║    ██║████╗  ██║
	██████╔╝███████║███████╗█████╗      ██████╔╝█████╗  ███████╗██████╔╝███████║██║ █╗ ██║██╔██╗ ██║
	██╔══██╗██╔══██║╚════██║██╔══╝      ██╔══██╗██╔══╝  ╚════██║██╔═══╝ ██╔══██║██║███╗██║██║╚██╗██║
	██████╔╝██║  ██║███████║███████╗    ██║  ██║███████╗███████║██║     ██║  ██║╚███╔███╔╝██║ ╚████║
	╚═════╝ ╚═╝  ╚═╝╚══════╝╚══════╝    ╚═╝  ╚═╝╚══════╝╚══════╝╚═╝     ╚═╝  ╚═╝ ╚══╝╚══╝ ╚═╝  ╚═══╝

	This part describes the base respawn (the bare minimum for a proper respawn) functions.
*/

void function TakeLoadoutRelatedWeapons( entity player )
{
	ItemFlavor character = LoadoutSlot_GetItemFlavor( ToEHI( player ), Loadout_CharacterClass() )

	// Shared
	if(IsValid(player.GetOffhandWeapon( OFFHAND_SLOT_FOR_CONSUMABLES )))
		player.TakeOffhandWeapon( OFFHAND_SLOT_FOR_CONSUMABLES )

	// Loadout meleeskin
	if(IsValid(player.GetNormalWeapon( WEAPON_INVENTORY_SLOT_PRIMARY_2 )))
		player.TakeNormalWeaponByIndexNow( WEAPON_INVENTORY_SLOT_PRIMARY_2 )
	
	if(IsValid(player.GetOffhandWeapon( OFFHAND_MELEE )))
		player.TakeOffhandWeapon( OFFHAND_MELEE )

	// Character related
	if(IsValid(player.GetOffhandWeapon( OFFHAND_TACTICAL )))
		player.TakeOffhandWeapon( OFFHAND_TACTICAL )
	if(IsValid(player.GetOffhandWeapon( OFFHAND_ULTIMATE )))
		player.TakeOffhandWeapon( OFFHAND_ULTIMATE )

	// if( GameRules_GetGameMode() == SURVIVAL )
	TakeAllPassives( player )
}

void function GiveLoadoutRelatedWeapons( entity player )
{
	TakeLoadoutRelatedWeapons(player)
	
	ItemFlavor character = LoadoutSlot_GetItemFlavor( ToEHI( player ), Loadout_CharacterClass() )
	ItemFlavor tactical = CharacterClass_GetTacticalAbility( character )
	ItemFlavor ultimate = CharacterClass_GetUltimateAbility( character )
	ItemFlavor passive = CharacterClass_GetPassiveAbility( character )
	
	player.GiveOffhandWeapon( CONSUMABLE_WEAPON_NAME, OFFHAND_SLOT_FOR_CONSUMABLES, [] )
	player.GiveOffhandWeapon( CharacterAbility_GetWeaponClassname( tactical ), OFFHAND_TACTICAL, [] )
	player.GiveOffhandWeapon( CharacterAbility_GetWeaponClassname( ultimate ), OFFHAND_ULTIMATE, [] )

	if( !Safe_is1v1EnabledAndAllowed() || Safe_isScenariosMode() ) // Todo: unweave gamemode logic ()
	{
		player.GiveWeapon( "mp_weapon_melee_survival", WEAPON_INVENTORY_SLOT_PRIMARY_2, [] )
		player.GiveOffhandWeapon( "melee_pilot_emptyhanded", OFFHAND_MELEE, [] )
	}

	if( !Flowstate_GivePassive() || !Flowstate_PassivesAllowedForMode() )
		return

	GivePassive( player, CharacterAbility_GetPassiveIndex( passive ) )

	if( ItemFlavor_GetHumanReadableRef( character ) == "character_caustic" || ItemFlavor_GetHumanReadableRef( character ) == "character_gibraltar" )
	{
		if( !PlayerHasPassive( player, ePassives.PAS_FORTIFIED) )
			GivePassive( player, ePassives.PAS_FORTIFIED )
	} 
	else if( ItemFlavor_GetHumanReadableRef( character ) == "character_crypto" )
	{
		if( !PlayerHasPassive( player, ePassives.PAS_CRYPTO ) )
			GivePassive( player, ePassives.PAS_CRYPTO )
	}
	
	//Supports perks
	if( ItemFlavor_GetHumanReadableRef( character ) == "character_lifeline" ||
		ItemFlavor_GetHumanReadableRef( character ) == "character_gibraltar" ||
		ItemFlavor_GetHumanReadableRef( character ) == "character_mirage" )
	{
		if( !PlayerHasPassive( player, ePassives.PAS_SUPPORT ) )
			GivePassive( player, ePassives.PAS_SUPPORT )

		if( !PlayerHasPassive( player, ePassives.PAS_BONUS_SMALL_HEAL ) )
			GivePassive( player, ePassives.PAS_BONUS_SMALL_HEAL )
	}
}

void function GiveLoadoutRelatedWeapons_HaloMod( entity player )
{	
	TakeLoadoutRelatedWeapons(player)

	player.GiveOffhandWeapon( CONSUMABLE_WEAPON_NAME, OFFHAND_SLOT_FOR_CONSUMABLES, [] )
	
	player.GiveWeapon( "mp_weapon_melee_survival", WEAPON_INVENTORY_SLOT_PRIMARY_2, [] )
	player.GiveOffhandWeapon( "melee_pilot_emptyhanded_halo", OFFHAND_MELEE, [] )
	
	player.GiveOffhandWeapon( "mp_ability_grapple_master_chief", OFFHAND_TACTICAL )
	player.GiveOffhandWeapon( "mp_weapon_bubble_bunker_master_chief", OFFHAND_ULTIMATE )

	GivePassive( player, ePassives.PAS_BATTERY_POWERED )
	
	// StatusEffect_AddEndless( player, eStatusEffect.minimap_jammed, 1.0 )
}

array<string> enabledMods = []
bool script_bHighlight = true
bool script_bRespawnInitComplete = false

void function RespawnBehavior_Init()
{
	table<string, string> possibleMods = {
		survival_jumpkit_enabled = "enable_doublejump",
		survival_wallrun_enabled = "enable_wallrun"
	}

	foreach ( playlistVar, modName in possibleMods )
		if ( GetCurrentPlaylistVarBool( playlistVar, false ) || GetCurrentPlaylistVarInt( "flowstate_modified_movement", 0 ) == 1 )
			enabledMods.append( modName )
	
	// Enables zero g
	if( GetCurrentPlaylistVarBool( "enable_zero_g", false ) )
		enabledMods.append( "zero_g" )

	// Enables ads hover
	if( GetCurrentPlaylistVarBool( "enable_ads_hover", false ) )
		enabledMods.append( "pas_ads_hover" )
	
	// Disable slides
	if( GetCurrentPlaylistVarBool( "disable_slide", false ) )
		enabledMods.append( "disable_slide" )
	
	// Removes teammates names
	if( GetCurrentPlaylistVarBool( "disable_targetinfo", false ) )
		enabledMods.append( "disable_targetinfo" )
	
	script_bRespawnInitComplete = true
}

void function DecideRespawnPlayer( entity player, bool giveLoadoutWeapons = true )
{
	#if DEVELOPER
		// Warning( "DecideRespawnPlayer: " + string( player ) )
		// DumpStack()
		mAssert( script_bRespawnInitComplete, "RespawnBehavior_Init() --- wasn't ready in DecideRespawnPlayer()" )
	#endif
	
	if ( !IsValid( player ) ) 
		return
	
	if ( IsAlive( player ) )
	 	TakeLoadoutRelatedWeapons( player )
		
	//(mk): This calls the definitive native code to respawn player, which will first fire "OnRespawnPlayer", and then fire signal "OnSpawned" in CodeCallback_OnPlayerRespawned
	DoRespawnPlayer( player, null )

	player.p.lastRespawnTime = Time()
	
	ItemFlavor playerCharacter = LoadoutSlot_GetItemFlavor( ToEHI( player ), Loadout_CharacterClass() )
	asset characterSetFile = CharacterClass_GetSetFile( playerCharacter )
	player.SetPlayerSettingsWithMods( characterSetFile, enabledMods )

	// Already executed in CodeCallback_OnPlayerRespawned
	// Remote_CallFunction_NonReplay( player, "ServerCallback_YouRespawned" )

	PlayerStopSpectating( player )

	// ItemFlavor playerCharacterSkin = LoadoutSlot_GetItemFlavor( ToEHI( player ), Loadout_CharacterSkin( playerCharacter ) )
	// CharacterSkin_Apply( player, playerCharacterSkin )
	player.AmmoPool_SetCapacity( 65535 )

	if ( giveLoadoutWeapons || Gamemode() == eGamemodes.map_editor_deprecated )
		GiveBasicSurvivalItems( player )

	Survival_SetInventoryEnabled( player, giveLoadoutWeapons )

	player.SetPlayerNetInt( "respawnStatus", eRespawnStatus.NONE )

	player.SetPlayerNetBool( "pingEnabled", true )
	player.SetHealth( player.GetMaxHealth() )

	UpdatePlayerCounts()
	
	if( Gamemode() == eGamemodes.map_editor_deprecated ) //todo move to mode specific callback
		thread (void function() : ( player )
		{
			if(IsValid(player.GetOffhandWeapon( OFFHAND_TACTICAL )))
			{
				player.TakeOffhandWeapon( OFFHAND_TACTICAL )
				player.GiveOffhandWeapon( "mp_weapon_editor", OFFHAND_TACTICAL, [] )
				player.SetActiveWeaponByName( eActiveInventorySlot.mainHand, "mp_weapon_editor" )
			}
			if(IsValid(player.GetOffhandWeapon( OFFHAND_ULTIMATE )))
				player.TakeOffhandWeapon( OFFHAND_ULTIMATE )
			
			wait 1
			Message(player, "PROP DYNAMIC MAP EDITOR", "Made by Sal, Fireproof, Pebbers & JustANormalUser. Misc fixes by CaféFPS.", 8)
		})()
		
	if( player.IsThirdPersonShoulderModeOn() )
		player.SetThirdPersonShoulderModeOn() // If you respawn in third person, it will automatically revert to first person, so turn it on again

	#if DEVELOPER
	SetSkydiveEmotesForAllCharacters( player )
	#endif

	//Set highlight to mantain retail behavior
	if( script_bHighlight )
	{
		Highlight_SetFriendlyHighlight( player, "sp_friendly_hero" )
	}
	
	Flowstate_ApplyModifiedMovementToPlayer( player ) //(mk)todo: check, shouldn't need to reapply every spawn.

	if( Playlist() == ePlaylists.fs_scenarios )
		return

	if( script_bGiveskins )
	{
		array<ItemFlavor> characterSkinsA = GetValidItemFlavorsForLoadoutSlot( ToEHI( player ), Loadout_CharacterSkin( LoadoutSlot_GetItemFlavor( ToEHI( player ), Loadout_CharacterClass() ) ) )
		CharacterSkin_Apply( player, characterSkinsA[characterSkinsA.len()-RandomIntRangeInclusive(1,4)])
	}

	//if( player.p.assignedCustomModel != -1 )//Custom models cause engine issues, disabling for now til models are updated. - Kral
	{
		//Flowstate_SetAssignedCustomModelToPlayer( player, player.p.assignedCustomModel )
	}
	//(mk): commented, already signaled in code callback after DoRespawnPlayer fires
	
	// if( Gamemode() != eGamemodes.SURVIVAL && Gamemode() != eGamemodes.WINTEREXPRESS )
		// player.Signal("OnRespawned")		
}

// clean up and move to main when completely debugged. Cafe
bool function DecideRespawnPlayer_Retail( entity player, bool allowSpawnAsObserver = false )
{
	// #if DEVELOPER
	// DumpStack()
	// #endif

	Assert( IsValid( player ), player + " is invalid!!" )
	Assert( !IsAlive( player ), player + " is already alive" )

	if ( !player.hasConnected || player.GetTeam() == TEAM_SPECTATOR )
	{
		printf( "%s() - player.hasConnected was false: %s", FUNC_NAME(), string( player ) )
		return false
	}

	if ( IsPVEMode() && (player.p.respawnCount == 0) )
		return false

	if ( (GetGameState() <= eGameState.WaitingForPlayers) && !PreGame_GetWaitingForPlayersSpawningEnabled() )
	{
		printf( "%s() - No spawning when waiting for players: %s", FUNC_NAME(), string( player ) )
		return false
	}

	if ( PlayerShouldObserve( player ) )
	{
		printf( "%s() - PlayerShouldObserve() was true: %s", FUNC_NAME(), string( player ) )
		if ( true ) //GamemodeUtility_IsSpectatorEnabled() ) review. Cafe
		{
			if ( IsPlayerEliminated( player ) && (GetGameState() == eGameState.Playing) && IsRoundBased() )
				SendHudMessage( player, "#GAMEMODE_RESPAWN_NEXT_ROUND", -1, 0.4, 255, 255, 255, 255, 1.0, 6.0, 1.0 )

			#if SERVER
				if ( file.ObserverThreadOverrideCallback != null )
					file.ObserverThreadOverrideCallback(player)
				else
					thread ObserverThread( player )
			#endif
		}

		return false
	}

	// if ( allowSpawnAsObserver )
		// player.AllowSpawnAsObserverOnce()

	printf( "%s() - Attempting to spawn: %s", FUNC_NAME(), string( player ) )
	bool didSpawn = RespawnTitanPilot( player )
	printf( "%s() - Spawn %s: %s", FUNC_NAME(), (didSpawn ? "success" : "failed"), string( player ) )

	return didSpawn
}


bool function RespawnTitanPilot( entity player )
{
	Assert( PlayerCanSpawn( player ), player + " cant spawn now" )

	if ( IsLobby() )
		return false

	DoRespawnPlayer( player, null )
	
	if( script_bHighlight )
	{
		Highlight_SetFriendlyHighlight( player, "sp_friendly_hero" )
	}
	
	Flowstate_ApplyModifiedMovementToPlayer( player )

	//if( player.p.assignedCustomModel != -1 )//Custom models cause engine issues, disabling for now til models are updated. - Kral
	{
		//Flowstate_SetAssignedCustomModelToPlayer( player, player.p.assignedCustomModel )
	}
	
	if( Playlist() == ePlaylists.fs_haloMod_survival )
	{
		CharacterSelect_AssignCharacter( player, GetItemFlavorByGUID( ConvertItemFlavorGUIDStringToGUID( "SAID00898565421" ) ) )
		player.SetPlayerNetBool( "hasLockedInCharacter", true )
		
		// HaloMod_HandlePlayerModel( player )
	}
	
	return true
}

void function SetCallback_ObserverThreadOverride( void functionref( entity player ) func  )
{
	file.ObserverThreadOverrideCallback = func
}

void function Flowstate_SetAssignedCustomModelToPlayer( entity player, int index )
{
	thread function () : ( index, player )
	{
		EndSignal( player, "OnDestroy" )
		WaitEndFrame()
		switch( index )
		{
			case 1:
			player.SetBodyModelOverride( $"mdl/Humans/pilots/w_blisk.rmdl" )
			player.SetArmsModelOverride( $"mdl/Humans/pilots/pov_blisk.rmdl" )
			break
			
			case 2:
			player.SetBodyModelOverride( $"mdl/Humans/pilots/w_phantom.rmdl" )
			player.SetArmsModelOverride( $"mdl/Humans/pilots/ptpov_phantom.rmdl" )
			break
			
			case 3:
			player.SetBodyModelOverride( $"mdl/Humans/pilots/w_amogino.rmdl" )
			player.SetArmsModelOverride( $"mdl/Humans/pilots/ptpov_amogino.rmdl" )
			break

			case 4:
			player.SetBodyModelOverride( $"mdl/Humans/pilots/w_rhapsody.rmdl" )
			player.SetArmsModelOverride( $"mdl/Humans/pilots/ptpov_rhapsody.rmdl" )
			break
			
			case 5:
			player.SetBodyModelOverride( $"mdl/Humans/pilots/w_ash_legacy.rmdl" )
			player.SetArmsModelOverride( $"mdl/Humans/pilots/pov_ash_legacy.rmdl" )
			break

			case 6:
			player.SetBodyModelOverride( $"mdl/Humans/pilots/w_jackcooper.rmdl" )
			player.SetArmsModelOverride( $"mdl/Humans/pilots/ptpov_jackcooper.rmdl" )
			break

			case 7:
			player.SetBodyModelOverride( $"mdl/Humans/pilots/pilot_medium_loba.rmdl" )
			player.SetArmsModelOverride( $"mdl/Humans/pilots/pov_pilot_medium_loba.rmdl" )
			break
			
			case 8:
			player.SetBodyModelOverride( $"mdl/Humans/pilots/pilot_heavy_revenant.rmdl" )
			player.SetArmsModelOverride( $"mdl/Humans/pilots/pov_pilot_heavy_revenant.rmdl" )
			break

			case 9: // ballistic
			player.SetBodyModelOverride( $"mdl/Humans/pilots/ballistic_base_w.rmdl" )
			player.SetArmsModelOverride( $"mdl/Humans/pilots/ballistic_base_v.rmdl" )
			break
			
			case 10: // mrvn
			player.SetBodyModelOverride( $"mdl/flowstate_custom/w_marvin.rmdl" )
			player.SetArmsModelOverride( $"mdl/Humans/pilots/ptpov_amogino.rmdl" )
			break

			case 11: // pete
			player.SetBodyModelOverride( $"mdl/flowstate_custom/w_pete_mri.rmdl" )
			player.SetArmsModelOverride( $"mdl/flowstate_custom/ptpov_pete_mri.rmdl" )
			break
		}
	}()	
}

void function SetSkydiveEmotesForAllCharacters( entity player ) // You need to unlock the loadout for this to work
{
	/*array< array< string > > emoteArrays = [ [ "skydive_emote_bangalore_backflip" ], [ "skydive_emote_bloodhound_backflip" ], [ "skydive_emote_caustic_backflip" ], [ "skydive_emote_gibraltar_backflip" , 
								"skydive_emote_gibraltar_surf" ], [ "skydive_emote_lifeline_backflip", "skydive_emote_lifeline_windmill" ], [ "skydive_emote_mirage_backflip", 
								"skydive_emote_mirage_rodeo" ], [ "skydive_emote_octane_backflip" ], [ "skydive_emote_pathfinder_backflip", "skydive_emote_pathfinder_birdattack" ], 
								[ "skydive_emote_wattson_backflip", "skydive_emote_wattson_explorer" ], [ "skydive_emote_wraith_backflip" ], [ "skydive_emote_revenant_backflip", "skydive_emote_revenant_snake" ] ]

	foreach( emoteArray in emoteArrays )
	{
		for( int i = 0; i < emoteArray.len(); i++ )
			ClientCommand( player, "loadouts_devset skydive_emote_" + i + " " + emoteArray[ i ] )
	}*/
}
#endif

#if SERVER
/*
	███████╗██████╗ ███████╗ ██████╗████████╗ █████╗ ████████╗██╗███╗   ██╗ ██████╗ 
	██╔════╝██╔══██╗██╔════╝██╔════╝╚══██╔══╝██╔══██╗╚══██╔══╝██║████╗  ██║██╔════╝ 
	███████╗██████╔╝█████╗  ██║        ██║   ███████║   ██║   ██║██╔██╗ ██║██║  ███╗
	╚════██║██╔═══╝ ██╔══╝  ██║        ██║   ██╔══██║   ██║   ██║██║╚██╗██║██║   ██║
	███████║██║     ███████╗╚██████╗   ██║   ██║  ██║   ██║   ██║██║ ╚████║╚██████╔╝
	╚══════╝╚═╝     ╚══════╝ ╚═════╝   ╚═╝   ╚═╝  ╚═╝   ╚═╝   ╚═╝╚═╝  ╚═══╝ ╚═════╝ 

	This part describes the spectator functions.
*/


void function PlayerStopSpectating( entity player )
{
	player.SetPlayerNetInt( "spectatorTargetCount", 0 )
	player.SetSpecReplayDelay( 0 )
	player.StopObserverMode()
}
#endif

#if SERVER
/*
	██████╗	 █████╗ ██╗     ██╗     ██████╗  █████╗  ██████╗██╗  ██╗███████╗
	██╔════╝██╔══██╗██║     ██║     ██╔══██╗██╔══██╗██╔════╝██║ ██╔╝██╔════╝
	██║     ███████║██║     ██║     ██████╔╝███████║██║     █████╔╝ ███████╗
	██║     ██╔══██║██║     ██║     ██╔══██╗██╔══██║██║     ██╔═██╗ ╚════██║
	╚██████╗██║  ██║███████╗███████╗██████╔╝██║  ██║╚██████╗██║  ██╗███████║
	 ╚═════╝╚═╝  ╚═╝╚══════╝╚══════╝╚═════╝ ╚═╝  ╚═╝ ╚═════╝╚═╝  ╚═╝╚══════╝

	This part describes the onboarding/shared gamemode callbacks.
*/

void function OnPlayerKilled( entity victim, entity attacker, var damageInfo )
{
	if ( !IsValid( victim ) || !IsValid( attacker ) )
		return
	
	if( Safe_is1v1EnabledAndAllowed() || Gamemode() == eGamemodes.fs_spieslegends )
	{
		int sourceId = DamageInfo_GetDamageSourceIdentifier( damageInfo )
		
		if ( sourceId == eDamageSourceId.damagedef_suicide || sourceId == eDamageSourceId.damagedef_despawn )
			return
	}
	
	UpdatePlayerCounts()
		
	if ( attacker.IsPlayer() && victim.IsPlayer() && attacker != victim )
		__IncrementPlayerNetInt( attacker, "kills" )
		
	if( Gamemode() == eGamemodes.SURVIVAL )
		Remote_CallFunction_NonReplay( victim, "ServerCallback_YouDied", attacker, GetHealthFrac( victim ), DamageInfo_GetDamageSourceIdentifier( damageInfo ), DamageInfo_GetDamage( damageInfo ) )

	victim.SetPlayerGameStat( PGS_DEATHS, victim.GetPlayerGameStat( PGS_DEATHS ) + 1 )
	if( Gamemode() != eGamemodes.CUSTOM_CTF && Gamemode() != eGamemodes.fs_snd )
		__IncrementPlayerNetInt( victim, "deaths" )

	victim.ClearParent()	
	victim.FreezeControlsOnServer()
	
	victim.SetPredictionEnabled( false )
	
	if( Gamemode() == eGamemodes.fs_spieslegends || Gamemode() == eGamemodes.fs_snd || Flowstate_IsHaloMode() && Playlist() != ePlaylists.fs_haloMod_survival ) //todo: init single bool conditional
		return
	
	victim.StartObserverMode( OBS_MODE_DEATHCAM )
	
	if( file.use_r2_deathcam && ShouldSetObserverTarget( attacker ) )
		victim.SetObserverTarget( attacker )
	else
		victim.SetObserverTarget( null )
}

void function ResetZiplineUseCountOnMantle( entity player )
{
	if( !IsValid( player ) )
		return
	
	//printt("Mantling, zipline use count reset.")
	
	player.p.ziplineUsages = 0
	Remote_CallFunction_NonReplay( player, "ServerCallback_NessyMessage", 40 ) //why
}

void function OnClientDisconnected( entity player )
{
	int connectedPlayerCount = GetPlayerArray().len() - 1
	SetGlobalNetInt( "connectedPlayerCount", connectedPlayerCount )
}

void function OnClientConnectionStarted( entity player )
{
	PlayerStopSpectating( player )
	GiveInitialTeamToPlayer( player )
	
	if( IsPlayerEliminated( player ) && GetGameState() == eGameState.WaitingForPlayers )
	{
		ClearPlayerEliminated( player )
	}
}

void function OnClientConnected( entity player )
{
	// Min players logic
	int connectedPlayerCount = GetPlayerArray().len()

	SetGlobalNetInt( "connectedPlayerCount", connectedPlayerCount )

	int minPlayers = GetCurrentPlaylistVarInt( "min_players", 1 )
	
	if ( connectedPlayerCount >= minPlayers && !Flag( "MinPlayersReached" ) )
		FlagSet( "MinPlayersReached" )

	// Min players logic end
	AddPlayerMovementEventCallback( player, ePlayerMovementEvents.MANTLE, ResetZiplineUseCountOnMantle )
	UpdatePlayerCounts()
	
	GiveInitialTeamToPlayer(player)

	if( GetCurrentPlaylistVarBool( "flowstate_give_random_custom_models_toall", false ) )
		player.p.assignedCustomModel = RandomIntRangeInclusive(1,10)
	else
		player.p.assignedCustomModel = -1
	
	
	if( Safe_is1v1EnabledAndAllowed() )
		player.p.playerCamo = RandomIntRangeInclusive( 1, 10 )
	
	bool replaceOrigin = false
	if( IsDevGamemode() || GetCurrentPlaylistVarBool( "is_practice_map", false ) || Playlist() == ePlaylists.fs_movementrecorder )
	{
		vector origin
		if( GetPlayerArray_Alive().len() > 0 && IsValid( GetPlayerArray_Alive()[0] ) )
		{
			origin = GetPlayerArray_Alive()[0].GetOrigin()
			replaceOrigin = true
		}
		
		PlayerMatchState_Set( player, ePlayerMatchState.NORMAL )
		
		if( !GetCurrentPlaylistVarBool( "is_practice_map", false ) )
		{
			Flowstate_AssignUniqueCharacterForPlayer(player, true)
			player.SetOrigin( origin )
		}

		player.p.survivalLandedOnGround = true
		player.p.respawnPodLanded = true
		
		DecideRespawnPlayer( player )
	} 
	else if( Gamemode() == eGamemodes.SURVIVAL && ( !IsDevGamemode() && !GetCurrentPlaylistVarBool( "is_practice_map", false ) && Playlist() != ePlaylists.fs_movementrecorder ) )
	{
		replaceOrigin = true
		
		if ( GetGameState() >= eGameState.Playing && !player.p.respawnPodLanded )
		{
			array<entity> teammates = GetPlayerArrayOfTeam_Alive( player.GetTeam() )

			// If we have no teammates and the plane exists we put the player in the plane
			// Or, if we have teammates in the plane we also put them in the plane with their team
			bool putInPlane                  = teammates.len() == 1 && IsValid( Sur_GetPlaneEnt() ) && !Flag( "PlaneAtLaunchPoint" )
			entity skydiveFollowPlayer
			bool skydiveFollowPlayerIsLeader = false
			entity groundPlayer
			foreach ( entity teammate in teammates )
			{
				if ( teammate == player )
					continue

				if ( teammate.GetPlayerNetBool( "playerInPlane" ) == true )
					putInPlane = true

				if ( PlayerMatchState_GetFor( teammate ) == ePlayerMatchState.SKYDIVE_FALLING && !skydiveFollowPlayerIsLeader )
				{
					skydiveFollowPlayer = teammate
					if ( teammate.GetPlayerNetBool( "isJumpmaster" ) )
					{
						skydiveFollowPlayerIsLeader = true
					}
				}

				if ( PlayerMatchState_GetFor( teammate ) == ePlayerMatchState.NORMAL )
					groundPlayer = teammate
			}

			if ( !putInPlane && !IsValid( skydiveFollowPlayer ) )
			{
				//If team is on the ground already, means that player has connected too late, which shouldn't be allowed to respawn in the game.
				//Let's put the player to spectate.
				
				if( !IsPlayerEliminated( player ) )
				{
					SetTeam( player, TEAM_SPECTATOR )
					SetPlayerEliminated( player )
				}
				
				player.SetPlayerNetInt( "respawnStatus", eRespawnStatus.NONE )
				
				printt( "[+] Player has connected too late, this is not allowed. Start spectating. Cafe" ) //Please don't remove my prints (:

				thread ObserverThread( player )
				Remote_CallFunction_ByRef( player, "ServerCallback_ShowDeathScreen" )
			} 
			else
			{
				DecideRespawnPlayer_Retail( player )
				GiveBasicSurvivalItems( player ) //If player is put in skydive mode and attached to its team mid-flight, we need to give them basic survival items here otherwise it will spawn without melee and basic items. Cafe
			}
		} 
		else
		{
			DecideRespawnPlayer_Retail( player )
		}
	}

	if( !replaceOrigin )
	{
		switch( MapName() )
		{
			case eMaps.mp_rr_eden:
				player.SetOrigin( <-0.76, -0.35, -0.06> )
				player.SetAngles( <-1.20, 17.66, 0> )
			break

			case eMaps.mp_rr_olympus:
			case eMaps.mp_rr_olympus_tt:
				player.SetOrigin( <-29181.76, -794.35, -4312.06> )
				player.SetAngles( <-1.20, 17.66, 0> )
			break
			case eMaps.mp_rr_olympus_mu1:
				player.SetOrigin( <373.503815, -20330.4629, -4138.41504> )
				player.SetAngles( <0, 68.0721817, 0> )
			break
			case eMaps.mp_rr_canyonlands_64k_x_64k:
			case eMaps.mp_rr_canyonlands_mu1:
			case eMaps.mp_rr_canyonlands_mu2:
			case eMaps.mp_rr_canyonlands_mu2_tt:
			case eMaps.mp_rr_canyonlands_mu1_night:				
				player.SetOrigin( <-3557.94165, 9962.51074, 3600> )
				player.SetAngles( <0, 65.3776093, 0> )
			break
			
			case eMaps.mp_rr_desertlands_holiday:
			case eMaps.mp_rr_desertlands_64k_x_64k:
			case eMaps.mp_rr_desertlands_64k_x_64k_nx:
			case eMaps.mp_rr_desertlands_64k_x_64k_mv:
			case eMaps.mp_rr_desertlands_64k_x_64k_tt:
			case eMaps.mp_rr_desertlands_mu1:
			case eMaps.mp_rr_desertlands_mu1_tt:
			case eMaps.mp_rr_desertlands_mu2:
				player.SetOrigin( <4838.49658, 13516.8604, -4025.90625> )
				player.SetAngles( <0, -136.298843, 0> )
			break
			
			default:
				entity startEnt = GetEnt( "info_player_start" )
				player.SetOrigin( startEnt.GetOrigin() )
				player.SetAngles( startEnt.GetAngles() )
			break
		}
	}

	player.p.isConnected = true
	player.Signal( "OnConnected" )
	
	thread Flowstate_CheckForLv4MagazinesAndRefillAmmo( player )
}

void function GiveInitialTeamToPlayer( entity player )
{
	if( IsPlayerEliminated( player ) )
	{
		EliminatedPlayerData data = GetPlayerEliminatedData( player )
		SetTeam( player, data.team ) // Assign the player to their pre-death team.
		
		#if DEVELOPER
			printw( "TEAMING - Player was eliminated, assigning old team", data.team )
		#endif

		return
	}
	
	int maxTeamSize = GetCurrentPlaylistVarInt( "max_team_size", 1 )
	maxTeamSize = maxTeamSize > 0 ? maxTeamSize : 1

	int maxPlayers = GetCurrentPlaylistVarInt( "max_players", 1 )
	maxPlayers = maxPlayers > 0 ? maxPlayers : 1

	int numTeams = maxPlayers / maxTeamSize
	
	#if DEVELOPER
		printw( "TEAMING - Team Size:", maxTeamSize, " - Num Teams: ", numTeams )
	#endif
	
	for( int i = TEAM_IMC; i <= TEAM_IMC + numTeams; i++ )
	{
		int teamSize = GetPlayerArrayOfTeam( i ).len()

		if( teamSize < maxTeamSize )
		{
			SetTeam( player, i )
			break
		}
	}
}

void function OnCharacterClassChanged( EHI playerEHI, ItemFlavor flavor )
{
	if ( GetGameState() < eGameState.Playing && !IsFiringRangeGameMode() || Playlist() == ePlaylists.fs_haloMod_survival )
		return

	entity player = FromEHI( playerEHI )
	if ( IsAlive( player ) ) 
	{	
		CharacterSelect_AssignCharacter( player, flavor, false )
		if( Gamemode() == eGamemodes.SURVIVAL )
			DecideRespawnPlayer( player, true )
		else
			DecideRespawnPlayer( player, false ) //(mk): Giving loadout related weapons here interferes with every custom gamemode in the codebase. Set to false. If your mode needs loadoutrelated weapons apply them.
	}
}

void function OnCharacterSkinChanged( EHI playerEHI, ItemFlavor flavor )
{
	if ( GetGameState() < eGameState.Playing && !IsFiringRangeGameMode() )
		return

	entity player = FromEHI( playerEHI )

	CharacterSkin_Apply( player, flavor )
}

array<int> function GetTeamsForPlayersFlowstate( array<entity> playersToUse )
{
	array<int> results
	foreach ( player in playersToUse )
	{
		int team = player.GetTeam()
		if ( !results.contains( team ) )
			results.append( team )
	}

	return results
}

void function UpdatePlayerCounts()
{
	int currGameMode = Gamemode()
	
	switch(currGameMode)
	{
		case eGamemodes.WINTEREXPRESS:
		{
			array<entity> playersAlive = GetPlayerArray_ConnectedNotSpectatorTeam()
			SetGlobalNetInt( "livingPlayerCount", playersAlive.len() )
			SetGlobalNetInt( "squadsRemainingCount", playersAlive.len() )		
			break
		}
		case eGamemodes.fs_infected:
		{
			SetGlobalNetInt( "livingPlayerCount", GetPlayerArrayOfTeam_Alive(TEAM_IMC).len() )
			SetGlobalNetInt( "livingShadowPlayerCount", GetPlayerArrayOfTeam_Alive(TEAM_MILITIA).len() )
			SetGlobalNetInt( "squadsRemainingCount", 2 )

			break
		}
		case eGamemodes.fs_dm:
		{
			if( Playlist() == ePlaylists.fs_scenarios )
			{
				foreach( player in GetPlayerArray() )
				{
					Remote_CallFunction_NonReplay( player, "FS_Scenarios_ForceUpdatePlayerCount", player )
				}
			}
			else
			{
				array<entity> connectedPlayers = GetPlayerArray_ConnectedNotSpectatorTeam()
				SetGlobalNetInt( "livingPlayerCount", connectedPlayers.len() )
				SetGlobalNetInt( "squadsRemainingCount", connectedPlayers.len() )
			}
			break
		}
		case eGamemodes.CUSTOM_CTF:
		{
			array<entity> connectedPlayers = GetPlayerArray_ConnectedNotSpectatorTeam()
			SetGlobalNetInt( "livingPlayerCount", connectedPlayers.len() )
			SetGlobalNetInt( "squadsRemainingCount", connectedPlayers.len() )		
			break
		}
		case eGamemodes.fs_prophunt:
		
		array<entity> propsAlive = GetPlayerArrayOfTeam_Alive( TEAM_MILITIA )
		SetGlobalNetInt( "livingPlayerCount", propsAlive.len() )
		SetGlobalNetInt( "squadsRemainingCount", propsAlive.len() )		
		break

		case eGamemodes.fs_prophunt:
		array<entity> propsAlive = GetPlayerArrayOfTeam_Alive( TEAM_MILITIA )
		SetGlobalNetInt( "livingPlayerCount", propsAlive.len() )
		SetGlobalNetInt( "squadsRemainingCount", propsAlive.len() )		
		break

		case eGamemodes.fs_spieslegends:
		array<entity> connectedPlayers = GetPlayerArray()
		SetGlobalNetInt( "livingPlayerCount", connectedPlayers.len() )
		SetGlobalNetInt( "squadsRemainingCount", connectedPlayers.len() )		
		break
		
		case eGamemodes.flowstate_pkknockback:
		{
			array<entity> playersAlive = GetPlayerArray_Alive()
			SetGlobalNetInt( "livingPlayerCount", playersAlive.len() )
			SetGlobalNetInt( "squadsRemainingCount", playersAlive.len() )		
			break
		}
		case eGamemodes.fs_duckhunt:
		{
			array<entity> ducksAlive = GetPlayerArrayOfTeam_Alive( TEAM_MILITIA )
			SetGlobalNetInt( "livingPlayerCount", ducksAlive.len() )
			SetGlobalNetInt( "squadsRemainingCount", ducksAlive.len() )		
			break
		}
		case eGamemodes.fs_snd:
		{
			foreach( player in GetPlayerArray() )
			{
				Remote_CallFunction_ByRef( player, "SND_ForceUpdatePlayerCount" )
				//Remote_CallFunction_NonReplay( player, "SND_ForceUpdatePlayerCount")
			}

			break
		}
		default:
		{
			SetGlobalNetInt( "livingPlayerCount", GetPlayerArray_AliveConnected().len() )
			SetGlobalNetInt( "squadsRemainingCount", GetNumTeamsRemaining() )		
			break
		}
	}
}
#endif

#if SERVER || CLIENT
/*
	██████╗	 ██████╗ ███╗   ██╗██████╗ ██╗████████╗██╗ ██████╗ ███╗   ██╗ █████╗ ██╗     ███████╗
	██╔════╝██╔═══██╗████╗  ██║██╔══██╗██║╚══██╔══╝██║██╔═══██╗████╗  ██║██╔══██╗██║     ██╔════╝
	██║     ██║   ██║██╔██╗ ██║██║  ██║██║   ██║   ██║██║   ██║██╔██╗ ██║███████║██║     ███████╗
	██║     ██║   ██║██║╚██╗██║██║  ██║██║   ██║   ██║██║   ██║██║╚██╗██║██╔══██║██║     ╚════██║
	╚██████╗╚██████╔╝██║ ╚████║██████╔╝██║   ██║   ██║╚██████╔╝██║ ╚████║██║  ██║███████╗███████║
	 ╚═════╝ ╚═════╝ ╚═╝  ╚═══╝╚═════╝ ╚═╝   ╚═╝   ╚═╝ ╚═════╝ ╚═╝  ╚═══╝╚═╝  ╚═╝╚══════╝╚══════╝

	This part describes customizable data which are used in sequence logic.
	The conditional functions usually get the value from the current playlist.
*/


// General
bool function OnboardingEnabled() 								{ return !GetCurrentPlaylistVarBool( "custom_onboarding", false ) }

// Waiting for players
bool function PreGame_GetWaitingForPlayersHasBlackScreen()		{ return GetCurrentPlaylistVarBool( "waiting_for_players_has_black_screen", false ) }
bool function PreGame_GetWaitingForPlayersSpawningEnabled()		{ return GetCurrentPlaylistVarBool( "waiting_for_players_spawning_enabled", false ) }
bool function PreGame_GetWaitingForPlayersWaitForeverEnabled() 	{ return GetCurrentPlaylistVarBool( "wait_for_players_forever", false ) }
float function PreGame_GetWaitingForPlayersDelayMin()			{ return GetCurrentPlaylistVarFloat( "waiting_for_players_min_wait", 0.0 ) }
float function PreGame_GetWaitingForPlayersDelayMax()			{ return GetCurrentPlaylistVarFloat( "waiting_for_players_timeout_seconds", 20.0 ) }
float function PreGame_GetWaitingForPlayersCountdown()			{ return GetCurrentPlaylistVarFloat( "waiting_for_players_countdown_seconds", 8.0 ) }

// Waiting for players -> character selection
float function CharSelect_GetIntroMusicStartTime()		 		{ return GetCurrentPlaylistVarFloat( "charselect_intro_music_start_time", -0.8 ) }
float function CharSelect_GetIntroTransitionDuration()			{ return GetCurrentPlaylistVarFloat( "charselect_intro_transition_duration", 3.0 ) }
float function CharSelect_GetIntroCountdownDuration()			{ return GetCurrentPlaylistVarFloat( "charselect_intro_countdown_duration", 0.0 ) }

// Character selection
float function CharSelect_GetPickingDelayBeforeAll()			{ return GetCurrentPlaylistVarFloat( "charselect_picking_delay_before_all", 0.0 ) }
float function CharSelect_GetPickingDelayOnFirst()				{ return GetCurrentPlaylistVarFloat( "charselect_picking_delay_on_first", 1.5 ) }
float function CharSelect_GetPickingSingleDurationMax()			{ return GetCurrentPlaylistVarFloat( "character_select_time_max", 8.0 ) }
float function CharSelect_GetPickingSingleDurationMin()			{ return GetCurrentPlaylistVarFloat( "character_select_time_min", 6.0 ) }
float function CharSelect_GetPickingDelayAfterEachLock()		{ return GetCurrentPlaylistVarFloat( "charselect_picking_delay_after_each_lock", 0.5 ) }
float function CharSelect_GetPickingDelayAfterAll()				{ return GetCurrentPlaylistVarFloat( "charselect_picking_delay_after_all", 1.5 ) }

// Character selection -> player squad -> champion squad -> outro
bool function CharSelect_PostSelectionMusicEnabled()			{ return GetCurrentPlaylistVarBool( "survival_enable_squad_intro_music", true ) }
bool function CharSelect_PlayerSquadIntroEnabled()				{ return GetCurrentPlaylistVarBool( "survival_enable_squad_intro", true ) }
bool function CharSelect_ChampionSquadIntroEnabled()			{ return GetCurrentPlaylistVarBool( "survival_enable_gladiator_intros", true ) }
float function CharSelect_GetOutroSceneChangeDuration()			{ return GetCurrentPlaylistVarFloat( "charselect_outro_scene_change_duration", 4.0 ) }
float function CharSelect_GetOutroSquadPresentDuration()		{ return GetCurrentPlaylistVarFloat( "charselect_outro_squad_present_duration", 6.0  ) }
float function CharSelect_GetOutroChampionPresentDuration()		{ return GetCurrentPlaylistVarFloat( "charselect_outro_champion_present_duration", 8.0 ) }
float function CharSelect_GetOutroTransitionDuration()			{ return GetCurrentPlaylistVarFloat( "charselect_outro_transition_duration", 3.0 ) }

// Custom logic
float function Survival_GetCharacterSelectDuration( int pickIndex )
{
	float min = CharSelect_GetPickingSingleDurationMin()
	float max = CharSelect_GetPickingSingleDurationMax()
	return GraphCapped( pickIndex, 0, MAX_TEAM_PLAYERS - 1, max, min )
}

bool function Survival_CharacterSelectEnabled()
{
	if ( Survival_GetCharacterSelectDuration( 0 ) <= 0.0 )
		return false

	return GetCurrentPlaylistVarBool( "charselect_enabled", true )
}
#endif

void function OnboardingPlaylistSettings_Init()
{
	//(mk): raising this limit in scripts has been deprecated as of Flowstate v4.5
	
	//int limit = 16 //200
		
	// #if DEVELOPER
		// limit = 99999
	// #endif
		
	// #if CLIENT
		// SetConVarInt( "cl_quota_stringCmdsPerSecond", limit )
	// #endif 
	
	#if SERVER
		//SetConVarInt( "sv_quota_stringCmdsPerSecond", limit )
		file.flowstate_modified_movement = GetCurrentPlaylistVarInt( "flowstate_modified_movement", 0 )
		file.use_r2_deathcam = GetCurrentPlaylistVarBool( "use_r2_deathcam", false )
	#endif
}

#if SERVER
void function SetPlayerSettings( entity player, table settings )
{
	foreach( k,v in settings )
	{
		//Thanks amos for this implementation <3. Cafe
		player.SetClassVar( expect string( k ), expect float( v ).tostring() )
	}
}

void function Flowstate_ApplyModifiedMovementToPlayer( entity player, bool resetOnly = false )
{
	if( file.flowstate_modified_movement == eMovementType.DISABLED )
		return

	if( resetOnly )
		return

	switch( file.flowstate_modified_movement )
	{
		case eMovementType.TRUE_TF2_SETTINGS: //1
		{
			player.SetMoveSpeedScale( 0.87 )		
			SetPlayerSettings( player, TRUE_TF2_SETTINGS )
			
			#if DEVELOPER
				printw( "Player movement changed to Titanfall 2 " + player )
			#endif
			break
		}
		case eMovementType.TRUE_TF2_SETTINGS_HIGH_AIRACCEL: //2
		{
			player.SetMoveSpeedScale( 0.87 )
			player.DisableMantle()
			SetPlayerSettings( player, TRUE_TF2_SETTINGS_HIGH_AIRACCEL )
			
			#if DEVELOPER
				printw( "Player movement changed to Titanfall 2 High Air Accel " + player )
			#endif
			break
		}
		case eMovementType.TRUE_TF2_SETTINGS_LOW_GRAV: //3
		{
			player.SetMoveSpeedScale( 0.87 )	
			SetPlayerSettings( player, TRUE_TF2_SETTINGS_LOW_GRAV )
			
			#if DEVELOPER
				printw( "Player movement changed to Titanfall 2 Low Gravity " + player )
			#endif
			break
		}
		case eMovementType.CSGO_MOVEMENT: //4
		{
			StatusEffect_AddEndless( player, eStatusEffect.move_slow, 0.1 )
			player.SetMoveSpeedScale( 1.38854974986041364747 )
			player.DisableMantle()
			player.SetGroundFrictionScale( 1.03125 )
			SetPlayerSettings( player, CSGO_MOVEMENT )
			
			#if DEVELOPER
				printw( "Player movement changed to CSGO " + player )
			#endif
			break
		}
		case eMovementType.CSGO_MOVEMENT_HIGH_AIRACCEL: //5
		{
			StatusEffect_AddEndless( player, eStatusEffect.move_slow, 0.1 )
			player.SetMoveSpeedScale( 1.38854974986041364747 )
			player.DisableMantle()
			player.SetGroundFrictionScale( 1.03125 )
			SetPlayerSettings( player, CSGO_MOVEMENT_HIGH_AIRACCEL )
			
			#if DEVELOPER
				printw( "Player movement changed to CSGO High Air Accel " + player )
			#endif
			break
		}
		case eMovementType.SURF_SETTINGS: //6
		{
			SetPlayerSettings( player, SURF_SETTINGS )
			
			#if DEVELOPER
				printw( "Player movement changed to (Apex) Surf " + player )
			#endif
			break
		}
		case eMovementType.HL1_MOVEMENT: //7
		{	
			StatusEffect_AddEndless( player, eStatusEffect.move_slow, 0.1 )
			player.SetMoveSpeedScale( 1.77840093365762835808 )
			player.DisableMantle()	
			SetPlayerSettings( player, HL1_MOVEMENT )
			
			#if DEVELOPER
				printw( "Player movement changed to Half-Life 1 " + player )
			#endif
			break
		}
		case eMovementType.HALO_MOVEMENT: //8
		{
			StatusEffect_AddEndless( player, eStatusEffect.move_slow, 0.1 )
			player.SetMoveSpeedScale( 1.1 )
			player.DisableMantle()
			SetPlayerSettings( player, HALO_MOVEMENT )

			#if DEVELOPER
				printw( "Player movement changed to Halo " + player )
			#endif
			break
		}
		case eMovementType.SUPERGLIDE_BOOST_SETTINGS: //9
		{
			SetPlayerSettings( player, SUPERGLIDE_BOOST_SETTINGS )
			
			#if DEVELOPER
				printw( "Superglide modified for all players " + player )
			#endif
			break
		}
		case eMovementType.INSTAGIB_PLAYER_SETTINGS: //10
		{
			SetPlayerSettings( player, INSTAGIB_PLAYER_SETTINGS )
			//Disable players collision
			player.kv.contents = CONTENTS_BULLETCLIP | CONTENTS_MONSTERCLIP | CONTENTS_HITBOX | CONTENTS_BLOCKLOS | CONTENTS_PHYSICSCLIP; //CONTENTS_PLAYERCLIP
			#if DEVELOPER
				printw( "Player movement changed to Insta-Gib " + player )
			#endif
			break
		}
		case eMovementType.HAVEFUN_PLAYER_SETTINGS: //11
		{
			SetPlayerSettings( player, HAVEFUN_PLAYER_SETTINGS )
			
			#if DEVELOPER
				printt( "Player movement changed to Have Fun Settings " + player )
			#endif
			break
		}
		case eMovementType.HALO_MOVEMENT_NEW: //HALO BETTER
		{
			SetPlayerSettings( player, HALO_MOVEMENT_NEW )
			player.SetMoveSpeedScale( 1.1 )
			player.DisableMantle()
			
			#if DEVELOPER
				printw( "Player movement changed to Halo New " + player )
			#endif
			break
		}
	}
}
#endif

#if SERVER
	table<int,table> movementLookupTable = {}
	bool bMovementLookupTableSet = false

	void function DEV_BuildMovementLookupTable()
	{
		movementLookupTable[ eMovementType.TRUE_TF2_SETTINGS ] <- TRUE_TF2_SETTINGS
		movementLookupTable[ eMovementType.TRUE_TF2_SETTINGS_HIGH_AIRACCEL ] <- TRUE_TF2_SETTINGS_HIGH_AIRACCEL
		movementLookupTable[ eMovementType.TRUE_TF2_SETTINGS_LOW_GRAV ] <- TRUE_TF2_SETTINGS_LOW_GRAV
		movementLookupTable[ eMovementType.CSGO_MOVEMENT ] <- CSGO_MOVEMENT
		movementLookupTable[ eMovementType.CSGO_MOVEMENT_HIGH_AIRACCEL ] <- CSGO_MOVEMENT_HIGH_AIRACCEL
		movementLookupTable[ eMovementType.SURF_SETTINGS ] <- SURF_SETTINGS
		movementLookupTable[ eMovementType.HL1_MOVEMENT ] <- HL1_MOVEMENT
		movementLookupTable[ eMovementType.HALO_MOVEMENT ] <- HALO_MOVEMENT
		movementLookupTable[ eMovementType.SUPERGLIDE_BOOST_SETTINGS ] <- SUPERGLIDE_BOOST_SETTINGS
		movementLookupTable[ eMovementType.INSTAGIB_PLAYER_SETTINGS ] <- INSTAGIB_PLAYER_SETTINGS
		movementLookupTable[ eMovementType.HAVEFUN_PLAYER_SETTINGS ] <- HAVEFUN_PLAYER_SETTINGS
		
		bMovementLookupTableSet = true
	}

	void function DEV_SetMovement( int enumVal )
	{
		int enumLen = eMovementType.len()
		
		if( enumVal > enumLen || enumVal < 0 )
		{
			Warning( "Invalid enum val:" + enumVal )
			return
		}

		array<entity> players = GetPlayerArray()
		ArrayRemoveInvalid( players )
		
		if( enumVal == 0 )
		{
			foreach( player in players )
			{
				ItemFlavor playerCharacter = LoadoutSlot_GetItemFlavor( ToEHI( player ), Loadout_CharacterClass() )
				asset characterSetFile = CharacterClass_GetSetFile( playerCharacter )
				player.SetPlayerSettingsWithMods( characterSetFile, [] )
			}
			
			return
		}
		
		if( !bMovementLookupTableSet )
			DEV_BuildMovementLookupTable()
		
		foreach( player in players )
			SetPlayerSettings( player, movementLookupTable[ enumVal ] )
			
		file.flowstate_modified_movement = enumVal
		string eMovementType = GetEnumString( "eMovementType", enumVal )
		Warning( "Player Movement set to: " + eMovementType )
	}
#endif