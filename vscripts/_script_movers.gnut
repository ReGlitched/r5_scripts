untyped

global function ScriptMovers_Init
global function ScriptedSwitchDeactivate
global function ScriptToyChangeStatusLights
global function ScriptedRotatorRotate
global function CodeCallback_PreBuildAINFile
global function GetNextMoverPathNodes
global function MoverThink

const FX_BARREL_EXPLOSION 						= $"P_spectre_suicide"
const FX_GENERATOR_EXPLOSION 					= $"xo_exp_death"
const FX_CONSOLE_EXPLOSION 						= $"xo_exp_death"
const FX_PANEL_EXPLOSION 						= $"P_drone_exp_md"
const FX_BARREL_FIRE_SMOKE						= $"P_fire_small_FULL"
const FX_GENERATOR_FIRE_SMOKE					= $"P_fire_med_FULL"
const FX_CONSOLE_FIRE_SMOKE						= $"P_fire_med_FULL"
const FX_PANEL_FIRE_SMOKE						= $"P_fire_small_FULL"

const SOUND_BARREL_EXPLODE 						= "corporate_spectre_death_explode"
const SOUND_GENERATOR_EXPLODE 					= "Goblin_Dropship_Explode"
const SOUND_PANEL_EXPLODE 						= "AngelCity_Scr_DroneExplodes"
const SOUND_CONSOLE_EXPLODE 					= "corporate_spectre_death_explode"

const FAN_PUSH_RAMP_TIME = 0.8
const FAN_DEFAULT_PUSH_ACCEL = 25000 // units/sec^2
const FAN_PUSH_ANTI_GRAVITY = 1000 // units/sec^2
const bool FAN_PUSH_DECAY_SIDE_VELOCITY = false
const bool FAN_DEBUG = false

const GRAPPLE_SWITCH_LEVER_MODEL_DEV			= $"mdl/test/roger_test/grapple_swtich_lever_dev.rmdl"
const GRAPPLE_SWITCH_LARGE_LEVER_MODEL_DEV		= $"mdl/test/roger_test/grapple_swtich_large_lever_dev.rmdl"

struct
{
	array<entity> scriptDoors
	array<entity> scriptSwitches
} file

struct ScriptMoverData
{
	bool isMoving
	bool isMoveSoundPlaying

	bool doEaseIn
	bool doEaseOut
	float pathSpeed

	string startFlag

	entity pathNode
	entity lastNode
}

void function ScriptMovers_Init()
{
	AddSpawnCallbackEditorClass( "prop_dynamic", 				"script_door", 				ScriptedDoorInit )
	AddSpawnCallbackEditorClass( "prop_dynamic", 				"script_switch", 			ScriptedSwitchInit )
	AddSpawnCallbackEditorClass( "script_mover_lightweight", 	"script_rotator", 			ScriptedRotatorThink )
	AddSpawnCallbackEditorClass( "script_mover_lightweight", 	"script_seesaw", 			SeeSawThink )

	AddSpawnCallback_ScriptName( "FanPusher", FanPusherThink )
	AddSpawnCallbackEditorClass( "info_target", "script_fan_pusher", FanPusherThink )

	PrecacheParticleSystem( FX_BARREL_EXPLOSION )
	PrecacheParticleSystem( FX_GENERATOR_EXPLOSION )
	PrecacheParticleSystem( FX_PANEL_EXPLOSION )
	PrecacheParticleSystem( FX_BARREL_FIRE_SMOKE )
	PrecacheParticleSystem( FX_GENERATOR_FIRE_SMOKE )
	PrecacheParticleSystem( FX_PANEL_FIRE_SMOKE )
	PrecacheParticleSystem( FX_CONSOLE_EXPLOSION )
	PrecacheParticleSystem( FX_CONSOLE_FIRE_SMOKE )

	// TEMP
	PrecacheModel( GRAPPLE_SWITCH_LEVER_MODEL_DEV )
	PrecacheModel( GRAPPLE_SWITCH_LARGE_LEVER_MODEL_DEV )

	AddSpawnCallback( "script_mover", MoverInit )
	AddSpawnCallback( "script_mover_lightweight", MoverInit )

	RegisterSignal( "OpenDoor" )
	RegisterSignal( "CloseDoor" )
	RegisterSignal( "OnDeactivate" )
	RegisterSignal( "OnActivate" )
	RegisterSignal( "StopRotating" )
	RegisterSignal( "ReachedPathNode" )
	RegisterSignal( "SwitchInitialized" )
	RegisterSignal( "SwitchActivate" )
	RegisterSignal( "SwitchReset" )
	RegisterSignal( "GrappleYank" )
	RegisterSignal( "GrappleLeverToggle" )
	RegisterSignal( "StopMoverThink" )
	RegisterSignal( "ReachedPathEnd" )

	// Train signals
	RegisterSignal( "OnArriveAtTrainNode" )
	RegisterSignal( "OnTrainStopping" )
	RegisterSignal( "OnTrainStopped" )
}

void function FlagControlsDoor( entity door, string flag )
{
	EndSignal( door, "OnDestroy" )
	while ( true )
	{
		WaitSignal( level, flag )
		if ( Flag( flag ) )
			Signal( door, "OpenDoor" )
		else
			Signal( door, "CloseDoor" )
	}
}

void function MotionActivatedDoor( entity door )
{
	bool doorOpen = false
	if ( door.HasKey( "startOpen" ) )
		doorOpen = ( door.kv.startOpen == "1" )

	EndSignal( door, "OnDestroy" )

	while ( true )
	{
		if ( doorOpen )
		{
			while ( ArrayEntityWithinDistance( GetPlayerArray(), door.GetOrigin(), 300 ) )
				wait 0.2
			Signal( door, "CloseDoor" )
		}
		else
		{
			while ( !ArrayEntityWithinDistance( GetPlayerArray(), door.GetOrigin(), 200 ) )
				wait 0.2
			Signal( door, "OpenDoor" )
		}
		doorOpen = !doorOpen
		wait 1
	}
}

void function CodeCallback_PreBuildAINFile()
{
	array<entity> doors = GetEntArrayByClass_Expensive( "prop_dynamic" )

	foreach ( entity door in doors )
	{
		if ( GetEditorClass( door ) != "script_door" )
			continue

		door.SetBoneFollowersSolid( false )
		array<entity> linkedEnts = door.GetLinkEntArray()
		foreach ( entity ent in linkedEnts )
		{
			if ( ent.GetClassName() == "func_brush" )
			{
				ent.NotSolid()
				break
			}
		}
	}
}

void function ScriptedDoorInit( entity door )
{
	//if ( GameModeRemove( door ) )
		//return

	//file.scriptDoors
	//array<entity> scriptSwitches

	#if DEVELOPER
	array validModels = [
		"mdl/door/door_416x288x32_rollupstyle01_animated.rmdl",
		"mdl/door/door_208x144x16_rollupstyle01_animated.rmdl",
		"mdl/door/door_imc_interior_03_128_animated.rmdl",
		"mdl/door/door_imc_interior_03_128_left_animated.rmdl",
		"mdl/door/pod_door_Hangar_IMC_01_animated.rmdl",
        "mdl/door/door_512x512x16_elevatorstyle01_animated.rmdl",
		"mdl/door/door_256x256x8_elevatorstyle01_animated.rmdl",
        "mdl/door/door_128x104x8_rolldownstyle01_animated.rmdl",
        "mdl/door/door_256x256x8_rolldownstyle01_animated.rmdl",
        "mdl/door/door_256_02_beacon_metal_door_animated.rmdl",
		"mdl/door/door_beacon_core_animated.rmdl",
        "mdl/door/door_128x104x8_elevatorstyle01_animated.rmdl"
        "mdl/door/door_marvin_animated.rmdl"
	]
	Assert( validModels.contains( string( door.GetModelName() ) ) , "Door model at " + door.GetOrigin() + " is invalid: " + door.GetModelName() )
	#endif

	EndSignal( door, "OnDestroy" )
	door.SetBlocksLOS( true )

	bool doorOpen = false
	if ( door.HasKey( "startOpen" ) )
		doorOpen = ( door.kv.startOpen == "1" )
	bool initializing = true

	if ( door.HasKey( "script_flag" ) )
	{
		string flag = expect string( door.kv.script_flag )
		FlagInit( flag )
		if ( Flag( flag ) )
			doorOpen = true
		if ( doorOpen )
			FlagSet( flag )
		thread FlagControlsDoor( door, flag )
	}

	string flagToggle
	if ( door.HasKey( "scr_flagToggle" ) )
	{
		flagToggle = expect string( door.kv.scr_flagToggle )
		FlagInit( flagToggle )
	}

	if ( door.HasKey( "motionActivated" ) && door.kv.motionActivated == "1" )
		thread MotionActivatedDoor( door )

	// We have to wait for all entities to finish loading before continuing before trying to get other linked entities
	FlagWait( "EntitiesDidLoad" )

	// The door can link to a func_brush that is the collision of the door. The collision will be enabled/disabled based on the door state
	entity clipBrush
	array<entity> linkedEnts = door.GetLinkEntArray()
	foreach ( entity ent in linkedEnts )
	{
		if ( ent.GetClassName() == "func_brush" )
		{
			clipBrush = ent
			break
		}
	}
	if ( IsValid( clipBrush ) )
	{
		clipBrush.Hide()
		clipBrush.NotSolid()
		WaitFrame()
	}

	while ( IsValid( door ) )
	{
		// UPDATE THE DOOR STATE
		if ( doorOpen )
			door.Anim_Play( "open" )
		else if ( !initializing )
			door.Anim_Play( "close" )

		if ( IsValid( clipBrush ) )
		{
			ToggleNPCPathsForEntity( clipBrush, doorOpen )
			if ( doorOpen )
			{
				clipBrush.Hide()
				clipBrush.NotSolid()
			}
			else
			{
				clipBrush.Show()
				clipBrush.Solid()
			}
		}
		else
		{
			// door must be setup with expensive bone_follower collision for this to work
			ToggleNPCPathsForEntity( door, doorOpen )
		}

		if ( flagToggle != "" )
		{
			if ( doorOpen )
				FlagSet( flagToggle )
			else
				FlagClear( flagToggle )
		}
		initializing = false

		// WAIT FOR STATE CHANGE
		if ( doorOpen )
			WaitSignal( door, "CloseDoor" )
		else
			WaitSignal( door, "OpenDoor" )

		CreateShakeRumbleOnly( door.GetOrigin(), 15, 150, 1 )

		doorOpen = !doorOpen
	}
}


void function ScriptedSwitchInit( entity button )
{
	#if DEVELOPER
	array<string> validModels = [
		"mdl/IMC_base/door_lock_large_imc_01.rmdl",
		"mdl/domestic/light_switch_touchscreen.rmdl",
		"mdl/props/pressure_plates/pressure_plate_titan_industrial_01.rmdl",
		"mdl/domestic/elevator_switch_01.rmdl",
		"mdl/beacon/crane_room_monitor_console.rmdl",
		"mdl/props/global_access_panel_button/global_access_panel_button_wall.rmdl",
		"mdl/props/global_access_panel_button/global_access_panel_button_console.rmdl"
		"mdl/props/grapple_switch/grapple_switch_small_animated.rmdl"
		"mdl/props/grapple_switch/grapple_switch_medium_animated.rmdl"
		"mdl/props/grapple_switch/grapple_switch_large_animated.rmdl"

		// TEMP
		"mdl/test/roger_test/grapple_switch_dev.rmdl"
                 
                                                     
      
	]

	Assert( validModels.contains( string( button.GetModelName() ) ), "Scripted switch model " + string( button.GetModelName() ) + " invalid" )
	#endif

	bool usesSkins
	int activeSkinID
	int inactiveSkinID

	switch ( string( button.GetModelName() ) )
	{
		case "mdl/props/global_access_panel_button/global_access_panel_button_wall.rmdl":
		case "mdl/props/global_access_panel_button/global_access_panel_button_console.rmdl":
		case "mdl/props/global_access_panel_button/global_access_panel_button_wall.rmdl":
		case "mdl/props/global_access_panel_button/global_access_panel_button_console.rmdl":
			usesSkins = true
			activeSkinID = 0
			inactiveSkinID = 1
			break
		case "mdl/beacon/crane_room_monitor_console.rmdl":
		case "mdl/beacon/crane_room_monitor_console.rmdl":
			usesSkins = true
			activeSkinID = 1
			inactiveSkinID = 2
			break
		default:
			usesSkins = false
			break
	}

	Highlight_SetNeutralHighlight( button, "sp_interact_object" )
	Highlight_SetFriendlyHighlight( button, "sp_interact_object" )
	Highlight_SetEnemyHighlight( button, "sp_interact_object" )
	Highlight_ClearNeutralHighlight( button )
	Highlight_ClearFriendlyHighlight( button )
	Highlight_ClearEnemyHighlight( button )

	EndSignal( button, "OnDestroy" )
	EndSignal( button, "OnDeactivate" )

	OnThreadEnd(
	function() : ( button )
		{
			// If we haven't destroyed the button, it must be inactive
			if ( IsValid( button ) )
			{
				//ScriptToyChangeStatusLights( button, $"runway_light_red" )
				Entity_StopFXArray( button )
				button.UnsetUsable()
				//button.Highlight_HideInside( 1.0 )
				//button.Highlight_HideOutline( 1.0 )
			}
		}
	)

	bool buttonActivated = false
	bool buttonIsSingleUse = false
	bool buttonIsToggleSwitch = false
	bool initialized = false
	bool buttonIsUsable = false
	bool buttonIsShootable = false
	float multiUseDelay = 0.2


	if ( button.HasKey( "shootable" ) )
		buttonIsShootable = ( button.kv.shootable == "1" )

	if ( button.GetModelName().find( "door_lock_large" ) > 0 )
		buttonIsShootable = true

	bool isPressurePlate = string( button.GetModelName() ) == "mdl/props/pressure_plates/pressure_plate_titan_industrial_01.rmdl"

	if ( isPressurePlate )
		button.kv.solid = 0 //hack until we can figure out why collision on this model kills titans when embarked

	if ( button.HasKey( "singleUse" ) )
		buttonIsSingleUse = ( button.kv.singleUse == "1" )

	 if ( buttonIsShootable )
		 buttonIsSingleUse = true

	if ( button.HasKey( "toggleSwitch" ) )
	{
		buttonIsToggleSwitch = ( button.kv.toggleSwitch == "1" )
		multiUseDelay = -1
	}

	if ( buttonIsShootable )
		buttonIsToggleSwitch = false


	if ( button.HasKey( "usable" ) )
		buttonIsUsable = ( button.kv.usable == "1" )

	if ( button.HasKey( "multiUseDelay" ) )
	{
		multiUseDelay = float( button.kv.multiUseDelay )
		if ( multiUseDelay > 0.0 )
			Assert( !buttonIsSingleUse, "script_switch at " + button.GetOrigin() + "has multiUseDelay set and is single use" )
	}

	string flagToggle
	if ( button.HasKey( "scr_flagToggle" ) )
	{
		flagToggle = expect string( button.kv.scr_flagToggle )
		FlagInit( flagToggle )
	}

	string flagRequired
	if ( button.HasKey( "scr_flagRequired" ) )
	{
		flagRequired = expect string( button.kv.scr_flagRequired )
		FlagInit( flagRequired )
	}

	string hintString_hold = "#HOLD_TO_USE_GENERIC"
	if ( button.HasKey( "hintString_hold" ) && button.kv.hintString_hold != "" )
		hintString_hold = string( button.kv.hintString_hold )
	string hintString_press = "#PRESS_TO_USE_GENERIC"
	if ( button.HasKey( "hintString_press" ) && button.kv.hintString_press != "" )
		hintString_press = string( button.kv.hintString_press )

	// We have to wait for all entities to finish loading before continuing before trying to get other linked entities
	FlagWait( "EntitiesDidLoad" )

	array<entity> linkedDoors = GetLinkedEntsByEditorClass( button, "script_door" )
	array<entity> linkedSwitches
	linkedSwitches.extend( GetLinkedEntsByEditorClass( button, "script_switch" ) )
	foreach ( entity door in linkedDoors )
		linkedSwitches.extend( GetParentLinkedEntsByEditorClass( door, "script_switch" ) )
	linkedSwitches.fastremovebyvalue( button )

	//need a trigger for pressure plate unless it's just for show
	entity trigger
	array<entity> linkedTriggers = GetLinkedEntsByClassName( button, "trigger_multiple" )
	if ( linkedTriggers.len() > 0 )
		trigger = linkedTriggers[0]
	if ( ( isPressurePlate ) && ( buttonIsUsable ) )
		Assert( IsValid( trigger ), "script_switch pressure plate at " + button.GetOrigin() + " needs to link to a trigger_multiple" )

	if ( isPressurePlate && buttonIsUsable )
	{
		Assert( IsValid( trigger ), "pressure plate switch at " + button.GetOrigin() + " requires a triggerTarget to activate" )
		Assert( trigger.GetClassName() == "trigger_multiple", "pressure plate switch at "  + button.GetOrigin() + " requires a trigger_multiple to activate" )
		Assert( trigger.kv.spawnflags == "3", "Trigger for pressure plate at " + button.GetOrigin() + " needs spawnflags set to 3" )
	}

	if ( !isPressurePlate )
	{
		button.SetUsable()
		button.SetUsableByGroup( "pilot" )
		button.SetUsePrompts( hintString_hold, hintString_press )
		//button.Highlight_ShowInside( 1.0 )
		//button.Highlight_ShowOutline( 1.0 )
	}
	if ( buttonIsShootable )
	{
		//prompts exist to tell you to shoot
		button.SetUsePrompts( "#BUTTON_HINT_SHOOT_LOCK", "#BUTTON_HINT_SHOOT_LOCK" )
	}

	bool allowGrapple = string( button.GetModelName() ).find_olduntyped( "grapple" ) != null
	if ( allowGrapple )
	{
		AddEntityCallback_OnGrappled( button, GrappleSwitchActivate )

		// spawn and attach the lever, also manage moving it when the "button" is used.
		if ( string( button.GetModelName() ).find_olduntyped( "_dev" ) )
			thread HACK_GrappleSwitchLever( button, multiUseDelay, buttonIsSingleUse, buttonIsToggleSwitch, flagToggle )
	}

	bool buttonUsedOnce = false

	button.Signal( "SwitchInitialized" )

	while ( IsValid( button ) )
	{
		//-------------------------
		// UPDATE EFFECTS
		//-------------------------

		if ( buttonActivated )
		{
			//ScriptToyChangeStatusLights( button, $"runway_light_red" )
			Entity_StopFXArray( button )
			if ( usesSkins )
				button.SetSkin( inactiveSkinID )
			if ( allowGrapple )
				GrappleAutoAim_RemoveTarget( button )
		}
		else
		{
			ScriptToyChangeStatusLights( button, $"runway_light_green" )
			if ( usesSkins )
				button.SetSkin( activeSkinID )
			if ( allowGrapple )
				GrappleAutoAim_AddTarget( button )
		}

		if ( !buttonIsUsable )
			break 		//exit loop if we just want the pretty lights, but no player usability

		if ( buttonIsSingleUse && buttonUsedOnce )
			break 		//exit loop if this is a single use button

		if ( isPressurePlate )
		{
			//-------------------------
			// WAIT FOR STATE CHANGE (PRESSURE PLATE)
			//-------------------------

			if ( buttonActivated )
				waitthread PressurePlateWaitSignal( trigger, "OnEndTouchAll" )
			else
				waitthread PressurePlateWaitSignal( trigger, "OnTrigger" )
		}
		else
		{
			if ( flagRequired != "" && !Flag( flagRequired ) )
			{
				if ( !isPressurePlate )
				{
					if ( button.HasKey( "disabledHintString" ) )
						button.SetUsePrompts( button.kv.disabledHintString, button.kv.disabledHintString )
					else
						button.UnsetUsable()
				}

				//ScriptToyChangeStatusLights( button, $"runway_light_red" )
				Entity_StopFXArray( button )
				if ( usesSkins )
					button.SetSkin( inactiveSkinID )
				FlagWait( flagRequired )
				ScriptToyChangeStatusLights( button, $"runway_light_green" )
				if ( usesSkins )
					button.SetSkin( activeSkinID )
				button.SetUsePrompts( hintString_hold, hintString_press )
				button.SetUsable()
			}

			//-------------------------
			// WAIT FOR STATE CHANGE (SIMPLE PUSH BUTTON)
			//-------------------------

			if ( buttonActivated )
			{
				thread ScriptSwitchWaitForReset( button, buttonIsToggleSwitch, multiUseDelay, flagToggle )
				WaitSignal( button, "SwitchReset" )
			}
			else
			{
				thread ScriptSwitchWaitForActivation( button, flagToggle, buttonIsShootable )
				WaitSignal( button, "SwitchActivate" )
			}
		}

		//--------------------------------------
		// Player activated, switch button state
		//--------------------------------------

		buttonUsedOnce = true
		buttonActivated = !buttonActivated

		EmitSoundOnEntity( button, "Switch_Activate" )

		button.Signal( "OnActivate" )

		if ( !isPressurePlate && buttonActivated && !buttonIsToggleSwitch )
		{
			button.UnsetUsable() //make the button unusable right after clicking so player doesn't double hit it
			//button.Highlight_HideInside( 1.0 )
			//button.Highlight_HideOutline( 1.0 )
		}

		//------------
		// SET FLAGS
		//------------

		// Button activated (green)
		if ( flagToggle != "" && buttonActivated )
		{
			FlagSet( flagToggle )
		}

		if ( buttonActivated )
			SpawnSpawnersLinkedToButton( button, button.e.usePlayer )

		//else if ( buttonActivated && isPressurePlate )
		//	wait 1.5	//wait a bit before re-enabling the usability

		// Button deactivated (red)
		if ( flagToggle != "" && !buttonActivated )
			FlagClear( flagToggle )

		//-------------------------------------------------------
		// Open Linked Doors (alternate method instead of flags)
		//-------------------------------------------------------

		foreach ( entity door in linkedDoors )
		{
			if ( buttonActivated )
				Signal( door, "OpenDoor" )
			else
				Signal( door, "CloseDoor" )
		}

		//-----------------------------------------------------------------
		// Make other linked switches toggle to the same state as this one
		//-----------------------------------------------------------------

		foreach ( entity linkedSwitch in linkedSwitches )
		{
			if ( buttonActivated )
				Signal( linkedSwitch, "SwitchActivate" )
			else
				Signal( linkedSwitch, "SwitchReset" )
		}

		//---------------------
		// Change Usable State
		//---------------------

		if ( !buttonActivated )
		{
			button.SetUsable()
			//button.Highlight_ShowInside( 1.0 )
			//button.Highlight_ShowOutline( 1.0 )
		}

		//-------------------------------------------------------
		// Animate Grapple Switches)
		//-------------------------------------------------------
		if ( allowGrapple )
			GrappleSwitchToggleLever( button, buttonActivated )

		button.e.usePlayer = null
	}

	if ( ( isPressurePlate ) && ( IsValid( trigger ) ) )
	{
		trigger.Destroy()
	}
	else
	{
		button.UnsetUsable()
		//button.Highlight_HideInside( 1.0 )
		//button.Highlight_HideOutline( 1.0 )
	}
}

void function ScriptSwitchWaitForActivation( entity button, string flagToggle, bool buttonIsShootable )
{
	OnThreadEnd(
		function() : ( button )
		{
			if ( IsValid( button ) )
				Signal( button, "SwitchActivate" )
		}
	)
	if ( flagToggle != "" )
		FlagEnd( flagToggle )

	button.EndSignal( "SwitchActivate" )

	if ( buttonIsShootable )
		thread ScriptSwitchWaitForActivationByDamage( button, flagToggle, buttonIsShootable )


	while ( true )
	{
		entity player = expect entity( button.WaitSignal( "OnPlayerUse" ).player )
		if ( buttonIsShootable )
			continue
		if ( IsValid( player ) && player.IsPlayer() )
			return
	}
}

void function ScriptSwitchWaitForActivationByDamage( entity button, string flagToggle, bool buttonIsShootable )
{
	OnThreadEnd(
		function() : ( button )
		{
			if ( IsValid( button ) )
				Signal( button, "SwitchActivate" )
		}
	)

	if ( flagToggle != "" )
		FlagEnd( flagToggle )

	button.EndSignal( "SwitchActivate" )

	//float currentHealth = 20
	while ( true )
	{
		table result = WaitSignal( button, "OnDamaged" )
		entity activator = expect entity( result.activator )
		float damage = expect float( result.value )
		if ( !IsValid( damage ) )
			continue
		if ( !IsValid( activator ) )
			continue
		if ( !activator.IsPlayer() )
			continue

		//currentHealth -= damage

		//if ( currentHealth <= 0 )
			//break

		break //as long as it's player damage, one bullet will do
	}

	EmitSoundOnEntity( button, "weapon_sentryfragdrone_explo" )
	StartParticleEffectOnEntity( button, GetParticleSystemIndex( FX_PANEL_EXPLOSION ), FX_PATTACH_ABSORIGIN_FOLLOW, -1 )
	PlayFX( FX_BARREL_FIRE_SMOKE, button.GetOrigin(), button.GetAngles() )

}

void function ScriptSwitchWaitForReset( entity button, bool buttonIsToggleSwitch, float multiUseDelay, string flagToggle )
{
	if ( multiUseDelay > 0.0 )
		thread ScriptSwitchWaitForReset_Timeout( button, multiUseDelay )
	if ( buttonIsToggleSwitch )
		thread ScriptSwitchWaitForReset_PlayerUse( button )
	if ( flagToggle != "" )
		thread ScriptSwitchWaitForReset_FlagCleared( button, flagToggle )
}

void function ScriptSwitchWaitForReset_Timeout( entity button, float multiUseDelay )
{
	//EndSignal( button, "SwitchActivate" )
	EndSignal( button, "SwitchReset" )
	EndSignal( button, "OnDeath" )
	EndSignal( button, "OnDestroy" )

	wait multiUseDelay

	Signal( button, "SwitchReset" )
}

void function ScriptSwitchWaitForReset_PlayerUse( entity button )
{
	//EndSignal( button, "SwitchActivate" )
	EndSignal( button, "SwitchReset" )
	EndSignal( button, "OnDeath" )
	EndSignal( button, "OnDestroy" )

	while ( true )
	{
		entity player = expect entity( button.WaitSignal( "OnPlayerUse" ).player )
		if ( IsValid( player ) && player.IsPlayer() )
			break
	}

	Signal( button, "SwitchReset" )
}

void function ScriptSwitchWaitForReset_FlagCleared( entity button, string flagToggle )
{
	//EndSignal( button, "SwitchActivate" )
	EndSignal( button, "SwitchReset" )
	EndSignal( button, "OnDeath" )
	EndSignal( button, "OnDestroy" )

	FlagWaitClear( flagToggle )

	Signal( button, "SwitchReset" )
}

void function SpawnSpawnersLinkedToButton( entity button, entity activator )
{
	foreach ( entity linkedEnt in button.GetLinkEntArray() )
	{
		if ( IsStalkerRack( linkedEnt ) )
		{
			thread SpawnFromStalkerRack( linkedEnt, activator )
		}
		else if ( IsSpawner( linkedEnt ) )
		{
			entity spawned = linkedEnt.SpawnEntity()
			DispatchSpawn( spawned )
		}
		else
		{
			Signal( linkedEnt, "OpenDoor" )
		}
	}
}

void function ScriptedSwitchDeactivate( entity button )
{
	Assert( IsValid( button ) )
	button.Signal( "OnDeactivate" )
}

void function ScriptToyChangeStatusLights( entity button, asset fxName )
{
	//--------------------------
	// Kill any previous effects
	//--------------------------
	Entity_StopFXArray( button )

	//--------------------------
	// Start new effects at tags
	//--------------------------
	array<entity> newFxLights
	array<string> fxTags
	entity newFx
	int index = 0
	string tagName

	while ( true )
	{
		tagName = "light" + index
		int id = button.LookupAttachment( tagName )
		if ( id == 0 )
			break

		newFx = PlayLoopFXOnEntity( fxName, button, tagName )
		newFxLights.append( newFx )

		index++
	}

	button.e.fxArray = newFxLights
}

void function PressurePlateWaitSignal( entity trigger, string waitSignal )
{
	//waitSignal is either "OnTrigger" or "OnEndTouchAll"

	trigger.EndSignal( "OnDestroy" )
	table result //hack. Result info from triggers

	while ( IsValid( trigger ) )
	{
		result = trigger.WaitSignal( waitSignal )

		if ( !IsValid( result.activator ) )
			continue
		if ( !result.activator.IsTitan() )
			continue
		if ( result.activator.IsPlayer() )
			break
	}
}

void function GrappleSwitchActivate( entity player, entity hitent, vector hitpos, vector hitNormal )
{
	player.EndSignal( "OnDeath" )
	hitent.EndSignal( "OnDestroy" )

	if ( hitent.GetUsableValue() == 0 )
		return

	PlayGrappleAttachedAnimation( player, "ptpov_cloudcity_grapple_switch" )

	bool buttonIsSingleUse = true
	if ( hitent.HasKey( "singleUse" ) )
		buttonIsSingleUse = (hitent.kv.singleUse == "1" )

	float multiUseDelay = 0.02
	if ( hitent.HasKey( "multiUseDelay" ) )
	{
		multiUseDelay = float(hitent.kv.multiUseDelay)
		if ( multiUseDelay > 0.0 )
			Assert( !buttonIsSingleUse, "script_switch at " + hitent.GetOrigin() + "has multiUseDelay set and is single use" )
	}

	entity proxy = player.GetPredictedFirstPersonProxy()
	proxy.EndSignal( "OnDestroy" )
	proxy.WaitSignal( "GrappleYank" )

	hitent.Signal( "OnPlayerUse", { player = player } )
}

void function GrappleSwitchToggleLever( entity button, bool buttonActivated )
{
	bool devModel = string( button.GetModelName() ).find_olduntyped( "_dev" ) != null
	if ( devModel )
	{
		button.Signal( "GrappleLeverToggle", { buttonActivated = buttonActivated } )
	}
	else
	{
		if ( buttonActivated )
		{
			printt( "animating switch", buttonActivated )
			PlayAnim( button, "grapple_switch_on" )
		}
		else
		{
			printt( "reseting switch", buttonActivated )
			PlayAnim( button, "grapple_switch_off" )
		}
	}
}

void function HACK_GrappleSwitchLever( entity button, float multiUseDelay, bool buttonIsSingleUse, bool buttonIsToggleSwitch, string flagToggle )
{
	asset levelModel = GRAPPLE_SWITCH_LEVER_MODEL_DEV
	
                 
                                                                                     
                                                   
      

	entity lever = CreateScriptMoverModel( levelModel )
	lever.SetParent( button, "Lever", false, 0 )
	lever.NonPhysicsSetRotateModeLocal( true )

	while ( true )
	{
		table results = WaitSignal( button, "GrappleLeverToggle" )
		bool buttonActivated = expect bool( results.buttonActivated )
		if ( buttonActivated )
		{
			printt( "animating switch" )
			lever.NonPhysicsRotateTo( <0,0,150>, 0.5, 0.5, 0.0 )
		}
		else
		{
			printt( "reseting switch" )
			lever.NonPhysicsRotateTo( <0,0,0>, 1, 0.50, 0.0 )
		}

		if ( buttonIsSingleUse )
			return
	}
}

void function ScriptedRotatorThink( entity rotator )
{
	rotator.Hide()

	if ( rotator.HasKey( "use_local_rotation" ) && ( rotator.kv.use_local_rotation == "1" ) )
	{
		rotator.NonPhysicsSetRotateModeLocal( true )
	}

	EndSignal( rotator, "OnDestroy" )

	// Linked entities get parented
	array<entity> linkedEnts = rotator.GetLinkEntArray()
	foreach ( entity ent in linkedEnts )
	{
		if ( !ent.HasKey( "no_parent" ) )
			ent.SetParent( rotator, "", true )
	}

	if ( rotator.HasKey( "player_collides" ) && rotator.kv.player_collides == "1" )
		rotator.SetPusher( true )

	if ( rotator.HasKey( "change_navmesh" ) && rotator.kv.change_navmesh == "1" )
		rotator.ChangeNPCPathsOnMove( true )

	// script will custom rotate this one
	if ( rotator.HasKey( "scripted_rotator" ) && expect string( rotator.kv.scripted_rotator ) == "true" )
		return

	if ( IsConnectedToTriggerActivate( rotator ) )
	{
		waitthread WaitForTriggerActivate( rotator )
	}

	// If there is a script_switch linked to this rotator we wait for switch activation. This isn't the normal setup, we usually use flags, but this works in prefabs being copied around the map
	waitthread WaitForLinkedScriptSwitch( rotator )

	if ( rotator.HasKey( "script_flag" ) )
	{
		string flag = expect string( rotator.kv.script_flag )
		FlagInit( flag )
		while ( true )
		{
			bool returnToBaseAngle = false
			if ( rotator.HasKey( "flag_clear_resets" ) )
				returnToBaseAngle = rotator.kv.flag_clear_resets == "1"

			FlagWait( flag )
			vector baseAngles = rotator.GetAngles()
			thread ScriptedRotatorRotate( baseAngles, rotator )
			FlagWaitClear( flag )
			Signal( rotator, "StopRotating" )

			// Return when the flag is cleared
			if ( returnToBaseAngle )
			{
				if ( !IsValid( rotator ) )
					return

				float rotateTime = 1.0
				if ( rotator.HasKey( "rotate_to_time" ) )
					rotateTime = float( rotator.kv.rotate_to_time )
				float easeTime = 0.0
				if ( rotator.HasKey( "rotate_to_ease" ) && rotator.kv.rotate_to_ease == "1" )
					easeTime = rotateTime * 0.33

				rotator.NonPhysicsRotateTo( baseAngles, rotateTime, easeTime, easeTime )
			}
		}
	}
	else
	{
		vector baseAngles = rotator.GetAngles()
		thread ScriptedRotatorRotate( baseAngles, rotator )
	}
}

void function WaitForLinkedScriptSwitch( entity childEnt )
{
	array<entity> entArray = childEnt.GetLinkParentArray()
	foreach ( ent in entArray )
	{
		if ( GetEditorClass( ent ) == "script_switch" )
		{
			WaitSignal( ent, "SwitchActivate" )
			return
		}
	}
}

vector function GetRotationVector( entity rotator )
{
	string axis
	if ( rotator.HasKey( "rotation_axis" ) )
		axis = expect string( rotator.kv.rotation_axis )

	vector angles = rotator.GetAngles()
	switch ( axis )
	{
		case "pitch":
			return AnglesToRight( angles )

		case "yaw":
			return AnglesToUp( angles )

		case "roll":
		default:
			return AnglesToForward( angles )
	}

	unreachable
}

void function ScriptedRotatorRotate( vector baseAngles, entity rotator )
{
	Signal( rotator, "StopRotating" )
	EndSignal( rotator, "OnDestroy" )
	EndSignal( rotator, "StopRotating" )

	OnThreadEnd(
	function() : ( rotator )
		{
			if ( IsValid( rotator ) )
				rotator.NonPhysicsRotate( <0,0,0>, 0 )
		}
	)

	if ( rotator.HasKey( "start_delay" ) )
	{
		float delay = float( rotator.kv.start_delay )
		if ( delay > 0 )
			wait delay
	}

	if ( rotator.kv.rotate_forever_speed != "0" )
	{
		// Rotate forever
		float speed = float( rotator.kv.rotate_forever_speed )
		Assert( speed != 0.0 )

		vector rotateVec = GetRotationVector( rotator )
		rotator.NonPhysicsRotate( rotateVec, speed )
		WaitForever()
	}
	else
	{
		// Rotate specified amount
		Assert( rotator.HasKey( "rotate_to_degrees" ) )
		Assert( rotator.HasKey( "rotate_to_time" ) )

		string soundEffect = ""
		if ( rotator.HasKey( "script_sound" ) )
			soundEffect = string( rotator.kv.script_sound )

		float rotateTime = float( rotator.kv.rotate_to_time )
		if ( rotateTime > 0.0 )
		{
			if ( rotator.HasKey( "use_local_rotation" ) && ( rotator.kv.use_local_rotation == "1" ) )
			{
				baseAngles = <0,0,0>
			}

			string axis
			if ( rotator.HasKey( "rotation_axis" ) )
				axis = expect string( rotator.kv.rotation_axis )

			vector rotateAngles
			switch ( axis )
			{
				case "pitch":
					rotateAngles = AnglesCompose( baseAngles, <float( rotator.kv.rotate_to_degrees ), 0, 0> )
					break

				case "yaw":
					rotateAngles = AnglesCompose( baseAngles, <0, float( rotator.kv.rotate_to_degrees ), 0> )
					break

				case "roll":
				default:
					rotateAngles = AnglesCompose( baseAngles, <0, 0, float( rotator.kv.rotate_to_degrees )> )
					break
			}

			float easeTime = 0.0
			if ( rotator.HasKey( "rotate_to_ease" ) && rotator.kv.rotate_to_ease == "1" )
				easeTime = rotateTime * 0.33

			while ( true )
			{
				// Rotate to the goal angle
				rotator.NonPhysicsRotateTo( rotateAngles, rotateTime, easeTime, easeTime )
				if ( soundEffect != "" )
					EmitSoundOnEntity( rotator, soundEffect )
				wait rotateTime

				// Rotate back to base angle if specified
				if ( !rotator.HasKey( "rotate_to_return_delay" ) || rotator.kv.rotate_to_return_delay == "-1" )
					return
				Assert( float( rotator.kv.rotate_to_return_delay ) >= 0.0 )
				wait float( rotator.kv.rotate_to_return_delay )
				rotator.NonPhysicsRotateTo( baseAngles, rotateTime, easeTime, easeTime )
				if ( soundEffect != "" )
					EmitSoundOnEntity( rotator, soundEffect )
				wait rotateTime

				// Wait a delay and repeat the rotation if specified
				if ( !rotator.HasKey( "rotate_to_loop_time" ) || rotator.kv.rotate_to_loop_time == "-1" )
					return
				Assert( float( rotator.kv.rotate_to_loop_time ) >= 0.0 )
				wait float( rotator.kv.rotate_to_loop_time )
			}
		}
	}
}

void function MoverInit( entity mover )
{
	if ( !mover.HasKey( "leveledplaced" ) || mover.kv.leveledplaced != "1" )
		return

	// Linked entities get parented
	if ( mover.HasKey( "parent_linked_ents" ) && mover.kv.parent_linked_ents == "1" )
	{
		array<entity> linkedEnts = mover.GetLinkEntArray()
		foreach ( entity ent in linkedEnts )
		{
			if ( ((GetEditorClass( ent ) != "script_mover_path") && (ent.GetClassName() != "script_mover_waypoint") && (ent.GetClassName() != "script_mover_train_node")) || (mover.HasKey( "zero_g_movement" ) && (mover.kv.zero_g_movement == "1")) )
			{
				ent.SetParent( mover, "", true )
			}
		}
	}

	if ( mover.HasKey( "player_collides" ) && mover.kv.player_collides == "1" )
		mover.SetPusher( true )

	if ( mover.HasKey( "change_navmesh" ) && mover.kv.change_navmesh == "1" )
		mover.ChangeNPCPathsOnMove( true )

	if ( mover.HasKey( "zero_g_movement" ) && mover.kv.zero_g_movement == "1" )
		mover.NonPhysicsSetZeroGMovement()

	thread MoverThinkInternal( mover )
}

void function MoverThinkInternal( entity mover )
{
	EndSignal( mover, "OnDestroy" )
	EndSignal( mover, "StopMoverThink" )

	array<entity> pathNodes = GetNextMoverPathNodes( mover )

	string modelName = string( mover.GetModelName() )
	if ( modelName == "mdl/dev/editor_ref.rmdl" || modelName == "mdl/dev/editor_ref.rmdl" )
		mover.Hide()

	// Go down the path gathering the nodes and init any flags
	foreach ( entity node in pathNodes )
		InitMoverNodeFlagsAndErrorCheck( node )

	Assert( mover.HasKey( "path_speed" ) && float( mover.kv.path_speed ) >= 0.0, "script_mover doesnt have a valid path speed" )

	if ( IsConnectedToTriggerActivate( mover ) )
	{
		waitthread WaitForTriggerActivate( mover )
	}

	string startFlag = ""
	if ( mover.HasKey( "script_flag" ) && mover.kv.script_flag != "" )
	{
		startFlag = mover.GetValueForKey( "script_flag" )
		FlagInit( startFlag )
	}

	if ( mover.HasKey( "dangerous_area_radius" ) )
		mover.AllowNPCGroundEnt( false )

	if ( pathNodes.len() == 0 )
		return

	if ( startFlag != "" )
		FlagWait( startFlag )

	if ( mover.HasKey( "start_delay" ) && float( mover.kv.start_delay ) > 0.0 )
		wait float( mover.kv.start_delay )

	thread MoverThink( mover, pathNodes, startFlag )
}

void function MoverThink( entity mover, array<entity> pathNodes, string startFlag = "" )
{
	EndSignal( mover, "OnDestroy" )
	EndSignal( mover, "StopMoverThink" )

	ScriptMoverData moverData
	moverData.pathNode = pathNodes.getrandom()

	moverData.doEaseOut = moverData.pathNode.HasKey( "ease_from_node" ) && moverData.pathNode.GetValueForKey( "ease_from_node" ) == "1"

	moverData.isMoveSoundPlaying = false
	moverData.isMoving = false

	float pathSpeed = 69
	if ( mover.HasKey( "path_speed" ) )
	{
		pathSpeed = float( mover.kv.path_speed )
	}
	moverData.pathSpeed = pathSpeed
	moverData.startFlag = startFlag

	while ( IsValid( moverData.pathNode ) )
	{
		bool teleport = false
		if ( moverData.pathNode.HasKey( "teleport_to_node" ) )
			teleport = moverData.pathNode.GetValueForKey( "teleport_to_node" ) == "1"

		bool perfectRotation = false
		if ( IsValid( moverData.lastNode ) && moverData.lastNode.HasKey( "perfect_circular_rotation" ) )
			perfectRotation = moverData.lastNode.GetValueForKey( "perfect_circular_rotation" ) == "1"

		float rotationDuration = 0.0
		if ( IsValid( moverData.lastNode ) && moverData.lastNode.HasKey( "circular_rotation_time" ) )
			rotationDuration = float( moverData.lastNode.GetValueForKey( "circular_rotation_time" ) )

		float dist = Distance( moverData.pathNode.GetOrigin(), mover.GetOrigin() )

		if ( moverData.startFlag != "" )
		{
			if ( Flag( startFlag ) == false )
			{
				if ( moverData.isMoving )
				{
					moverData.isMoving = false
					MoverPath_PlayStopSound( mover, moverData.pathNode )
				}

				if ( moverData.isMoveSoundPlaying )
					moverData.isMoveSoundPlaying = !MoverPath_AttemptStopMoveSound( mover )

				FlagWait( moverData.startFlag )
			}
		}

		if ( !moverData.isMoving )
		{
			MoverPath_PlayStartSound( mover, moverData.pathNode )
			moverData.isMoving = true
		}

		if ( !moverData.isMoveSoundPlaying )
		{
			moverData.isMoveSoundPlaying = true
			MoverPath_PlayMoveSound( mover )
		}

		if ( dist > 0.0 && !teleport )
		{
			MoverThink_LinearAndCircularMovement( mover, moverData, dist, perfectRotation )
		}
		else if ( dist == 0.0 && !teleport && rotationDuration > 0.0 )
		{
			MoverThink_RotateInPlace( mover, moverData, rotationDuration )
		}
		else
		{
			// teleport
			mover.SetAbsOrigin( moverData.pathNode.GetOrigin() )
			mover.SetAbsAngles( moverData.pathNode.GetAngles() )
		}

		MoverThink_ProcessPathNodeOnArrival( mover, moverData )

		pathNodes = GetNextMoverPathNodes( moverData.pathNode )
		if ( pathNodes.len() == 0 )
		{
			moverData.isMoveSoundPlaying = !MoverPath_AttemptStopMoveSound( mover )
			MoverPath_PlayStopSound( mover, moverData.pathNode )
			break
		}

		// Update speed based on the node
		if ( moverData.pathNode.HasKey( "path_speed" ) )
			moverData.pathSpeed = float( moverData.pathNode.GetValueForKey( "path_speed" ) )

		moverData.lastNode = moverData.pathNode

		entity namedNode
		foreach ( n in pathNodes )
		{
			if ( n.HasKey("script_noteworthy") && n.GetValueForKey( "script_noteworthy" ) == mover.GetTargetName() )
				namedNode = n
		}
		if (IsValid(namedNode))
			moverData.pathNode = namedNode
		else
			moverData.pathNode = pathNodes.getrandom()
	}

	mover.Signal( "ReachedPathEnd" )
}

void function MoverThink_LinearAndCircularMovement( entity mover, ScriptMoverData moverData, float dist, bool perfectRotation )
{
	// circular movement around an anchor point OR linear and rotational movement
	moverData.doEaseIn = moverData.pathNode.HasKey( "ease_to_node" ) && moverData.pathNode.GetValueForKey( "ease_to_node" ) == "1"

	float angleChange = IsValid( moverData.lastNode ) ? MoverPath_GetAngleChange( moverData.lastNode, moverData.pathNode ) : 0.0
	bool doPerfectRotation = perfectRotation && (angleChange != 0)

	float currDuration = 0.0
	float targetMoveTime = 0.0

	entity curveMover
	string rotationSoundEvent = ""

	if ( doPerfectRotation )
	{
		if ( mover.HasKey( "sound_circular_rotation" ) )
			rotationSoundEvent = mover.GetValueForKey( "sound_circular_rotation" )

		vector turnAnchorPos = MoverPath_GetAngleAnchor( moverData.lastNode, moverData.pathNode )

		// Create a new mover because as far as I know I can't get all the children of the mover and clearparent and reparent.
		curveMover = CreateScriptMover_NEW( "_script_movers_curvemover", turnAnchorPos, moverData.lastNode.GetAngles() )
		curveMover.SetPusher( mover.GetPusher() )
		mover.SetParent( curveMover, "", true )

		// Find the circumference of the turn so we can calculate the rotation time based on the distance traveled around the bend
		float c = 2.0 * PI * Length(turnAnchorPos - moverData.lastNode.GetOrigin())
		float frac = fabs(angleChange) / 360.0

		currDuration = (c * frac) / moverData.pathSpeed
	}
	else
	{
		currDuration = dist / moverData.pathSpeed
	}

	do
	{
		if ( moverData.startFlag != "" )
		{
			FlagWait( moverData.startFlag )

			if ( !moverData.isMoving )
			{
				moverData.isMoving = true
				MoverPath_PlayStartSound( mover, moverData.pathNode )
			}
			if ( !moverData.isMoveSoundPlaying )
			{
				moverData.isMoveSoundPlaying = true
				MoverPath_PlayMoveSound( mover )
			}
		}

		targetMoveTime = Time() + currDuration - 0.01

		if ( doPerfectRotation )
		{
			if ( rotationSoundEvent != "" )
				EmitSoundOnEntity( mover, rotationSoundEvent )

			curveMover.NonPhysicsRotateTo( moverData.pathNode.GetAngles(), currDuration, 0.0, 0.0 )
		}
		else
		{
			float easeLeaving = moverData.doEaseOut ? currDuration * 0.5 : 0.0
			float easeArriving = moverData.doEaseIn ? currDuration * 0.5 : 0.0

			if ( mover.HasKey( "dangerous_area_radius" ) )
				thread CreateMoverDangrousAreas( mover, mover.GetOrigin(), moverData.pathNode.GetOrigin(), float( mover.GetValueForKey( "dangerous_area_radius" ) ), currDuration, moverData.startFlag )

			mover.NonPhysicsMoveTo( moverData.pathNode.GetOrigin(), currDuration, easeLeaving, easeArriving )
			mover.NonPhysicsRotateTo( moverData.pathNode.GetAngles(), currDuration, easeLeaving, easeArriving )
		}

		if ( moverData.startFlag != "" )
		{
			FlagWaitClearWithTimeout( moverData.startFlag, currDuration )

			if ( Time() <= targetMoveTime )
			{
				moverData.isMoving = false
				MoverPath_PlayStopSound( mover, moverData.pathNode )
				moverData.isMoveSoundPlaying = !MoverPath_AttemptStopMoveSound( mover )

				if ( doPerfectRotation )
				{
					curveMover.NonPhysicsStop()

					if ( rotationSoundEvent != "" )
						StopSoundOnEntity( mover, rotationSoundEvent )
				}
				else
				{
					mover.NonPhysicsStop()
				}

				currDuration = targetMoveTime - Time()
			}
		}
		else
		{
			wait currDuration
		}
	} while ( Time() <= targetMoveTime )

	if ( doPerfectRotation )
	{
		mover.ClearParent()
		curveMover.Destroy()

		if ( rotationSoundEvent != "" )
			StopSoundOnEntity( mover, rotationSoundEvent )
	}
}

void function MoverThink_RotateInPlace( entity mover, ScriptMoverData moverData, float rotationDuration )
{
	// Rotation in place
	string rotationSoundEvent = ""
	if ( mover.HasKey( "sound_rotation" ) )
		rotationSoundEvent = mover.GetValueForKey( "sound_rotation" )

	moverData.isMoveSoundPlaying = !MoverPath_AttemptStopMoveSound( mover )
	MoverPath_PlayStopSound( mover, moverData.pathNode )
	moverData.isMoving = false

	float targetRotationTime = 0

	do
	{
		if ( moverData.startFlag != "" )
			FlagWait( moverData.startFlag )

		if ( rotationSoundEvent != "" )
			EmitSoundOnEntity( mover, rotationSoundEvent )

		targetRotationTime = Time() + rotationDuration - 0.01

		float easeIn = moverData.doEaseOut ? rotationDuration * 0.5 : 0.0
		float easeOut = moverData.doEaseIn ? rotationDuration * 0.5 : 0.0
		mover.NonPhysicsRotateTo( moverData.pathNode.GetAngles(), rotationDuration, easeIn, easeOut )

		if ( moverData.startFlag != "" )
		{
			FlagWaitClearWithTimeout( moverData.startFlag, rotationDuration )

			if ( Time() <= targetRotationTime )
			{
				mover.NonPhysicsStop()
				rotationDuration = targetRotationTime - Time()
				if ( rotationSoundEvent != "" )
					StopSoundOnEntity( mover, rotationSoundEvent )
			}
		}
		else
		{
			wait rotationDuration
		}
	} while ( Time() <= targetRotationTime )

	if ( rotationSoundEvent != "" )
		StopSoundOnEntity( mover, rotationSoundEvent )
}

void function MoverThink_ProcessPathNodeOnArrival( entity mover, ScriptMoverData moverData )
{
	mover.Signal( "ReachedPathNode", { pathNode = moverData.pathNode } )

	if ( moverData.pathNode.HasKey( "scr_flag_set" ) )
		FlagSet( moverData.pathNode.GetValueForKey( "scr_flag_set" ) )

	if ( moverData.pathNode.HasKey( "scr_flag_clear" ) )
		FlagClear( moverData.pathNode.GetValueForKey( "scr_flag_clear" ) )

	if ( moverData.pathNode.HasKey( "scr_flag_wait" ) )
	{
		string flag = moverData.pathNode.GetValueForKey( "scr_flag_wait" )
		if ( !Flag( flag ) )
		{
			moverData.isMoving = false
			moverData.isMoveSoundPlaying = !MoverPath_AttemptStopMoveSound( mover )
			MoverPath_PlayStopSound( mover, moverData.pathNode )
			FlagWait( flag )
		}
	}

	if ( moverData.pathNode.HasKey( "scr_flag_wait_clear" ) )
	{
		string flag = moverData.pathNode.GetValueForKey( "scr_flag_wait_clear" )
		if ( Flag( flag ) )
		{
			moverData.isMoving = false
			moverData.isMoveSoundPlaying = !MoverPath_AttemptStopMoveSound( mover )
			MoverPath_PlayStopSound( mover, moverData.pathNode )
			FlagWaitClear( flag )
		}
	}

	if ( moverData.pathNode.HasKey( "path_wait" ) )
	{
		float time = float( moverData.pathNode.GetValueForKey( "path_wait" ) )
		if ( time > 0.0 )
		{
			moverData.isMoving = false
			moverData.isMoveSoundPlaying = !MoverPath_AttemptStopMoveSound( mover )
			MoverPath_PlayStopSound( mover, moverData.pathNode )
			wait time

		}
	}

	moverData.doEaseOut = moverData.pathNode.HasKey( "ease_from_node" ) && moverData.pathNode.GetValueForKey( "ease_from_node" ) == "1"
}

void function CreateMoverDangrousAreas( entity mover, vector start, vector end, float radius, float duration, string startFlag )
{
	float d = Distance( start, end )
	float spacing = radius * 1.5
	int numDangerousSpots = int( ceil( d / spacing ) )
	vector direction = Normalize( end - start )
	vector pos

	for ( int i = 0; i < numDangerousSpots; i++ )
	{
		pos = start + ( direction * spacing * i )
		thread CreateMoverDangrousAreaUntilMoverPasses( mover, start, end, pos, radius, duration, startFlag )
	}
}

void function CreateMoverDangrousAreaUntilMoverPasses( entity mover, vector start, vector end, vector pos, float radius, float maxDuration, string startFlag )
{
	// Create entity to link it to (lifetime)
	entity lifetimeEnt = CreateScriptRef( pos )

	// Create the dangerous area
	// AI_CreateDangerousArea_Static( lifetimeEnt, null, radius, TEAM_INVALID, true, true, false, pos )

	// Wait for mover to go past the dangerous area, or timeout
	float endTime = Time() + maxDuration
	while ( Time() <= endTime )
	{
		if ( DotProduct( end - start, pos - mover.GetOrigin() ) < 0 )
			break

		if ( startFlag != "" && Flag( startFlag ) == false )
			break

		WaitFrame()
	}

	lifetimeEnt.Destroy()
}

void function MoverPath_PlayMoveSound( entity mover )
{
	// Play sound on mover if one is specified
	if ( mover.HasKey( "sound_move" ) && mover.kv.sound_move != "" )
		EmitSoundOnEntity( mover, string( mover.kv.sound_move ) )
}

bool function MoverPath_AttemptStopMoveSound( entity mover )
{
	// Stops any move sounds playing on the mover

	// Stop playing a sound on the mover if one is specified & it is set to do so
	if ( mover.HasKey( "sound_move" ) && mover.kv.sound_move != "" )
	{
		// "sound_move" sound continues to play after moving unless this is checked"
		if ( mover.HasKey( "stop_sound_move_on_stop" ) && mover.GetValueForKey( "stop_sound_move_on_stop" ) == "1" )
		{
			StopSoundOnEntity( mover, string( mover.kv.sound_move ) )
			return true
		}
	}

	return false
}

void function MoverPath_PlayStopSound( entity mover, entity node )
{
	// Play sound on the node if one is specified
	if ( node.HasKey( "sound_stop_move" ) && node.kv.sound_stop_move != "" )
		EmitSoundAtPosition( TEAM_UNASSIGNED, node.GetOrigin(), string( node.kv.sound_stop_move ), node )

	// Play sound on the mover if one is specified
	if ( mover.HasKey( "sound_stop_move" ) && mover.kv.sound_stop_move != "" )
		EmitSoundOnEntity( mover, string( mover.kv.sound_stop_move ) )
}

void function MoverPath_PlayStartSound( entity mover, entity node )
{
	// Play sound on the node if one is specified
	if ( node.HasKey( "sound_start_move" ) && node.kv.sound_start_move != "" )
		EmitSoundAtPosition( TEAM_UNASSIGNED, node.GetOrigin(), string( node.kv.sound_start_move ), node )
}

float function MoverPath_GetAngleChange( entity node1, entity node2 )
{
	vector vec1 = node1.GetForwardVector()
	vector vec2 = node2.GetForwardVector()
	float angle = acos( DotProduct( vec1, vec2 ) ) * 180 / PI
	return angle
}

vector function MoverPath_GetAngleAnchor( entity node1, entity node2 )
{
	vector node1Origin = node1.GetOrigin()
	vector node2Origin = node2.GetOrigin()
	vector node1Angles = node1.GetAngles()
	vector node2Angles = node2.GetAngles()
	vector node1SideVec
	vector node2SideVec

	if ( node1Origin.z != node2Origin.z )
	{
		// vertical turn
		node1SideVec = AnglesToUp( node1Angles )
		node2SideVec = AnglesToUp( node2Angles )
	}
	else
	{
		// horizontal turn
		node1SideVec = AnglesToRight( node1Angles )
		node2SideVec = AnglesToRight( node2Angles )
	}

	float angleChange = MoverPath_GetAngleChange( node1, node2 )
	Assert( angleChange != 0 )
	if ( angleChange > 0 )
	{
		node1SideVec *= -1
		node2SideVec *= -1
	}
	float d = Distance( node1Origin, node2Origin )
	vector intersect = GetClosestPointToLineSegments( node1Origin, node1Origin + node1SideVec * d, node2Origin, node2Origin + node2SideVec * d )

	//DebugDrawLine( intersect, node1Origin, COLOR_YELLOW, true, 5.0 )
	//DebugDrawLine( intersect, node2Origin, COLOR_CYAN, true, 5.0 )
	//DebugDrawLine( node1Origin, node1Origin + node1SideVec * 250, <100, 100, 100>, true, 5.0 )
	//DebugDrawLine( node2Origin, node2Origin + node2SideVec * 250, <100, 100, 100>, true, 5.0 )
	//DebugDrawLine( intersect, intersect - <0,0,128>, <100, 0, 0>, true, 5.0 )
	//DebugDrawText( intersect, angleChange.tostring(), true, 5.0 )

	return intersect
}

array<entity> function GetNextMoverPathNodes( entity node, bool errorChecking = false )
{
	array<entity> nodes
	if ( !node.HasKey( "zero_g_movement" ) || (node.kv.zero_g_movement == "0") )
	{
		array<entity> linkedEnts = node.GetLinkEntArray()
		foreach ( entity ent in linkedEnts )
		{
			if ( GetEditorClass( ent ) == "script_mover_path" )
			{
				if ( !errorChecking && ent.HasKey( "switchtrack_flag" ) && !Flag( ent.GetValueForKey( "switchtrack_flag" ) ) )
					continue
				nodes.append( ent )
			}
		}
	}
	return nodes
}

void function InitMoverNodeFlagsAndErrorCheck( entity node )
{
	if ( node.e.moverPathPrecached )
		return

	if ( node.HasKey( "path_speed" ) )
		Assert( float( node.kv.path_speed ) > 0.0, "Node path_speed at " + node.GetOrigin() + " must be greater than 0." )

	if ( node.HasKey( "path_wait" ) )
		Assert( float( node.kv.path_wait ) >= 0.0, "Node path_wait at " + node.GetOrigin() + " must be greater than 0." )

	if ( node.HasKey( "teleport_to_node" ) && node.kv.teleport_to_node == "1" )
	{
		if ( node.HasKey( "ease_to_node" ) )
			Assert( node.kv.ease_to_node == "0", "Node at " + node.GetOrigin() + " cant have both teleport_to_node and ease_to_node checked." )
	}

	if ( node.HasKey( "scr_flag_set" ) )
		FlagInit( node.GetValueForKey( "scr_flag_set" ) )
	if ( node.HasKey( "scr_flag_clear" ) )
		FlagInit( node.GetValueForKey( "scr_flag_clear" ) )
	if ( node.HasKey( "scr_flag_wait" ) )
		FlagInit( node.GetValueForKey( "scr_flag_wait" ) )
	if ( node.HasKey( "switchtrack_flag" ) )
		FlagInit( node.GetValueForKey( "switchtrack_flag" ), true )

	node.e.moverPathPrecached = true

	array<entity> pathNodes = GetNextMoverPathNodes( node, true )
	foreach ( entity nextnode in pathNodes )
		InitMoverNodeFlagsAndErrorCheck( nextnode )
}

struct SeeSawThinkStruct // struct that is internal to seeSaw think logic
{
	float speed
	bool touching
	bool wasTouched
	vector startAngles
	float oldSpeed
	bool playerIgnore
	float maxSpeed = 10
	float acceleration = 0.425
}

void function SeeSawThink( entity seeSaw )
{
	seeSaw.Hide()

	seeSaw.EndSignal( "OnDestroy" )
//	seeSaw.NonPhysicsSetRotateModeLocal( true )
	seeSaw.SetPusher( true )

	array<entity> parents = seeSaw.GetLinkParentArray()
	array<entity> brushes
	foreach ( ent in parents )
	{
		if ( ent.GetClassName() == "func_brush" )
			brushes.append( ent )
	}

	float minz = 0
	float maxz = 0
	foreach ( brush in brushes )
	{
		vector mins = brush.GetBoundingMins()
		vector maxs = brush.GetBoundingMaxs()

		if ( mins.z < minz )
			minz = mins.z

		if ( maxs.z > maxz )
			maxz = maxs.z
	}

	float height = fabs( minz ) + maxz

	entity trigger = seeSaw.GetLinkEnt()
	trigger.EndSignal( "OnDestroy" )

	SeeSawThinkStruct e
	e.startAngles = seeSaw.GetAngles()

	if ( seeSaw.HasKey( "script_start_moving" ) && int( seeSaw.kv.script_start_moving ) > 0 )
	{
		e.wasTouched = true
		e.speed = 8
	}

	thread SeeSawSpeedThink( seeSaw, e )

	if ( seeSaw.HasKey( "script_player_ignore" ) && int( seeSaw.kv.script_player_ignore ) > 0 )
	{
		e.playerIgnore = true
	}
	else
	{
		thread SeeSawTriggerThink( seeSaw, trigger, height, e )
	}
}

void function SeeSawTriggerThink( entity seeSaw, entity trigger, float height, SeeSawThinkStruct e )
{
	for ( ;; )
	{
		e.touching = false
		table results = trigger.WaitSignal( "OnTrigger" )
		entity player = expect entity( results.activator )
		if ( !IsAlive( player ) )
			continue

		while ( trigger.IsTouching( player ) )
		{
			PlayerNearSeeSaw( player, seeSaw, height, e )
			WaitFrame()
		}
	}
}

float ornull function SeeSawPitchLimitOverride()
{
//	return 60.0
	return null
}

void function SeeSawSpeedThink( entity seeSaw, SeeSawThinkStruct e )
{
	seeSaw.EndSignal( "OnDestroy" )
	float pitchLimit = 50 // 70.75

	if ( seeSaw.HasKey( "script_pitch_limit" ) )
		pitchLimit = float( seeSaw.kv.script_pitch_limit )

	vector angles = seeSaw.GetAngles()
	vector forward = AnglesToRight( angles ) * -1
	vector rotateDir = forward // <-1,0,0>

	for ( ;; )
	{
		WaitFrame()
		SeeSawSpeedThink_internal( seeSaw, e, rotateDir, pitchLimit )
	}
}

void function SeeSawSpeedThink_internal( entity seeSaw, SeeSawThinkStruct e, vector rotateDir, float pitchLimit )
{
	float ornull pitchLimitOverride = SeeSawPitchLimitOverride()
	if ( pitchLimitOverride != null )
	{
		pitchLimit = expect float( pitchLimitOverride )
	}
	vector localAngles = seeSaw.GetLocalAngles()

	if ( ( !e.touching && e.wasTouched ) || e.playerIgnore )
	{
		vector startForward = AnglesToForward( e.startAngles )
		vector startUp = AnglesToUp( e.startAngles )
		vector seeSawForward = AnglesToForward( seeSaw.GetAngles() )

//		if ( ge(106)==seeSaw)
//		{
//			printt( "dot is " + DotProduct( startForward, seeSawForward ) + " speed " + e.speed )
//		}
		//printt( "Dot " + DotProduct( startForward, seeSawForward ) )
		//printt( "Dot " +
		//printt( DotProduct( startUp, seeSawForward ) )


		// return to normal
		//printt( "start angles " + e.startAngles + " current angles " + seeSaw.GetAngles() )

		if ( fabs( DotProduct( startForward, seeSawForward ) ) < 0.75 )
		{
			if ( DotProduct( startUp, seeSawForward ) > 0 )
			{
				if ( e.speed < e.maxSpeed )
					e.speed += e.acceleration
			}
			else
			{
				if ( e.speed > -e.maxSpeed )
					e.speed -= e.acceleration
			}
		}

		//DebugDrawText( seeSaw.GetOrigin(), "" + e.speed, true, 1 )
		//DebugDrawLine( seeSaw.GetOrigin(), GetPlayerArray()[0].GetOrigin(), COLOR_RED, true, 0.2 )
	}

//	if ( ge(117) == seeSaw )
//		return
	if ( e.speed < 0 )
	{
		if ( localAngles.x < -pitchLimit )
		{
			seeSaw.NonPhysicsRotate( rotateDir, 0 )
			e.speed = 0
			return
		}
	}
	else
	{
		if ( localAngles.x > pitchLimit )
		{
			seeSaw.NonPhysicsRotate( rotateDir, 0 )
			e.speed = 0
			return
		}
	}

	if ( e.oldSpeed != e.speed || pitchLimitOverride != null )
	{
		seeSaw.NonPhysicsRotate( rotateDir, e.speed )
		e.oldSpeed = e.speed
	}
}

void function PlayerNearSeeSaw( entity player, entity seeSaw, float height, SeeSawThinkStruct e )
{
	vector playerOrigin = player.GetOrigin()
	vector seeSawOrigin = seeSaw.GetOrigin()
	//DebugDrawLine( playerOrigin, seeSawOrigin, COLOR_RED, true, 0.2 )
	vector originDif = playerOrigin - seeSawOrigin
	vector difNormal = Normalize( originDif )
	vector seeSawAngles = seeSaw.GetAngles()
	vector seeSawUp = AnglesToUp( seeSawAngles )
	bool onTop = DotProduct( difNormal, seeSawUp ) > 0

	// may need to do something special for hands holding on
	if ( !onTop )
	{
		e.touching = false
		return
	}

	float amountAbove = DotProduct( originDif, seeSawUp )
	amountAbove -= height
	amountAbove += 2.5 // player is in the ground?

//	if ( ge(117) == seeSaw )
//	{
//		printt( "amountAbove " + amountAbove )
//	}

	if ( amountAbove < 0 || amountAbove > 15 )
	{
		e.touching = false
		return
	}



	vector seeSawForward = AnglesToForward( seeSawAngles )
	float amountForward = DotProduct( originDif, seeSawForward )
	e.speed += Graph( amountForward, 0, 1000, 0, 2 )
	float maxSpeed = 10
	e.speed = min( maxSpeed, e.speed )
	e.speed = max( -maxSpeed, e.speed )
	e.touching = true
	e.wasTouched = true
}

float fanradius = 50
float fanPushDist = 256

void function FanPusherThink( entity fanPusher )
{
	EndSignal(fanPusher, "OnDestroy")
	
	if ( fanPusher.HasKey( "height" ) )
		fanPushDist = float( fanPusher.kv.height )

	if ( fanPusher.HasKey( "script_gravityscale" ) && fanPusher.kv.script_gravityscale != "" )
	{
		fanPushDist *= string( fanPusher.kv.script_gravityscale ).tofloat()
	}
	else
	{
		float gravityScale = 1.0
		fanPushDist *= gravityScale // adjusted for new gravity scale
	}

	float radius = fanradius
	vector forward = AnglesToForward( fanPusher.GetAngles() )
	vector cylinderBottom = fanPusher.GetOrigin()
	vector cylinderTop = cylinderBottom + ( forward * fanPushDist )

	string flag = ""
	if ( fanPusher.HasKey( "script_flag" ) )
	{
		flag = string( fanPusher.kv.script_flag )
		FlagInit( flag )
	}

	bool lifterFan = DotProduct( forward, <0,0,1> ) >= 0.98
	float pushAccel = FAN_DEFAULT_PUSH_ACCEL
	if ( fanPusher.HasKey( "strength" ) )
		pushAccel = float( fanPusher.kv.strength )

	array<entity> fanPushables
	table<entity,float> startTimes
	table<entity,float> startHeights

	// Play fan sound on entity instead of at position because some occluder bug with miles. Easiest fix for late in game. Next project fan pusher shoudln't be info_target that you can't play sounds on
	entity fanSoundEntity = CreateScriptMover( fanPusher.GetOrigin() )
	fanSoundEntity.DisableHibernation()

	// Delay to fix code bug where audio wont play at map load
	wait 0.2

	FanOnSoundEffects( fanPusher, radius, fanSoundEntity )

	while( IsValid(fanPusher) )
	{
		//make this update each frame so fan can be moved
		forward = AnglesToForward( fanPusher.GetAngles() )
		cylinderBottom = fanPusher.GetOrigin()
		cylinderTop = cylinderBottom + ( forward * fanPushDist )
		
		if ( FAN_DEBUG )
			DebugDrawCylinder( fanPusher.GetOrigin(), fanPusher.GetAngles(), radius, fanPushDist, 100, 0, 0, true, 0.1 )
		
		if ( flag != "" && !Flag( flag ) )
		{
			foreach( entity ent, float time in startTimes )
				ent.e.inWindTunnel = false

			startTimes.clear()
			startHeights.clear()

			FanOffSoundEffects( fanPusher, radius, fanSoundEntity )
			FlagWait( flag )
			FanOnSoundEffects( fanPusher, radius, fanSoundEntity )
		}

		fanPushables.clear()
		fanPushables.extend( GetPlayerArray() )
		fanPushables.extend( GetNPCArray() )
		//fanPushables.extend( GetProjectileArrayEx( "any", TEAM_ANY, TEAM_ANY, cylinderBottom, fanPushDist ) )
		fanPushables.extend( GetEntArrayByClass_Expensive( "prop_physics" ) )

		foreach( entity ent in fanPushables )
		{
			array<vector> testPosArray = [ ent.GetWorldSpaceCenter(), ent.EyePosition() + <0,0,16>, ent.GetOrigin() - <0,0,16> ]
			bool isInFanCylinder = false
			vector testPos = ent.GetWorldSpaceCenter()
			if ( ent.e.windPushEnabled )
			{
				foreach( vector pos in testPosArray )
				{
					if ( !PointInCylinder( cylinderBottom, cylinderTop, radius, pos ) )
						continue
					isInFanCylinder = true
					break
				}
			}

			if ( isInFanCylinder )
			{
				if ( ent.IsPlayer() && ent.IsNoclipping() )
					continue

				if ( !( ent in startTimes ) )
				{
					ent.e.inWindTunnel = true
					ent.e.windTunnelDirection = forward
					if ( ent.IsPlayer() )
						thread PlayerInWindTunnel( ent )
					else
						ent.SetOrigin( ent.GetOrigin() + <0,0,48> )
					startTimes[ ent ] <- Time()
				}
				float startTime = startTimes[ ent ]
				ent.e.windTunnelStartTime = startTime

				float startHeight
				if ( lifterFan )
				{
					if ( !( ent in startHeights ) )
						startHeights[ ent ] <- ent.GetOrigin().z
					startHeight = startHeights[ ent ]
				}

				// Figure out what force should be based on proximity to fan
				vector pointAlongTunnel = GetClosestPointOnLineSegment( cylinderBottom, cylinderTop, testPos )
				float distanceFromFanAlongTunnel = Distance( pointAlongTunnel, cylinderBottom )

				float fanStrength = GetFanStrengthWithGeoBlockage( ent, testPos, cylinderBottom, cylinderTop, forward )
				// if ( ent.IsPlayer() )
					// ent.SetPlayerNetFloatOverTime( "FanRumbleStrength", fanStrength, 0.0 )

				if ( lifterFan )
					fanStrength = GraphCapped( distanceFromFanAlongTunnel, 0.0, fanPushDist, 1.0, 0.0 )

				if ( ent.IsProjectile() )
					fanStrength *= 2.0

				if ( ent.GetModelName() == $"mdl/containers/barrel.rmdl" )
					fanStrength = 0.0

				// Ramp up the push over time when first entering
				float ramp = GraphCapped( Time(), startTime, startTime + FAN_PUSH_RAMP_TIME, 0.0, 1.0 )

				float dt = 0.01666667 // old behavior
				vector velocity = ent.GetVelocity()

				// Apply push to the velocity
				velocity += forward * ( dt * pushAccel * fanStrength )

				// Decay other directional movement on the vector
				if ( FAN_PUSH_DECAY_SIDE_VELOCITY )
				{
					vector velInOtherDirs = velocity - forward * DotProduct( velocity, forward )
					float decayFrac = pow( ramp * fanStrength, dt )
					vector loseVelInOtherDirs = velInOtherDirs * (1 - decayFrac)
					velocity -= loseVelInOtherDirs
				}

				// Add some anti-gravity
				velocity.z += dt * FAN_PUSH_ANTI_GRAVITY * fanStrength
				ent.e.windTunnelStrength = fanStrength

				// Apply new force to ent
				ent.SetVelocity( velocity )

				// Hack for drones. You can't set velocity on them yet so I'm doing this for now to test the gameplay
				if ( ent.GetClassName() == "npc_drone" )
				{
					float zChange = dt * pushAccel * fanStrength * 1
					ent.SetOrigin( ent.GetOrigin() + < 0, 0, zChange > )
				}
			}
			else
			{
				if ( ent in startTimes )
				{
					ent.e.inWindTunnel = false
					delete startTimes[ ent ]
				}

				if ( lifterFan && ent in startHeights )
				{
					delete startHeights[ ent ]
				}

				// if ( ent.IsPlayer() )
					// ent.SetPlayerNetFloatOverTime( "FanRumbleStrength", 0.0, 1.0 )
			}
		}
		WaitFrame()
	}
}

void function PlayerInWindTunnel( entity player )
{
	//int poseIndex = player.LookupPoseParameterIndex( "windfrac" )

	EndSignal( player, "OnDestroy" )
	OnThreadEnd(
		function() : ( player )
		{
			if ( FAN_DEBUG )
				printt( "OUT!" )
			if ( IsValid( player ) )
			{
				//player.MovementEnable()
				player.SetOneHandedWeaponUsageOff()
				FadeOutSoundOnEntity( player, "Beacon_WindBuffet_Player", 1.0 )

				player.kv.airSpeed = player.GetPlayerSettingFloat( "airSpeed" )
				player.kv.airAcceleration = player.GetPlayerSettingFloat( "airAcceleration" )
			}
		}
	)

	if ( FAN_DEBUG )
		printt( "IN!" )

	bool playingWindBuffet = false

	player.kv.airSpeed = 80
	player.kv.airAcceleration = 800

	while( player.e.inWindTunnel )
	{
		//player.GetViewModelEntity().SetPoseParameter( poseIndex, player.e.windTunnelStrength )
		//player.MovementDisable()
		if ( player.e.windTunnelStrength > 0 )
		{
			player.SetOneHandedWeaponUsageOn()
			if ( !playingWindBuffet )
			{
				EmitSoundOnEntityOnlyToPlayerWithFadeIn( player, player, "Beacon_WindBuffet_Player", 1.0 )
				playingWindBuffet = true
			}
		}
		else
		{
			player.SetOneHandedWeaponUsageOff()
			if ( playingWindBuffet )
			{
				FadeOutSoundOnEntity( player, "Beacon_WindBuffet_Player", 1.0 )
				playingWindBuffet = false
			}
		}
		WaitFrame()
	}
}

float function GetFanStrengthWithGeoBlockage( entity ent, vector testPos, vector cylinderBottom, vector cylinderTop, vector fanDirection )
{
	vector pointAlongFan = GetClosestPointOnLineSegment( cylinderBottom, cylinderTop, testPos )
	vector vecFromFanCenter = testPos - pointAlongFan
	vector traceEnd = cylinderBottom + vecFromFanCenter

	// Trace from the entity towards the fan along the fan axis to see if we are getting blocked
	TraceResults result = TraceLine( testPos, traceEnd, ent, TRACE_MASK_NPCSOLID, TRACE_COLLISION_GROUP_NONE )
	if ( FAN_DEBUG )
	{
		DebugDrawLine( testPos, result.endPos, 255, 255, 0, true, 0.1 )
		DebugDrawLine( result.endPos, traceEnd, 255, 255, 255, true, 0.1 )
		//DebugDrawLine( <0,0,0>, result.endPos, 255, 0, 0, true, 0.1 )
	}

	float distFromCover = Distance( testPos, result.endPos )
	float strength = GraphCapped( distFromCover, 256, 1024, 0.0, 1.0 )
	if ( result.fraction == 1.0 )
		strength = 1.0

	//if ( FAN_DEBUG )
	//{
	//	printt( "strength:", strength )
	//	printt( "fraction:", result.fraction )
	//	printt( "dist from fan:", Distance( testPos, cylinderBottom ) )
	//	printt( "distFromCover:", distFromCover )
	//}

	Assert( strength >= 0.0 && strength <= 1.0 )
	return strength
}

void function FanOnSoundEffects( entity fanPusher, float radius, entity fanSoundEntity )
{
	// Turn on sound
	if ( radius >= 350 )
	{
		EmitSoundOnEntity( fanSoundEntity, "Beacon_VerticalFanControl_On" )
		if ( fanPusher.HasKey( "fan_loop_sound" ) )
			EmitSoundOnEntity( fanSoundEntity, string( fanPusher.kv.fan_loop_sound ) )

	}
	else
	{
		EmitSoundOnEntity( fanSoundEntity, "Beacon_MediumBlueFan_On" )
		string loopAlias = fanPusher.HasKey( "fan_loop_sound" ) ? string( fanPusher.kv.fan_loop_sound ) : "Beacon_MediumBlueFan_Loop_01"
		EmitSoundOnEntity( fanSoundEntity, loopAlias )
		//DebugDrawText( fanPusher.GetOrigin(), loopAlias, true, 90.0 )
	}
}

void function FanOffSoundEffects( entity fanPusher, float radius, entity fanSoundEntity )
{
	// Turn off sound
	if ( radius >= 350 )
	{
		string alias = "Beacon_VerticalFanControl_Off"
		if ( fanPusher.HasKey( "shutoff_sound" ) )
			alias = string( fanPusher.kv.shutoff_sound )
		EmitSoundOnEntity( fanSoundEntity, alias )

		if ( fanPusher.HasKey( "fan_loop_sound" ) )
			StopSoundOnEntity( fanSoundEntity, string( fanPusher.kv.fan_loop_sound ) )
	}
	else
	{
		EmitSoundOnEntity( fanSoundEntity, "Beacon_MediumBlueFan_Off" )
		string loopAlias = fanPusher.HasKey( "fan_loop_sound" ) ? string( fanPusher.kv.fan_loop_sound ) : "Beacon_MediumBlueFan_Loop_01"
		StopSoundOnEntity( fanSoundEntity, loopAlias )
	}
}