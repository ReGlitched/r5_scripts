//=========================================================
//	sh_sp_dialogue.gnut
//=========================================================

#if CLIENT
const bool DEBUG_QUEUE_PRINTS = false

global table<string, bool> FORBIDDEN_DIALOGUE_EVENT_NAMES = {
		// only use this in case of emergencies!
		// diag_mp_pathfinder_ping_helpcall_1p = true, // example
}
#endif


global function RegisterCSVDialogue
global function SPDialogueInit
global function Dialog_RegisterNetworking


#if SERVER
global function PlayDialogue
global function PlayDialogue_AllConnectedPlayers
global function PlayDialogue_NoWait
global function PlayDialogueForAnimEvent
global function PlayBTDialogue
global function PlayGabbyDialogue
global function StopDialogue
global function StopDialogueForPlayer
global function PlayDialogueForPlayer_NoWait
global function PlayDialogueForPlayer
global function PlayDialogueForPlayer_Retail
global function PlayRadioDialogueToAll
global function PlayRadioDialogueToTeam
global function PlayRadioDialogueToPlayer
global function RequestCustomDialogueQueueIndex
#endif //SERVER


#if CLIENT
global function SCB_PlayDialogueOnEntity
global function SCB_PlayDialogueAtPosition
global function SCB_PlayDialogueOnEnvironmentSpeakers
global function SCB_PlayDialogueOnEnvironmentSpeakersNoResponse
global function SCB_PlayDialogueOnCustomSpeakers
global function SCB_AbortCurrentDialogue
global function SetUseDialogueVDU
global function PlayAnyClientSelfDialogueByName
global function GetAnyDialogueAliasFromName
global function GetAnyAliasIdForName
global function PlayClientDialogueOnEntity

global function PauseDialogueQueue
global function ResumeDialogueQueue

global function ResumeMainDialogueQueue
global function PauseMainDialogueQueue
global function SuspendMainDialogueQueueForDurationOfSound
global function RemovePlayerDialogueEventsFromMainDialogueQueue


global function RegisterEnvironmentSpeaker
global function DeregisterEnvironmentSpeaker
global function CustomSpeakers1ListInit
global function RegisterCustomDialogueQueueSpeakerEntities
#endif //CLIENT


#if DEVELOPER
global function ShouldTryToReplaceMissingVoiceWithTempVoice
#endif // #if DEVELOPER


//////////////////////
//////////////////////
//// Global Types ////
//////////////////////
//////////////////////
global struct QueueItem
{
	int    priority
	int    entHandle   = -1
	float  timeAdded   = -1
	bool   active      = false
	string debugRef    = ""
	bool   success     = true
	int    serialNum   = -1
}


enum eDialogueQueues
{
	main,
	custom1,

	_COUNT
}

global struct EnvironmentSpeaker
{
	vector origin
	string crowdQuietAlias             = ""
	string crowdActiveAlias            = ""
	string crowdCheerAlias             = ""
	string crowdRoarAlias              = ""
	string crowdOvationAlias           = ""
	string crowdChantAlias             = ""
	string crowdEndMatchChantAlias     = ""
	string activeVOLine                = ""
	float  quietLoopSecondsToTimeout   = 0
	float  activeLoopSecondsToTimeout  = 0
	float  cheerLoopSecondsToTimeout   = 0
	float  oneShotDelayBetweenReuse    = 0
	float  ovationLoopSecondsToTimeout = 0
	entity speakerEnt
	float  distanceSqr
}


global enum eDialogueFlags
{
	SHORT_DELAY_AFTER_PLAYING = (1 << 0),
	SURVIVAL_HOST_ALL_SPEAKERS = (1 << 1),
	NO_ON_FINISHED_NOTIFY = (1 << 2),
	MUTE_PLAYER_PING_DIALOGUE_FOR_DURATION = (1 << 3),
	MUTE_PLAYER_PING_CHIMES_FOR_DURATION = (1 << 4),
	BLOCK_LOWER_PRIORITY_QUEUE_ITEMS = (1 << 5),
	STOMP_CON_ALT = (1 << 6),
	AMBIENT_DIALOGUE = (1 << 7),
	USE_CUSTOM_QUEUE = (1 << 8 ),
	USE_CUSTOM_SPEAKERS = ( 1 << 9 ),
	BLOCK_ANNOUNCER = ( 1 << 10 ),
	EMIT_FROM_FIXED_POSITION = ( 1 << 11 ),
}

// Speakers
global const string ENVIRONMENT_SPEAKER_SCRIPT_NAME = "info_survival_speaker_location"
global const string SILENT_PLAYER_VOICE = "_silent"

// Play priorities
global const PRIORITY_NO_QUEUE  = 0     // Plays the dialogue right away, avoiding the queue.
global const PRIORITY_HIGH      = 20    // Enters the queue with the highest of priorities, only other items in queue of same priority will play first
global const PRIORITY_NORMAL    = 10
global const PRIORITY_LOW       = 5
global const PRIORITY_LOWEST    = 1


#if DEVELOPER
global const string TEMP_VOICE  = "playerM1"
#endif // #if DEVELOPER


///////////////////////
///////////////////////
//// Private Types ////
///////////////////////
///////////////////////
struct DialogueEntryGroup
{
	string     groupName
	array<int> aliasIds
	asset      sourceDataTable

	#if SERVER
		ShuffleData shuffleData
	#endif // SERVER
}


struct DialogueData
{
	string name
	string alias
	int    priority
	string perspective
	bool   canPlayIfSolo
	string radioDisplayName
	string voice
	bool   radioIntercept
	string DEV_DialogueText
	asset  vduVideo

	DialogueEntryGroup& group
	int                 indexInGroup
}


struct QueueData
{
	array<QueueItem> queue
	#if CLIENT
		string flagPauseQueue
		int    dialoguePauseStackCount = 0
		table  signalDummy
	#endif
}

const int QUEUE_MAIN = 0
const int NUM_CUSTOM_QUEUES = 6
global const int NUM_TOTAL_DIALOGUE_QUEUES = NUM_CUSTOM_QUEUES + 1

#if CLIENT
struct CachedCharacterData
{
	string longName
	asset  portraitImage
}
#endif //CLIENT


struct
{
	var                   currentDialoguePlayingHandle
	string                currentDialoguePlayingName
	array<DialogueData>               registeredDialog
	table<string, DialogueEntryGroup> nameToGroupMap

	bool                  dialoguePlaying = false
	QueueData[ NUM_TOTAL_DIALOGUE_QUEUES ] allQueues

	table<string, asset>  callerIDs
	table<int, bool>      waitingOnDialogue
	bool                  useVDU = false
	array<var>            currentDialoguePlayingHandles
	int                   lastLineRequestPriority
	int 				  numCustomQueuesUsed = 1 // Starts at 1, since 0 is main

	array<string> validVoices

	#if DEVELOPER
		array<string> validPerspectives = ["", "solo", "radio"] // blank perspective means 1p and 3p, solo means additional to-self perspective on top of 1p and 3p
	#endif // DEVELOPERELOPER

	#if CLIENT
		var                                devTextDialogueRUI
		int                                videoChannel = -1
		array<EnvironmentSpeaker>          environmentSpeakers
		array<entity>                      customSpeakers1
		table<string, CachedCharacterData> voiceToCachedCharDataMap
		bool blockAnnouncer = false
		array< EnvironmentSpeaker >[ NUM_TOTAL_DIALOGUE_QUEUES ]		  allSpeakersList
	#endif //CLIENT
} file


/////////////////////////
/////////////////////////
//// Initialiszation ////
/////////////////////////
/////////////////////////
void function SPDialogueInit()
{
	// set up queue data
	for( int i; i < NUM_TOTAL_DIALOGUE_QUEUES; i++ )
	{
		#if CLIENT
			file.allQueues[ i ].flagPauseQueue = format( "flag_queue%iPaused", i )
		#endif
	}

	#if SERVER
	RegisterSignal( "DialogueFinishedForID" )
	RegisterSignal( "AllDialogueFinished" )
	RegisterSignal( "fireSalvo" )
	AddClientCommandCallback( "DialogueFinishedForID", ClientCommand_DialogueFinishedForID )
	AddClientCommandCallback( "AllDialogueFinished", ClientCommand_AllDialogueFinished )

	#if DEVELOPER
		// When a character is loaded from bakery, add their currently registered voice value
		// to the list of voices to be verified by VerifyExistenceOfNongenericAliases
		AddCallback_OnItemFlavorRegistered( eItemType.character, OnCharacterRegistered )
	#endif //DEVELOPER
#endif //SERVER

	AddCallback_OnItemFlavorRegistered( eItemType.character, OnCharacterRegistered )

	#if(CLIENT)
		AddCallback_OnClientScriptInit( ClientScriptInitForPlayer )
		AddCallback_EntitiesDidLoad( EnvironmentSpeakerListInit )

		RegisterSignal( "QueueUpdated" )
		RegisterSignal( "NextInQueue" )
		RegisterSignal( "RemovedFromQueue" )
		RegisterSignal( "AbortCurrentDialogue" )
		RegisterSignal( "EndSoundEarly" )

		file.videoChannel = ReserveVideoChannel()

		for ( int i; i < NUM_TOTAL_DIALOGUE_QUEUES; i++ )
		{
			QueueData queueData = file.allQueues[ i ]
			FlagInit( queueData.flagPauseQueue, false )
			thread QueueThink( queueData )
		}

		foreach( string eventName, bool unused in FORBIDDEN_DIALOGUE_EVENT_NAMES )
			printf( "Dialogue sound event '%s' has been disabled in script.", eventName )
	#endif //
}


const string FUNCNAME_PlayDialogueOnEntity = "SCB_PlayDialogueOnEntity"
const string FUNCNAME_PlayDialogueAtPosition = "SCB_PlayDialogueAtPosition"
const string FUNCNAME_PlayDialogueOnEnvironmentSpeakers = "SCB_PlayDialogueOnEnvironmentSpeakers"
const string FUNCNAME_PlayDialogueOnEnvironmentSpeakersNoResponse = "SCB_PlayDialogueOnEnvironmentSpeakersNoResponse"
const string FUNCNAME_PlayDialogueOnCustomSpeakers = "SCB_PlayDialogueOnCustomSpeakers"
const string FUNCNAME_AbortCurrentDialogue = "SCB_AbortCurrentDialogue"


void function Dialog_RegisterNetworking()
{
	Remote_RegisterClientFunction( FUNCNAME_PlayDialogueOnEntity, "int", -1, INT_MAX, "int", INT_MIN, INT_MAX, "int", INT_MIN, INT_MAX )
	Remote_RegisterClientFunction( FUNCNAME_PlayDialogueAtPosition, "int", -1, INT_MAX, "int", INT_MIN, INT_MAX, "vector", -MAX_WORLD_COORD, MAX_WORLD_COORD, 32 )
	Remote_RegisterClientFunction( FUNCNAME_PlayDialogueOnEnvironmentSpeakers, "int", 0, INT_MAX, "int", 0, INT_MAX, "int", 0, INT_MAX, "int", -1, INT_MAX, "entity", "int", -1, NUM_TOTAL_DIALOGUE_QUEUES )
	Remote_RegisterClientFunction( FUNCNAME_PlayDialogueOnEnvironmentSpeakersNoResponse, "int", 0, INT_MAX, "int", 0, INT_MAX, "int", 0, INT_MAX, "int", -1, INT_MAX, "int", -1, NUM_TOTAL_DIALOGUE_QUEUES )
	Remote_RegisterClientFunction( FUNCNAME_PlayDialogueOnCustomSpeakers, "int", 0, INT_MAX, "int", 0, INT_MAX, "int", -1, NUM_CUSTOM_QUEUES )
	//Remote_RegisterClientFunction( FUNCNAME_AbortCurrentDialogue ) //(mk): moved to byRef
}


DialogueData function GetDataForAliasId( int index )
{
	return file.registeredDialog[index]
}


#if SERVER && DEVELOPER
void function OnCharacterRegistered( ItemFlavor flavor )
{
	var block    = GetSettingsBlockForAsset( CharacterClass_GetSetFile( flavor ) )
	string voice = GetSettingsBlockString( block, "voice" )

	if ( !file.validVoices.contains( voice ) )
		file.validVoices.append( voice )
}
#endif //SERVER && DEVELOPER


#if(CLIENT)
int function GetAnyAliasIdForName( string dialogueName )
{
	if ( !(dialogueName in file.nameToGroupMap) )
		return -1
	DialogueEntryGroup group = file.nameToGroupMap[dialogueName]
	return group.aliasIds.getrandom()
}
#endif //

#if CLIENT || !DEVELOPER
void function OnCharacterRegistered( ItemFlavor flavor )
{
	var block    = GetSettingsBlockForAsset( CharacterClass_GetSetFile( flavor ) )
	string voice = GetSettingsBlockString( block, "voice" ).tolower()

	if ( !file.validVoices.contains( voice ) )
	{
		file.validVoices.append( voice )
		#if(CLIENT)
			CachedCharacterData ccd
			ccd.longName = ItemFlavor_GetLongName( flavor )
			ccd.portraitImage = CharacterClass_GetCharacterLockedPortrait( flavor )
			file.voiceToCachedCharDataMap[voice] <- ccd
		#endif //
	}
}
#endif


void function EnvironmentSpeakerListInit()
{
	#if(CLIENT)
		array<entity> speakerEnts = GetEntArrayByScriptName( ENVIRONMENT_SPEAKER_SCRIPT_NAME )

		foreach( speaker in speakerEnts )
		{
			RegisterEnvironmentSpeaker( speaker )
		}
	#endif //
}
#if SERVER
int function RequestCustomDialogueQueueIndex()
{
	Assert( file.numCustomQueuesUsed < NUM_CUSTOM_QUEUES, "Requested new custom dialogue queue, but all are taken! Consider increasing NUM_CUSTOM_QUEUES" )
	if( file.numCustomQueuesUsed >= NUM_CUSTOM_QUEUES )
		return 0

	// Starts at 1, since 0 is for main
	int queueIdx = file.numCustomQueuesUsed
	file.numCustomQueuesUsed++

	return queueIdx
}
#endif

#if(CLIENT)
void function CustomSpeakers1ListInit( array<entity> customSpeakers1 )
{
	if ( file.customSpeakers1.len() > 0 )
		printt( "Dialogue system custom speakers 1 already are set up, they are now being overwritten." )

	file.customSpeakers1 = customSpeakers1
}
#endif //


// #if(CLIENT)
// EnvironmentSpeaker function RegisterEnvironmentSpeaker( entity speakerEnt )
// {
	// EnvironmentSpeaker speaker
	// speaker.origin = speakerEnt.GetOrigin()
	// speaker.speakerEnt = speakerEnt

	// file.environmentSpeakers.append( speaker )
	// return speaker
// }
// #endif


// #if(CLIENT)
// void function DeregisterEnvironmentSpeaker( EnvironmentSpeaker speaker )
// {
	// file.environmentSpeakers.fastremovebyvalue( speaker )
// }
// #endif


void function RegisterCSVDialogue( asset dt )
{
	//
	var dataTable = GetDataTable( dt )

	int columnName                = GetDataTableColumnByName( dataTable, "name" )
	int columnAlias               = GetDataTableColumnByName( dataTable, "alias" )
	int columnPriority            = GetDataTableColumnByName( dataTable, "priority" )
	int columnRadioDisplayName    = GetDataTableColumnByName( dataTable, "radioDisplayName" )
	int columnVoice               = GetDataTableColumnByName( dataTable, "voice" )
	int columnRadioIntercept      = GetDataTableColumnByName( dataTable, "radioIntercept" )
	int columnVDUVideo            = GetDataTableColumnByName( dataTable, "vduVideo" )
	int columnDevDialogueText     = GetDataTableColumnByName( dataTable, "dialogue" )
	int optionalColumnPerspective = GetDataTableColumnByName( dataTable, "perspective" )
	int optionalCanPlayIfSolo     = GetDataTableColumnByName( dataTable, "canPlayIfSolo" )

	int numRows = GetDatatableRowCount( dataTable )
	for ( int i = 0; i < numRows; i++ )
	{
		string name = GetDataTableString( dataTable, i, columnName )

		//
		if ( name == "" )
			continue

		//
		if ( name.slice( 0, 2 ) == "//" )
			continue

		string alias = GetDataTableString( dataTable, i, columnAlias )
		int priority = GetDataTableInt( dataTable, i, columnPriority )
		Assert( priority >= 0, "Dialogue alias " + alias + " has invalid priority in the dialogue csv. Must be >= 0" )

		string extraPerspective = ((optionalColumnPerspective > -1) ? GetDataTableString( dataTable, i, optionalColumnPerspective ) : "")

		#if SERVER && DEVELOPER
		Assert( file.validPerspectives.contains( extraPerspective ), "Dialogue name " + name + " has a perspective field, but an invalid perspective. Check the perspective column in the CSV against file.validPerspectives in sh_sp_dialogue.gnut" )
		#endif

		bool canPlayIfSolo      = ((optionalCanPlayIfSolo > -1) ? GetDataTableBool( dataTable, i, optionalCanPlayIfSolo ) : true)
		string radioDisplayName = GetDataTableString( dataTable, i, columnRadioDisplayName )
		string voice            = ((columnVoice > -1) ? GetDataTableString( dataTable, i, columnVoice ).tolower() : "")
		bool radioIntercept     = ((columnRadioIntercept > -1) ? GetDataTableBool( dataTable, i, columnRadioIntercept ) : false)
		asset vduVideo          = ((columnVDUVideo > -1) ? GetDataTableAsset( dataTable, i, columnVDUVideo ) : $"")
		string DEV_DialogueText = GetDataTableString( dataTable, i, columnDevDialogueText )

		if ( (voice.len() > 0) && (!file.validVoices.contains( voice )) )
			Warning( "Dialogue '%s' in source '%s' specifies unknown voice '%s'.", name, string( dt ), voice )

		if ( (voice.len() > 0) && (radioDisplayName.len() > 0) )
		{
			Warning( "Dialogue '%s' has both voice '%s' and radioDisplay '%s'. Will only use voice.", name, voice, radioDisplayName )
			radioDisplayName = ""
		}

		RegisterDialogueLine( name, alias, priority, radioDisplayName, voice, radioIntercept, vduVideo, DEV_DialogueText, extraPerspective, canPlayIfSolo, dt )
	}
}


string s_prevNameRegistered
void function RegisterDialogueLine( string name, string alias, int priority, string radioDisplayName, string voice, bool radioIntercept, asset vduVideo, string DEV_DialogueText, string extraPerspective, bool canPlayIfSolo, asset dt )
{
	Assert( name != "", "Can't register a line of dialogue with no name" )
	Assert( priority >= 0, "Can't register a line of dialogue with a negative priority" )
	Assert( alias != "" || DEV_DialogueText != "", "Dialogue alias " + name + " doesn't have a miles event listed or dev text. You need one or the other." )

	if ( vduVideo != $"" )
		Assert( radioDisplayName != "", "Dialogue alias " + name + " specifies a vdu bink without setting radioDisplayName as well." )

// #if SERVER && DEVELOPER
	// if ( alias != "" && !DoesAliasExist( alias ) )
	// {
		// if ( alias.find( "%" ) >= 0 )
			// VerifyExistenceOfNongenericAliases( alias, extraPerspective )
		// else
			// Warning( "Error: Dialogue '" + name + "': alias '" + alias + "' can't be registered because the alias does not exist" )
	// }
// #endif // SERVER && DEVELOPER

	DialogueData data
	data.name = name
	data.alias = alias
	data.priority = priority
	data.perspective = extraPerspective
	data.canPlayIfSolo = canPlayIfSolo
	data.radioDisplayName = radioDisplayName
	data.voice = voice
	data.radioIntercept = radioIntercept
	data.vduVideo = vduVideo
	data.DEV_DialogueText = DEV_DialogueText

	int aliasId = file.registeredDialog.len()
	file.registeredDialog.append( data )

	if ( !(name in file.nameToGroupMap) )
	{
		DialogueEntryGroup newGroup
		newGroup.groupName = name
		newGroup.sourceDataTable = dt
		file.nameToGroupMap[name] <- newGroup
	}
	DialogueEntryGroup group = file.nameToGroupMap[name]
	Assert( (dt == group.sourceDataTable), format( "Dialogue entry '%s' from '%s' has already been defined in '%s'.", name, string( dt ), string( group.sourceDataTable ) ) )
	Assert( ((group.aliasIds.len() == 0) || (s_prevNameRegistered == name)), format( "Dialogue entry '%s' in '%s' is defined in more than one section. Dupes (groups) are allowed, but must be defined all one-after-another.", name, string( dt ) ) )

	data.indexInGroup = group.aliasIds.len()
	data.group = group
	group.aliasIds.append( aliasId )

	// printt( "DIALOGUE", name )

	s_prevNameRegistered = name
}

#if SERVER && DEVELOPER
void function VerifyExistenceOfNongenericAliases( string alias, string extraPerspective )
{
	array<string> specifiedPerspectiveAliases = []

	if ( alias.find( "%perspective%" ) >= 0 )
	{
		specifiedPerspectiveAliases.append( StringReplace( alias, "%perspective%", "1p" ) )
		specifiedPerspectiveAliases.append( StringReplace( alias, "%perspective%", "3p" ) )

		if ( extraPerspective != "" )
		{
			specifiedPerspectiveAliases.append( StringReplace( alias, "%perspective%", extraPerspective ) )
		}

	}
	else
	{
		specifiedPerspectiveAliases.append( alias )
	}

	foreach( string specifiedAlias in specifiedPerspectiveAliases )
	{
		if ( specifiedAlias.find( "%voice%" ) >= 0 )
		{
			foreach ( string voice in file.validVoices )
			{
				IssueWarningIfAliasMissing( StringReplace( specifiedAlias, "%voice%", voice ) )
			}
		}
		else
		{
			IssueWarningIfAliasMissing( specifiedAlias )
		}
	}
}

void function IssueWarningIfAliasMissing( string alias )
{
	if( !DoesAliasExist( alias ) )
		Warning( "Error: Dialogue alias '" + alias + "' can't be registered because the alias does not exist. Most likely missing a Miles event." )
}
#endif // SERVER && DEVELOPER

int function GetLinePriority( int aliasID )
{
	if ( aliasID == -1 )
		return -1

	DialogueData data = file.registeredDialog[aliasID]
	return data.priority
}

#if SERVER // TODO: This all needs to be fixed in the future!!!!
void function PlayDialogueForAnimEvent( entity ent, string dialogueName )
{
	if ( !( dialogueName in file.nameToGroupMap ) )
	{
		printt(  ( "Dialogue line " + dialogueName + " is not registered" ) )
		return
	}

	DialogueEntryGroup group = file.nameToGroupMap[dialogueName]
	int aliasID = group.aliasIds.getrandom()
	DialogueData data = file.registeredDialog[aliasID]
	Assert( data.priority == PRIORITY_NO_QUEUE, ("Dialogue " + dialogueName + " triggered via qc must use PRIORITY_NO_QUEUE") )
	thread PlayDialogue( dialogueName, ent )
}

void function PlayDialogue( string name, entity speaker, float delay = 0, int dialogueFlags = 0 )
{
	array<entity> players = GetPlayerArray_Alive()
	for ( int i = players.len() - 1; i >= 0; i-- )
	{
		if ( i > 0 )
			thread PlayDialogueForPlayer( name, players[i], speaker, delay, dialogueFlags )
		else
			waitthread PlayDialogueForPlayer( name, players[i], speaker, delay, dialogueFlags )
	}
}

void function PlayDialogue_AllConnectedPlayers( string name, entity speaker, float delay = 0, int dialogueFlags = 0 )
{
	array<entity> players = GetPlayerArray()
	for ( int i = players.len() - 1; i >= 0; i-- )
	{
		if ( i > 0 )
			thread PlayDialogueForPlayer( name, players[i], speaker, delay, dialogueFlags )
		else
			waitthread PlayDialogueForPlayer( name, players[i], speaker, delay, dialogueFlags )
	}
}

void function PlayDialogue_NoWait( string name, entity speaker )
{
	array<entity> players = GetPlayerArray_Alive()
	for ( int i = players.len() - 1; i >= 0; i-- )
		PlayDialogueForPlayer_NoWait( name, players[i], speaker )
}

void function PlayBTDialogue( string name, float delay = 0, int dialogueFlags = 0 )
{
	/*array<entity> players = GetPlayerArray_Alive()
	for ( int i = players.len() - 1; i >= 0; i-- )
	{
		entity speaker
		entity petTitan = players[i].GetPetTitan()
		if ( IsValid( petTitan ) )
			speaker = GetBuddyTitanDialogueEnt( petTitan )
		else
			speaker = GetBuddyTitanDialogueEnt( players[i] )

		// Catch issues like BT is not created yet so the dialogue ent doesn't exist yet. In this case we just use the player for sound position, which gives us the same result anyhow.
		if ( !IsValid( speaker ) )
			speaker = players[i]

		if ( i > 0 )
			thread PlayDialogueForPlayer( name, players[i], speaker, delay, dialogueFlags )
		else
			waitthread PlayDialogueForPlayer( name, players[i], speaker, delay, dialogueFlags )
	}*/
}

void function PlayGabbyDialogue( string name, entity speaker, string anim = "face_generic_talker_flat" )
{
	speaker.EndSignal( "OnDestroy" )

	//for the next game we shouldn't have variants of dialogue and functionality should be done through a CSV - Chad
	speaker.Anim_ScriptedAddGestureSequence( anim, false )
	PlayDialogue( name, speaker )
	speaker.Anim_ScriptedRemoveAllGestures()
}

void function StopDialogue()
{
	array<entity> players = GetPlayerArray_Alive()
	foreach ( player in players )
		Remote_CallFunction_ByRef( player, "SCB_AbortCurrentDialogue" )
		//Remote_CallFunction_NonReplay( player, "SCB_AbortCurrentDialogue" )
}

void function StopDialogueForPlayer( entity player )
{
	//Remote_CallFunction_NonReplay( player, "SCB_AbortCurrentDialogue" )
	Remote_CallFunction_ByRef( player, "SCB_AbortCurrentDialogue" )
}

void function PlayDialogue_Internal( int aliasID, int dialogueFlags, entity player, entity speaker, int responseID = -1, entity responseSpeaker = null, int customQueueIdx = -1 )
{
	if ( player == speaker )
	{
		DialogueData data = GetDataForAliasId( aliasID )
		DialogueData dataClone = data
		Assert( true, data.name)
	}

	if ( dialogueFlags & eDialogueFlags.SURVIVAL_HOST_ALL_SPEAKERS )
	{
		if ( IsValid( responseSpeaker ) )
			Remote_CallFunction_NonReplay( player, FUNCNAME_PlayDialogueOnEnvironmentSpeakers, aliasID, NUM_NEARBY_SPEAKERS_TO_PLAY_FROM, dialogueFlags, responseID, responseSpeaker, customQueueIdx )
		else
			Remote_CallFunction_NonReplay( player, FUNCNAME_PlayDialogueOnEnvironmentSpeakersNoResponse, aliasID, NUM_NEARBY_SPEAKERS_TO_PLAY_FROM, dialogueFlags, responseID, customQueueIdx )
	}
	else if ( dialogueFlags & eDialogueFlags.USE_CUSTOM_SPEAKERS )
	{
		// Idx -1 is invalid, idx 0 is main
		Assert( customQueueIdx < NUM_CUSTOM_QUEUES, "Custom speakers requested with invalid index! " + customQueueIdx )
		Remote_CallFunction_NonReplay( player, FUNCNAME_PlayDialogueOnCustomSpeakers, aliasID, dialogueFlags, customQueueIdx )
	}
	else if ( speaker.IsNPC() || speaker.IsPlayer() || (speaker.GetClassName() == "script_mover_lightweight") )
	{
		string milesAlias = GetDataForAliasId( aliasID ).alias
		string voice = GetPlayerVoice( speaker )
		if ( milesAlias.find( "%voice%" ) >= 0 )
			milesAlias = StringReplace( milesAlias, "%voice%", voice )

		// #if DEVELOPER
			// if ( ShouldTryToReplaceMissingVoiceWithTempVoice() )
			// {
				// if ( !DoesAliasExist( milesAlias ) )
				// {
					// if ( milesAlias.find( "%voice%" ) >= 0 )
					// {
						// milesAlias = StringReplace( milesAlias, "%voice%", TEMP_VOICE )
					// }
				// }
			// }
		// #endif // DEVELOPER

		if ( milesAlias.find( "%perspective%" ) >= 0 )
			milesAlias = StringReplace( milesAlias, "%perspective%", "3p" )

		Remote_CallFunction_NonReplay( player, FUNCNAME_PlayDialogueOnEntity, aliasID, dialogueFlags, speaker.GetEncodedEHandle() ) //EvaluateSoundSelector( milesAlias )
	}
	else
	{
		vector pos = (speaker == svGlobal.worldspawn) ? player.EyePosition() : speaker.GetOrigin()
		Remote_CallFunction_NonReplay( player, FUNCNAME_PlayDialogueAtPosition, aliasID, dialogueFlags, pos )
	}
}

void function PlayDialogueForPlayer_NoWait( string name, entity player, entity speaker, int dialogueFlags = 0, int customQueueIdx = -1 )
{
	if ( !IsValid( player ) )
		return
	if ( !IsValid( speaker ) )
		return
	Assert( player.IsPlayer(), "Tried to play dialogue " + name + " to a non-player" )

	int aliasID = GetNextAliasIdForName( name )
	if ( aliasID < 0 )
	{
		printt( "Dialogue line " + name + " is not registered" )
		return
	}

	PlayDialogueIdForPlayer_NoWait( aliasID, player, speaker, dialogueFlags, customQueueIdx )
}

void function PlayDialogueIdForPlayer_NoWait( int aliasId, entity player, entity speaker, int dialogueFlags = 0, int customQueueIdx = -1 )
{
	if ( !ShouldPlayDialogueIfSolo( GetDataForAliasId( aliasId ), speaker ) )
		return
	PlayDialogue_Internal( aliasId, dialogueFlags | eDialogueFlags.NO_ON_FINISHED_NOTIFY, player, speaker )
}

void function PlayRadioDialogueTo_Internal( string alias, array<entity> players )
{
	/*int dialogueFlags = 0

	int aliasID = file.registeredDialog.find( alias )
	Assert( aliasID >= 0, "Given dialogue alias not registered." )
	foreach( entity player in players )
	{
		if ( !IsValid( player ) )
			continue
		PlayDialogue_Internal( aliasID, (dialogueFlags | eDialogueFlags.NO_ON_FINISHED_NOTIFY | eDialogueFlags.SHORT_DELAY_AFTER_PLAYING), player, svGlobal.worldspawn )
	}*/
}

void function PlayRadioDialogueToAll( string alias )
{
	array<entity> players = GetPlayerArray()
	PlayRadioDialogueTo_Internal( alias, players )
}

void function PlayRadioDialogueToTeam( string alias, int teamNum )
{
	array<entity> players = GetPlayerArrayOfTeam( teamNum )
	PlayRadioDialogueTo_Internal( alias, players )
}

void function PlayRadioDialogueToPlayer( string alias, entity player )
{
	PlayRadioDialogueTo_Internal( alias, [player] )
}

void function PlayDialogueForPlayer_Retail( string name, entity player, entity speaker, float delay = 0, int dialogueFlags = 0, string responseName = "", entity responseSpeaker = null, int customQueueIdx = -1 )
{
	if ( !IsValid( player ) )
		return
	Assert( player.IsPlayer() )

	bool isForAllSpeakers = ((dialogueFlags & eDialogueFlags.SURVIVAL_HOST_ALL_SPEAKERS) != 0)
	if ( !IsValid( speaker ) && !isForAllSpeakers )
	{
		if ( !IsBitFlagSet( dialogueFlags, eDialogueFlags.USE_CUSTOM_SPEAKERS ) )
		{
			Warning( "Attempted to play dialogue on a null speaker without identifying an environmental/custom speaker flag." )
			return
		}
	}

	int aliasID = GetNextAliasIdForName( name )
	if ( aliasID < 0 )
	{
		printt( "Dialogue line " + name + " is not registered" )
		return
	}

	int responseID = -1
	if ( responseName != "" )
	{
		responseID = GetNextAliasIdForName( responseName )
		if ( responseID < 0 )
		{
			printt( "Dialogue line " + responseName + " is not registered" )
		}
		else
		{
			if ( ! ShouldPlayDialogueIfSolo( GetDataForAliasId( responseID ), responseSpeaker ) )
				responseID = -1
		}
	}

	PlayAliasIdForPlayer( aliasID, player, speaker, delay, dialogueFlags, responseID, responseSpeaker, customQueueIdx )
}

void function PlayAliasIdForPlayer( int aliasID, entity player, entity speaker, float delay = 0, int dialogueFlags = 0, int responseID = -1, entity responseSpeaker = null, int customQueueIdx = -1 )
{
	EndSignal( player, "OnDestroy" )
	if ( IsValid( speaker ) )
		EndSignal( speaker, "OnDestroy" )

	if ( delay > 0 )
		wait delay

	file.dialoguePlaying = true
	file.lastLineRequestPriority = GetLinePriorityForAliasId( aliasID )

	OnThreadEnd(
		function() : ( aliasID )
		{
			file.dialoguePlaying = false
			if ( aliasID in file.waitingOnDialogue )
				delete file.waitingOnDialogue[aliasID]
		}
	)

	if ( !(aliasID in file.waitingOnDialogue) )
		file.waitingOnDialogue[aliasID] <- true

	PlayDialogue_Internal( aliasID, dialogueFlags, player, speaker, responseID, responseSpeaker, customQueueIdx )

	while ( true )
	{
		table signalData = WaitSignal( player, "DialogueFinishedForID", "AllDialogueFinished" )
		if ( string( signalData.signal ) == "AllDialogueFinished" )
			break
		if ( signalData.aliasID == aliasID )
			break
		if ( !(aliasID in file.waitingOnDialogue) )
			break
	}
}

void function PlayDialogueForPlayer( string name, entity player, entity speaker, float delay = 0, int dialogueFlags = 0, string responseName = "", entity responseSpeaker = null )
{
	if ( !IsBattleChatterEnabled() )
		return

	if ( !IsValid( player ) )
		return

	if ( !IsValid( speaker )  && ( !( dialogueFlags & eDialogueFlags.SURVIVAL_HOST_ALL_SPEAKERS ) ) )
		return

	EndSignal( player, "OnDestroy" )

	if ( !( dialogueFlags & eDialogueFlags.SURVIVAL_HOST_ALL_SPEAKERS ) )
		EndSignal( speaker, "OnDestroy" )

	if ( !( name in file.nameToGroupMap ) )
	{
		printt( "Dialogue line " + name + " is not registered" )
		return
	}

	DialogueEntryGroup group = file.nameToGroupMap[name]
	int aliasID = group.aliasIds.getrandom()

	int responseID = -1
	if ( responseName != "" )
	{
		if ( !( responseName in file.nameToGroupMap ) )
		{
			printt( "Dialogue line " + responseName + " is not registered" )
		}
		else
		{
			DialogueEntryGroup responseGroup = file.nameToGroupMap[responseName]
			responseID = responseGroup.aliasIds.getrandom()

			Assert( GetLinePriority( responseID ) == PRIORITY_NO_QUEUE, "Can only pass responseName as param if primary dialogue line has 0 priority. Response should be queued instead." )

			if ( ! ShouldPlayDialogueIfSolo( file.registeredDialog[responseID], responseSpeaker ) )
			{
				responseID = -1
			}
		}
	}

	Assert( player.IsPlayer(), "Tried to play dialogue " + name + " to a non-player" )

	if ( delay > 0 )
		wait delay

	if( !IsValid( player ) )
		return

	if ( ! ShouldPlayDialogueIfSolo( file.registeredDialog[aliasID], speaker ) )
	{
		return
	}

	file.dialoguePlaying = true
	file.lastLineRequestPriority = GetLinePriority( aliasID )

	OnThreadEnd(
	function() : ( aliasID )
		{
			file.dialoguePlaying = false
			if ( aliasID in file.waitingOnDialogue )
				delete file.waitingOnDialogue[aliasID]
		}
	)

	if ( !(aliasID in file.waitingOnDialogue) )
		file.waitingOnDialogue[aliasID] <- true

	PlayDialogue_Internal( aliasID, dialogueFlags, player, speaker, responseID, responseSpeaker )

	while ( true )
	{
		table signalData = WaitSignal( level, "DialogueFinishedForID", "AllDialogueFinished" )
		if ( string( signalData.signal ) == "AllDialogueFinished" )
			break
		if ( int( signalData.aliasID ) == aliasID )
			break
		if ( !(aliasID in file.waitingOnDialogue) )
			break
	}
}

bool function ClientCommand_DialogueFinishedForID( entity player, array<string> args )
{
	string aliasID = args[ 0 ]
	table signalData = { aliasID = aliasID }
	if ( int( aliasID ) in file.waitingOnDialogue )
		delete file.waitingOnDialogue[int( aliasID )]
	Signal( level, "DialogueFinishedForID", signalData )
	return true
}

bool function ClientCommand_AllDialogueFinished( entity player, array<string> args )
{
	// This happens when a save is loaded. Server will be waiting to hear back from client that a dialogue alias is finished but client was reset, so we tell the server the line has stopped playing
	Signal( level, "AllDialogueFinished" )
	return true
}

#endif //SERVER


#if(CLIENT)
string function GetAnyDialogueAliasFromName( string name )
{
	int aliasID = GetAnyAliasIdForName( name )
	Assert( aliasID >= 0, "Dialogue line " + name + " is not registered" )
	DialogueData data = GetDataForAliasId( aliasID )
	return data.alias
}



int s_queueItemNextNum = 0
QueueItem function QueueAndWait( int priority, QueueData queueData, int dialogueFlags, int entHandle, string milesAlias )
{
	// Creates an ID and adds it to the queue. Waits until that ID is up to be played or canceled and returns the result

	// Create queue item
	QueueItem queueItem
	queueItem.priority = priority
	queueItem.timeAdded = Time()
	queueItem.entHandle = entHandle
	queueItem.debugRef = milesAlias
	queueItem.serialNum = s_queueItemNextNum

	s_queueItemNextNum += 1

	// Instant priority items don't use the queue. This may changed based on our needs though, if we need this line to cut off whatever is playing
	if ( priority == PRIORITY_NO_QUEUE )
		return queueItem

	// if any items in the queue should block lower priority lines, check to see if this item should be blocked from being added.
	if ( queueData.queue.len() > 0 )
	{
		foreach ( QueueItem alreadyAddedItem in queueData.queue )
		{
			if ( !GetCurrentPlaylistVarBool( "requeue_identical_vo", false ) && alreadyAddedItem.debugRef == milesAlias && alreadyAddedItem.entHandle == entHandle )
			{
				queueItem.success = false
				return queueItem
			}
		}
	}

	// Add it to the queue
	_AddToQueue( queueItem, queueData )

	// Wait for it to be up in the queue
	table result = WaitSignal( queueItem, "NextInQueue", "RemovedFromQueue" )
	//PrintTable( result )

	queueItem.success = (result.signal == "NextInQueue")
	//printt( "queueItem.success:", queueItem.success )

	// Return the queue item back to the caller so it can removed it
	return queueItem
}

void function _AddToQueue( QueueItem queueItem, QueueData queueData )
{
	Assert( !queueData.queue.contains( queueItem ) )

	queueData.queue.append( queueItem )
	queueData.queue.sort( QueueSort )

	//
	if ( queueData.queue.len() > 1 )
	{
		for ( int i = queueData.queue.len() - 1; i >= 0; i-- )
		{
			if ( queueData.queue[i].priority >= queueItem.priority )
				continue

			RemoveFromQueue( queueData.queue[i], queueData.queue )

			if ( i == 0 )
				AbortCurrentDialogue()
		}
	}

	//
	Signal( queueData.signalDummy, "QueueUpdated" )
}


void function RemovePlayerDialogueEventsFromMainDialogueQueue( entity player )
{
	if ( !IsValid( player ) )
		return

	array<QueueItem> queue = file.allQueues[QUEUE_MAIN].queue

	int playerEntHandle = player.GetEncodedEHandle()

	if ( queue.len() >= 1 )
	{
		for ( int i = queue.len() - 1; i >= 0; i-- )
		{
			if ( queue[i].entHandle == -1 )
				continue

			if ( queue[i].entHandle == playerEntHandle )
			{
				RemoveFromQueue( queue[i], queue )

				if ( i == 0 )
					AbortCurrentDialogue()
			}
		}
	}
}


void function RemoveFromQueue( QueueItem queueItem, array<QueueItem> queue )
{
	//
	Signal( queueItem, "RemovedFromQueue" )
	if ( queue.contains( queueItem ) )
		queue.removebyvalue( queueItem )
}


int function QueueSort( QueueItem itemA, QueueItem itemB )
{
	if ( itemA.active )
		return -1
	if ( itemB.active )
		return 1

	if ( itemA.priority > itemB.priority )
		return -1
	if ( itemA.priority < itemB.priority )
		return 1

	if ( itemA.timeAdded < itemB.timeAdded )
		return -1
	if ( itemA.timeAdded > itemB.timeAdded )
		return 1

	if ( itemA.serialNum < itemB.serialNum )
		return -1
	if ( itemA.serialNum > itemB.serialNum )
		return 1

	Assert( itemA == itemB, "Queue items should never have equal sort values." )
	return 0
}


void function QueueThink( QueueData queueData )
{
	QueueItem currentItem
	array<QueueItem> queue = queueData.queue
	while ( true )
	{
		if ( queue.len() == 0 )
		{
			if ( DEBUG_QUEUE_PRINTS )
				printt( "Queue empty - waiting for signal" )
			WaitSignal( queueData.signalDummy, "QueueUpdated" )
			continue
		}

		FlagWaitClear( queueData.flagPauseQueue )

		if ( queue.len() == 0 )
			continue

		currentItem = queue[0]
		Signal( currentItem, "NextInQueue" )

		currentItem.active = true
		if ( DEBUG_QUEUE_PRINTS )
			printt( "waiting for script to clear the queue current item" )
		while ( queue.len() > 0 && currentItem == queue[0] )
		{
			if ( DEBUG_QUEUE_PRINTS )
			{
				printt( "Queue (len = " + queue.len() + "):" )
				foreach ( int i, QueueItem queueItem in queue )
				{
					if ( queueItem.active )
						printt( "  ", i, queueItem.timeAdded, "PRIORITY", queueItem.priority, queueItem.debugRef, "ACTIVE!" )
					else
						printt( "  ", i, queueItem.timeAdded, "PRIORITY", queueItem.priority, queueItem.debugRef )
				}
			}
			WaitFrame()
		}
	}
}


void function PauseMainDialogueQueue()
{
	PauseDialogueQueue( eDialogueQueues.main )
}


void function PauseDialogueQueue( int queueIdx )
{
	Assert( queueIdx < eDialogueQueues._COUNT, "Unknown enum index for eDialogueQueues: " + queueIdx )

	QueueData data = file.allQueues[ queueIdx ]

	FlagSet( data.flagPauseQueue )
	data.dialoguePauseStackCount++
}


void function ResumeMainDialogueQueue()
{
	ResumeDialogueQueue( eDialogueQueues.main )
}


void function ResumeDialogueQueue( int queueIdx )
{
	Assert( queueIdx < eDialogueQueues._COUNT, "Unknown enum index for eDialogueQueues: " + queueIdx )

	QueueData data = file.allQueues[ queueIdx ]

	data.dialoguePauseStackCount--
	if ( data.dialoguePauseStackCount <= 0 )
		FlagClear( data.flagPauseQueue )

	Assert( data.dialoguePauseStackCount >= 0, "Warning! ResumeDialogueQueue() called but queue wasn't paused!" )
}


void function SuspendMainDialogueQueueForDurationOfSound( entity player, var soundHandle )
{
	EndSignal( player, "OnDestroy" )

	OnThreadEnd(
		function()
		{
			ResumeMainDialogueQueue()
		}
	)

	PauseMainDialogueQueue()
	WaitSignal( soundHandle, "OnSoundFinished" )
}


void function SCB_PlayDialogueOnEntity( int aliasID, int dialogueFlags, int speakerEHandle )
{
	entity speaker = GetEntityFromEncodedEHandle( speakerEHandle )
	thread PlayClientDialogueOnEntity( aliasID, dialogueFlags, speaker )
}


void function SCB_PlayDialogueAtPosition( int aliasID, int dialogueFlags, vector pos )
{
	thread PlayClientDialogueOnPos( aliasID, dialogueFlags, pos )
}


void function SCB_PlayDialogueOnEnvironmentSpeakers( int aliasID, int numSpeakers, int dialogueFlags, int responseID, entity responseSpeaker, int customQueueIdx )
{
	Assert( !( dialogueFlags & eDialogueFlags.USE_CUSTOM_QUEUE ) , "Environment speaker dialogue must NOT be called using the custom queue." )

	if ( file.blockAnnouncer )
		return

	array<EnvironmentSpeaker> nearbySpeakers = SortEnvironmentSpeakersByClosest()
	array<entity> speakerEnts
	foreach ( int i, EnvironmentSpeaker speaker in nearbySpeakers )
	{
		if ( i >= numSpeakers )
			break
		speakerEnts.append( speaker.speakerEnt )
	}

	if ( speakerEnts.len() == 0 )
	{
		printt( "No speakers found within 10000 units. Using local client player as speaker." )
		speakerEnts.append( GetLocalClientPlayer() )
	}
	
	if ( responseID < 0 )
		thread PlayClientDialogueOnSpeakers( aliasID, dialogueFlags, speakerEnts, customQueueIdx )
	else
		thread PlayClientDialogueInCustomQueueWithMainQueuedResponse( aliasID, responseID, dialogueFlags, speakerEnts, responseSpeaker, customQueueIdx )
}

void function PlayClientDialogueInCustomQueueWithMainQueuedResponse( int aliasID, int responseID, int dialogueFlags, array<entity> speakers, entity responseSpeaker, int customQueueIdx )
{
	DialogueData leadingLineData  = GetDataForAliasId( aliasID )
	DialogueData responseLineData = GetDataForAliasId( responseID )

	string leadingMilesAlias  = leadingLineData.alias
	string responseMilesAlias = responseLineData.alias

	waitthread PlayClientDialogueOnSpeakers( aliasID, dialogueFlags, speakers, customQueueIdx )

	if ( IsValid( responseSpeaker ) )
	{
		// Clear custom queue flag
		int responseDialogueFlags = dialogueFlags & ~( eDialogueFlags.USE_CUSTOM_QUEUE )
		thread PlayClientDialogueOnEntity( responseID, responseDialogueFlags, responseSpeaker )
	}
}

void function SCB_PlayDialogueOnEnvironmentSpeakersNoResponse( int aliasID, int numSpeakers, int dialogueFlags, int responseID, int customQueueIdx )
{
	SCB_PlayDialogueOnEnvironmentSpeakers( aliasID, numSpeakers, dialogueFlags, responseID, null, customQueueIdx )
}

array<EnvironmentSpeaker> function SortEnvironmentSpeakersByClosest()
{
	entity player    = GetLocalClientPlayer()
	vector playerPos = player.GetOrigin()

	array<EnvironmentSpeaker> nearbySpeakers
	const float maxDistSqr = 10000 * 10000
	foreach ( EnvironmentSpeaker speaker in file.allSpeakersList[ QUEUE_MAIN ] )
	{
		float distanceSqr = Distance2DSqr( playerPos, speaker.origin )
		if ( distanceSqr > maxDistSqr )
			continue

		speaker.distanceSqr = distanceSqr
		nearbySpeakers.append( speaker )
	}

	nearbySpeakers.sort( DistanceCompareClosestSpeaker )

	return nearbySpeakers
}


int function DistanceCompareClosestSpeaker( EnvironmentSpeaker a, EnvironmentSpeaker b )
{
	if ( a.distanceSqr > b.distanceSqr )
		return 1
	else if ( a.distanceSqr < b.distanceSqr )
		return -1

	return 0
}


void function SCB_PlayDialogueOnCustomSpeakers( int aliasID, int dialogueFlags, int customQueueIdx ) //custom queue is not implemented. Cafe EvaluateSoundSelector is not in s3
{
	if ( file.customSpeakers1.len() == 0 )
	{
		if ( Flag( "EntitiesDidLoad" ) )
			printt( "Custom Speakers 1 debug: Entities have loaded." )
		else
			printt( "Custom Speakers 1 debug: Entities have NOT loaded." )

		Assert( 0, "Custom Speakers 1 haven't been registered. Use the function CustomSpeakers1ListInit to create the array of speakers to be used." )
	}

	const float maxDistSqr = 2000.0 * 2000.0

	//
	entity player           = GetLocalClientPlayer()
	vector playerPos        = player.GetOrigin()
	bool playerNearSpeakers = false

	foreach ( entity speaker in file.customSpeakers1 )
	{
		if ( !IsValid( speaker ) )
			continue

		if ( Distance2DSqr( playerPos, speaker.GetOrigin() ) <= maxDistSqr )
		{
			playerNearSpeakers = true
			break
		}
	}

	if ( playerNearSpeakers )
		thread PlayClientDialogueOnSpeakers( aliasID, dialogueFlags, file.customSpeakers1 )
}


void function PlayClientDialogue_Internal( int aliasID, int dialogueFlags, array<entity> speakers, vector pos, int customQueueIdx = -1, int selector = -1 )
{
	DialogueData data = GetDataForAliasId( aliasID )

	string milesAlias = data.alias

	if ( speakers.len() == 1 && !ShouldPlayDialogueIfSolo( data, speakers[0] ) )
		return
	// if ( speakers.len() == 1 && IsValid( speakers[0] ) && speakers[0].IsPlayer() && (GetPlayerVoice( speakers[0] ) == SILENT_PLAYER_VOICE) )
	// {
		// DisplaySilentPlayerVoiceDialogue( speakers[0], data )
		// return
	// }

	string radioDisplayName = data.radioDisplayName
	asset specificImage     = $""

	                                
		if ( speakers.len() == 1 && IsValid( speakers[0] ) && speakers[0].IsPlayer() && (dialogueFlags & eDialogueFlags.STOMP_CON_ALT ) )
		{
			array<string> condAltDialogueAliases
			array<entity> squadmates = GetPlayerArrayOfTeam_Alive( speakers[0].GetTeam() )

			foreach ( entity squadmate in squadmates )
			{
				if ( squadmate == speakers[0] )
					continue

				string condAltAlias = ""//GetConditionalAltDialogue( data.name, speakers[0], squadmate )
				if ( condAltAlias != "" )
				{
					// if ( ShouldForcePlayConditionalAlt( condAltAlias ) )
					// {
						// condAltDialogueAliases = [ condAltAlias ]
						// break
					// }
					condAltDialogueAliases.append( condAltAlias )
				}
			}

			string condWildCardAltAlias = ""//GetConditionalAltMapOnlyDialogue( data.name, speakers[0] )
			if ( condWildCardAltAlias != "" )
			{
				// if ( ShouldForcePlayConditionalAlt( condWildCardAltAlias ) )
				// {
					// condAltDialogueAliases = [ condWildCardAltAlias ]
				// }
				// else
				// {
					condAltDialogueAliases.append( condWildCardAltAlias )
				// }
			}

			if ( condAltDialogueAliases.len() > 0 )
			{
				milesAlias = condAltDialogueAliases.getrandom()
			}
		}
                                       

	if ( milesAlias.find( "%" ) >= 0 )
	{
		Assert ( speakers.len() == 1, "Generic audio alias attempted to be made specific from multiple speakers simultaneously." )

		if ( IsValid( speakers[0] ) )
		{
			milesAlias = SpecifyAliasFromGeneric( data, milesAlias, speakers[0] )
		}
		else if ( speakers[0] == null )
		{
			milesAlias = SpecifyRadioDialoguePerspective( data )
		}
		else
		{
			Warning( "Tried to play '%s' with an invalid speaker. Couldn't specify generic alias.", milesAlias )
			return
		}
	}

	if ( (data.voice.len() > 0) && (data.voice in file.voiceToCachedCharDataMap) )
	{
		CachedCharacterData ccd = file.voiceToCachedCharDataMap[data.voice]
		radioDisplayName = ccd.longName
		specificImage = ccd.portraitImage
	}

	int speakerEHandle = -1
	if ( speakers.len() == 1 && IsValid( speakers[0] ) )
		speakerEHandle = speakers[0].GetEncodedEHandle()

	QueueData queueData = file.allQueues[ QUEUE_MAIN ]

	if ( ( dialogueFlags & eDialogueFlags.USE_CUSTOM_QUEUE ) )
		queueData = file.allQueues[ customQueueIdx ]

	QueueItem queueItem = QueueAndWait( data.priority, queueData, dialogueFlags, speakerEHandle, milesAlias )
	// The queue wait is not successful it if was removed before it got in turn (caused by higher priority lines taking over, deduping logic, etc)
	if ( !queueItem.success )
		return

	if ( DEBUG_QUEUE_PRINTS )
	{
		printt( "Dialogue Added to Queue" )
		printt( "  name:", data.group.groupName )
	}

	bool isDevText = ((data.alias == "") && (data.DEV_DialogueText != ""))
	
	#if DEVELOPER
		printf( "Playing Dialogue - '%s'#%d -> '%s', priority:%d, from:'%s'  %s", data.group.groupName, data.indexInGroup, milesAlias, data.priority, string( data.group.sourceDataTable ), (isDevText ? " (dev text)" : "") )
	#endif

	// if ( milesAlias.find( "_cond" ) >= 0 || milesAlias.find( "_flavor" ) >= 0 )  {
		// PIN_DynamicDialogue( milesAlias )
	// }

	float duration
	float extraWait = 0.0
	string speakerName
	// if ( isDevText )
	// {
		// duration = data.dialogueTextDuration
		// if ( duration < FLT_EPSILON )
			// duration = max( data.dialogueText.len() * 0.07, 1.5 )
		// printt( "len, duration", data.dialogueText.len(), duration )
		// if ( speakers.len() == 0 || !IsValid( speakers[0] ) )
			// speakerName = ((radioDisplayName.len() > 0) ? Localize( radioDisplayName ) : "non_NPC")
		// else
			// speakerName = speakers[0].GetScriptName()
	// }
	// else
	// {
		duration = GetSoundDuration( milesAlias )
	// }

	if ( ( dialogueFlags & eDialogueFlags.SHORT_DELAY_AFTER_PLAYING ) )
		extraWait = 0.40

	var waveformRUI = null
	if ( (radioDisplayName != "") && (specificImage != $"") && file.useVDU )
	{
		// waveformRUI = CreateDialogPopup( radioDisplayName, duration + extraWait, specificImage, data.dialogueText )

		// foreach ( void functionref() cb in file.dialoguePopupCreatedCallbacks )
			// cb()

		if ( data.vduVideo != $"" )
			StartVideoOnChannel( file.videoChannel, data.vduVideo, false, 0.0 )
	}

	foreach ( entity speaker in speakers )
	{
		if ( IsValid( speaker ) )
		{
			EndSignal( speaker, "OnDeath" )
			EndSignal( speaker, "OnDestroy" )
		}
	}

	entity player = GetLocalClientPlayer()
	EndSignal( player, "AbortCurrentDialogue" )

	OnThreadEnd(
		function() : ( player, aliasID, waveformRUI, queueItem, queueData, dialogueFlags )
		{
			if ( ( dialogueFlags & eDialogueFlags.MUTE_PLAYER_PING_DIALOGUE_FOR_DURATION ) )
				SetCommsDialogueEnabled( true )

			// if ( ( dialogueFlags & eDialogueFlags.MUTE_PLAYER_PING_CHIMES_FOR_DURATION ) )
				// SetCommsWaypointSoundsEnabled( true )

			if ( ( dialogueFlags & eDialogueFlags.BLOCK_ANNOUNCER ) )
				file.blockAnnouncer = false

			// Notify the server that the alias finished playing
			if ( IsValid( player ) && !( dialogueFlags & eDialogueFlags.NO_ON_FINISHED_NOTIFY ) )
				player.ClientCommand( "DialogueFinishedForID " + aliasID )
			if ( IsValid ( waveformRUI ) )
			{
				thread DestroyWaveform( waveformRUI )

				// foreach ( void functionref() cb in file.dialoguePopupDestroyedCallbacks )
					// cb()
			}

			file.currentDialoguePlayingHandle = null
			file.currentDialoguePlayingName = ""
			file.currentDialoguePlayingHandles = []

			RemoveItemFromQueue( queueItem, queueData.queue )
		}
	)

	if ( ( dialogueFlags & eDialogueFlags.MUTE_PLAYER_PING_DIALOGUE_FOR_DURATION ) )
		SetCommsDialogueEnabled( false )

	// if ( ( dialogueFlags & eDialogueFlags.MUTE_PLAYER_PING_CHIMES_FOR_DURATION ) )
		// SetCommsWaypointSoundsEnabled( false )

	if ( ( dialogueFlags & eDialogueFlags.BLOCK_ANNOUNCER ) )
		file.blockAnnouncer = true

	if ( !(milesAlias in FORBIDDEN_DIALOGUE_EVENT_NAMES) && !IsWatchingKillReplay() )
	{
		foreach ( entity speaker in speakers )
		{
			if ( IsValid( speaker ) )
			{
				// if ( isDevText )
				// {
					// if ( waveformRUI == null )
						// thread DevDialogueWithoutSoundAlias( speakerName, data.dialogueText, duration )
				// }
				// else 
				if ( ( dialogueFlags & eDialogueFlags.EMIT_FROM_FIXED_POSITION ) )
				{
					file.currentDialoguePlayingHandle = EmitSoundAtPosition( speaker.GetTeam(), speaker.GetOrigin(), milesAlias )
					file.currentDialoguePlayingName = data.name
				}
				else
				{
					file.currentDialoguePlayingHandle = EmitSoundOnEntity( speaker, milesAlias ) //EmitSoundOnEntityWithSelector( speaker, milesAlias, selector )
					file.currentDialoguePlayingName = data.name

					// SetPlayThroughPOVTransitions( file.currentDialoguePlayingHandle )
				}
			}
			else if ( pos != <0, 0, 0> )
			{
				// if ( isDevText )
				// {
					// if ( waveformRUI == null )
						// thread DevDialogueWithoutSoundAlias( speakerName, data.dialogueText, duration )
				// }
				// else
				// {
					file.currentDialoguePlayingHandle = EmitSoundAtPosition( TEAM_UNASSIGNED, pos, milesAlias )
					file.currentDialoguePlayingName = data.name
				// }
			}
		}
	}

	if ( file.currentDialoguePlayingHandle != null )
	{
		WaitSignal( file.currentDialoguePlayingHandle, "OnSoundFinished" )
		wait extraWait
	}
	else
	{
		// Dev text doesn't play a sound event, so we just wait a calculated duration
		wait duration + extraWait
	}

	if ( data.vduVideo != $"" )
		StopVideoOnChannel( 2 )

	if ( SurvivalCommentary_IsEnabled() )
		SurvivalCommentary_ClearCurrentSpeakerPrefix()
}

void function RemoveItemFromQueue( QueueItem queueItem, array<QueueItem> queue )
{
	// Call this to tell the queue that you are done with the current item and it should move onto the next
	Signal( queueItem, "RemovedFromQueue" )
	if ( queue.contains( queueItem ) )
		queue.removebyvalue( queueItem )
}

void function PlayAnyClientSelfDialogueByName( entity self, string name )
{
	int aliasID = GetAnyAliasIdForName( name )
	if ( aliasID < 0 )
	{
		Warning( "Dialogue line " + name + " is not registered" )
		return
	}

	int dialogueFlags = 0
	PlayClientDialogue_Internal( aliasID, dialogueFlags, [self], <0, 0, 0> )
}


void function PlayClientDialogueOnEntity( int aliasID, int dialogueFlags, entity ent, int customQueueIdx = -1, int selector = -1 )
{
	PlayClientDialogue_Internal( aliasID, dialogueFlags, [ent], <0, 0, 0>, customQueueIdx, selector )
}


void function PlayClientDialogueOnSpeakers( int aliasID, int dialogueFlags, array<entity> speakers, int customQueueIdx = -1 )
{
	PlayClientDialogue_Internal( aliasID, dialogueFlags, speakers, <0, 0, 0>, customQueueIdx )
}


void function PlayClientDialogueOnPos( int aliasID, int dialogueFlags, vector pos, int customQueueIdx = -1 )
{
	PlayClientDialogue_Internal( aliasID, dialogueFlags, [null], pos, customQueueIdx )
}


void function PlayClientDialogueInCustomQueue1WithMainQueuedResponse( int aliasID, int responseID, int dialogueFlags, array<entity> speakers, entity responseSpeaker, float x, float y, float z )
{
	DialogueData leadingLineData  = GetDataForAliasId( aliasID )
	DialogueData responseLineData = GetDataForAliasId( responseID )

	string leadingMilesAlias  = leadingLineData.alias
	string responseMilesAlias = responseLineData.alias

	waitthread PlayClientDialogueOnSpeakers( aliasID, dialogueFlags, speakers )

	if ( IsValid( responseSpeaker ) )
		thread PlayClientDialogueOnEntity( responseID, dialogueFlags & ~eDialogueFlags.USE_CUSTOM_QUEUE1, responseSpeaker )
}


string function SpecifyAliasFromGeneric( DialogueData data, string alias, entity speaker )
{
	string milesAlias = alias

	string specifiedPerspective
	string extraPerspective = data.perspective

	specifiedPerspective = (speaker == GetLocalViewPlayer()) ? "1p" : "3p"

	if ( extraPerspective == "solo" && GetPlayerArrayOfTeam_Alive( speaker.GetTeam() ).len() == 1 )
	{
		specifiedPerspective = extraPerspective
	}

	if ( milesAlias.find( "%perspective%" ) >= 0 )
	{
		// #if DEVELOPER
			// Assert( specifiedPerspective != "", "Dialogue with generic perspective specified in CSV alias without specifying intended perspective!" )
		// #endif // DEVELOPER

		milesAlias = StringReplace( milesAlias, "%perspective%", specifiedPerspective )
	}

	string aliasWithGenericVoice = milesAlias

	string voice = GetPlayerVoice( speaker )
	if ( milesAlias.find( "%voice%" ) >= 0 )
		milesAlias = StringReplace( milesAlias, "%voice%", voice )

	// #if DEVELOPER
		// if ( ShouldTryToReplaceMissingVoiceWithTempVoice() )
		// {
			// if ( !DoesAliasExist( milesAlias ) )
			// {
				// if ( aliasWithGenericVoice.find( "%voice%" ) >= 0 )
				// {
					// milesAlias = StringReplace( aliasWithGenericVoice, "%voice%", TEMP_VOICE )

					// if ( !DoesAliasExist( milesAlias ) )
						// Warning( "Attempted to fall back to temp voice \"" + TEMP_VOICE + "\", but resulting alias \"" + milesAlias + "\" does not exist in miles." )
				// }
				// else
				// {
					// Warning( "Alias \"" + aliasWithGenericVoice + "\" does not exist, and since there is no generic voice field, we can't fall back to \"" + TEMP_VOICE + "\"." )
				// }
			// }
		// }
	// #endif // DEVELOPER

	if ( specifiedPerspective == "solo" && !DoesAliasExist( milesAlias ) )
	{
		//if a line per spective is listed as solo, but we can't find it and we did not receive a warning in registration - we know it is solo_flav
		//if it is solo_flav, but missing, we will fallback to their 1p lines, since we would have done that if canPlayIfSolo was true and they did not have solo lines anyway
		milesAlias = StringReplace( milesAlias, "solo", "1p" )
	}

	return milesAlias
}


string function SpecifyRadioDialoguePerspective( DialogueData data )
{
	string milesAlias = data.alias
	if ( data.perspective != "radio" )
		return data.alias

	string radioAlias = StringReplace( milesAlias, "%perspective%", data.perspective )

	//
	if ( !DoesAliasExist( radioAlias ) )
		return StringReplace( milesAlias, "%perspective%", "3p" )

	return radioAlias
}


void function SCB_AbortCurrentDialogue()
{
	AbortCurrentDialogue()
}


void function SCB_AbortAllMainQueuedAndCurrentDialogue()
{
	AbortAllQueuedAndCurrentDialogue( file.allQueues[ QUEUE_MAIN ] )
}

void function SCB_AbortAllCustomSpeakersQueuedAndCurrentDialogue( int queueIdx )
{
	AbortAllQueuedAndCurrentDialogue( file.allQueues[ queueIdx ] )
}

void function AbortCurrentDialogue()
{
	if ( file.currentDialoguePlayingHandle != null )
	{
		// if ( file.currentDialoguePlayingName != "" )
		// {
			// foreach ( void functionref( string abortedDialogueLine ) cb in file.abortDialogueCallbacks )
				// cb( file.currentDialoguePlayingName )
		// }

		StopSound( file.currentDialoguePlayingHandle )
		Signal( GetLocalClientPlayer(), "AbortCurrentDialogue" )
	}
	else if ( file.currentDialoguePlayingHandles.len() > 0 )
	{
		foreach ( handle in file.currentDialoguePlayingHandles )
		{
			StopSound( handle )
		}
		Signal( GetLocalClientPlayer(), "AbortCurrentDialogue" )
	}
}


void function AbortAllQueuedAndCurrentDialogue( QueueData queueData )
{
	array<QueueItem> queueItems = clone(queueData.queue)

	foreach ( QueueItem qItem in queueItems )
		RemoveItemFromQueue( qItem, queueData.queue )

	AbortCurrentDialogue()
}


void function ClientScriptInitForPlayer( entity player )
{
	//
	player.ClientCommand( "AllDialogueFinished" )
}


void function DevDialogueWithoutSoundAlias( string speaker, string text, float duration )
{
	if ( IsValid( file.devTextDialogueRUI ) )
		RuiDestroyIfAlive( file.devTextDialogueRUI )
	file.devTextDialogueRUI = RuiCreate( $"ui/id_dev_text.rpak", clGlobal.topoFullScreen, RUI_DRAW_HUD, 0 )
	RuiSetFloat( file.devTextDialogueRUI, "startTime", Time() )
	RuiSetString( file.devTextDialogueRUI, "speaker", speaker )
	RuiSetString( file.devTextDialogueRUI, "text", text )
	RuiSetFloat( file.devTextDialogueRUI, "duration", duration )
	RuiSetResolutionToScreenSize( file.devTextDialogueRUI )
}


void function SetUseDialogueVDU( bool useVDU )
{
	file.useVDU = useVDU
}
#endif //


#if DEVELOPER
bool function ShouldTryToReplaceMissingVoiceWithTempVoice()
{
	return (GetCurrentPlaylistVarInt( "vo_fallback_to_temp", 0 ) == 1)
}
#endif //


int function GetLinePriorityForAliasId( int aliasId )
{
	DialogueData data = GetDataForAliasId( aliasId )
	return data.priority
}


bool function ShouldPlayDialogueIfSolo( DialogueData data, entity speaker )
{
	if ( data.canPlayIfSolo || AllowPlayersToTalkToThemselves() )
		return true

	if ( !IsValid( speaker ) ) //
		return true

	if ( !speaker.IsPlayer() )
		return true

	return GetPlayerArrayOfTeam_Alive( speaker.GetTeam() ).len() > 1
}

#if SERVER
int function GetNextAliasIdForName( string dialogueName )
{
	if ( !(dialogueName in file.nameToGroupMap) )
		return -1

	DialogueEntryGroup group = file.nameToGroupMap[dialogueName]

	int aliasCount = group.aliasIds.len()
	if ( Shuffle_GetCount( group.shuffleData ) != aliasCount )
		Shuffle_Init( group.shuffleData, aliasCount )

	int index = Shuffle_GetNextIndex( group.shuffleData )
	return group.aliasIds[index]
}
#endif // SERVER


#if CLIENT
// You need to know the queue as the client. Request a queue on server, send that info to your client.
//void function RegisterCustomDialogueQueueSpeakerEntities( int queueIdx, array<entity> customSpeakers )
void function RegisterCustomDialogueQueueSpeakerEntities( int queueIdx, array<entity> customSpeakers )
{
	Assert( queueIdx < NUM_CUSTOM_QUEUES, "Tried to register entities for custom speaker with invalid queueIdx!" )
	foreach ( entity speaker in customSpeakers )
	{
		RegisterSpeaker_Internal( speaker, queueIdx )
	}
}
#endif

#if CLIENT
EnvironmentSpeaker function RegisterEnvironmentSpeaker( entity speakerEnt )
{
	return RegisterSpeaker_Internal( speakerEnt, QUEUE_MAIN )
}
#endif

#if CLIENT
EnvironmentSpeaker function RegisterSpeaker_Internal( entity speakerEnt, int queue )
{
	EnvironmentSpeaker speaker
	speaker.origin = speakerEnt.GetOrigin()
	speaker.speakerEnt = speakerEnt

	file.allSpeakersList[ queue ].append( speaker )
	return speaker
}
#endif

#if CLIENT
void function DeregisterEnvironmentSpeaker( EnvironmentSpeaker speaker )
{
	file.allSpeakersList[ QUEUE_MAIN ].fastremovebyvalue( speaker )
}
#endif