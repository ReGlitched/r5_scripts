untyped

globalize_all_functions

//********************************************************************************************
//	Base Gametype
//********************************************************************************************
const DEATH_CHAT_DELAY = 0.3

//For performance, flinch is negated based on gamemode bitmask.
//To add:  | ( 1 << playlistenum )
const NON_FLINCH_MODES_BITMASK = ( 1 << ePlaylists.fs_lgduels_1v1 ) | ( 1 << ePlaylists.fs_1v1 )
const NON_FLINCH_DAMAGE_BITMASK = 1 << eDamageSourceId.deathField

global struct EliminatedPlayerData
{
	string name
	int team
}

table< string, EliminatedPlayerData > EliminatedPlayers = {}

global struct OutOfBoundsDataStruct //Have to globalize it because all functions are globalized in this file :/
{
	int outOfBoundsTriggersTouched = 0
	float timeBackInBound = 0
	float timeLeftBeforeDyingFromOutOfBounds = OUT_OF_BOUNDS_TIME_LIMIT
}

struct
{
	PilotLoadoutDef& playbackBotLoadout
	array<entity> outOfBoundsTriggers = []
	array<entity> allTriggers = []
	array<entity> hurtTriggers = []
	bool functionref( entity, entity, var ) isProtectedFromFriendlyFire
	table< entity, OutOfBoundsDataStruct > outOfBoundsTable
	bool flowstate_allow_friendly_damage
} file

function BaseGametype_Init()
{
	file.flowstate_allow_friendly_damage = GetCurrentPlaylistVarBool( "flowstate_allow_friendly_damage", false )
	
	FlagInit( "APlayerHasSpawned" )
	FlagInit( "PilotBot" )

	if ( !reloadingScripts )
	{
		level.gameTypeText <- null
		level.classTypeText <- null

		level.titanAlwaysAvailableForTeam <- [ 0, 0, 0, 0 ]

		level.missingPlayersTimeout <- null

		CreateTeamColorControlPoints()

 		AddClientCommandCallback( "CC_SelectRespawn", ClientCommand_SelectRespawn )
 		AddClientCommandCallback( "CC_RespawnPlayer", ClientCommand_RespawnPlayer )

		AddCallback_NPCLeeched( OnNPCLeeched )

		//MarkTeamsAsBalanced_Off()
	}

	if ( IsSingleplayer() )
	{
		file.isProtectedFromFriendlyFire = IsProtectedFromFriendlyFire_SP
	}
	else
	{
		file.isProtectedFromFriendlyFire = IsProtectedFromFriendlyFire_MP
	}

	RegisterSignal( "OnDamageNotify" )
	RegisterSignal( "OnRespawned" )
	RegisterSignal( "ChoseToSpawnAsTitan" )
	RegisterSignal( "OutOfBounds" )
	RegisterSignal( "BackInBounds" )
	RegisterSignal( "PlayerKilled" )
	RegisterSignal( "RespawnMe" )
	RegisterSignal( "SimulateGameScore" )
	RegisterSignal( "ObserverThread" )
	RegisterSignal( "CE_FLAGS_CHANGED" )

	RegisterSignal( "Stop_OnStartTouch_EntityOutOfBounds" )
	RegisterSignal( "Stop_OnEndTouch_EntityBackInBounds" )

	RegisterSignal( "OnRespawnSelect" )
	RegisterSignal( "StopPostDeathLogic" )
	RegisterSignal( "HaltPlayerCharacterThread" )

	AddCallback_EntitiesDidLoad( BaseGametypeEntitiesDidLoad )

	BaseGametype_Init_MPSP()
	
	//AddCallback_OnTitanBecomesPilot( OnTitanBecomesPilot_OutOfBoundsCheck ) //disabled for r5r
}

void function BaseGametypeEntitiesDidLoad()
{
	Flowstate_CheckForMapTriggers()

	TriggerHurtSetup()
	OutOfBoundsSetup()
}

void function Flowstate_CheckForMapTriggers()
{
	file.allTriggers.extend( GetEntArrayByClass_Expensive( "trigger_out_of_bounds" ) )
	file.allTriggers.extend( GetEntArrayByClass_Expensive( "trigger_hurt" ) )
	file.allTriggers.extend( GetEntArrayByClass_Expensive( "trigger_slip" ) )
	file.allTriggers.extend( GetEntArrayByClass_Expensive( "trigger_no_zipline" ) )
	file.allTriggers.extend( GetEntArrayByScriptName( "WallTrigger_Killzone" ) )
	file.allTriggers.extend( GetEntArrayByScriptName( "WallTrigger_oob_timer" ) )

	if( Flowstate_DisableAllMapTriggers() || MapName() == eMaps.mp_rr_arena_skygarden && Gamemode() == eGamemodes.fs_dm )
	{
		int i = 0
		foreach( trigger in file.allTriggers )
			if( IsValid( trigger ) )
			{
				trigger.Destroy()
				i++
			}
		
		file.allTriggers.clear()
			
		printt( "[FS All Triggers Disabled] Removed", i, "map triggers" )
	}
}

function CreateTeamColorControlPoints()
{
	Assert( !( "fx_CP_color_enemy" in level ) )
	Assert( !( "fx_CP_color_friendly" in level ) )

	entity enemy = CreateEntity( "info_placement_helper" )
	SetTargetName( enemy, UniqueString( "teamColorControlPoint_enemy" ) )
	enemy.kv.start_active = 1
	DispatchSpawn( enemy )

	enemy.SetOrigin( ENEMY_COLOR_FX )
	svGlobal.fx_CP_color_enemy = enemy

	entity friendly = CreateEntity( "info_placement_helper" )
	SetTargetName( friendly, UniqueString( "teamColorControlPoint_friendly" ) )
	friendly.kv.start_active = 1
	DispatchSpawn( friendly )

	friendly.SetOrigin( FRIENDLY_COLOR_FX )
	svGlobal.fx_CP_color_friendly = friendly

	entity neutral = CreateEntity( "info_placement_helper" )
	SetTargetName( neutral, UniqueString( "teamColorControlPoint_neutral" ) )
	neutral.kv.start_active = 1
	DispatchSpawn( neutral )

	neutral.SetOrigin( NEUTRAL_COLOR_FX )
	svGlobal.fx_CP_color_neutral = neutral
}

const SOLDIER_SOUND_PAIN = "npc_grunt_pain"

void function CodeCallback_OnPrecache()
{
	if ( IsLobby() )
		return

 	Assert( IsSingleplayer() || GAMETYPE in GAMETYPE_TEXT )

	PrecacheModel( $"mdl/error.rmdl" ) // model used when no model is provided

	if ( IsLobby() )
		return

	PrecacheModel( $"mdl/dev/editor_ref.rmdl" )
	PrecacheModel( $"mdl/dev/empty_model.rmdl" )

	if ( !IsMenuLevel() )
	{
		SetGameState( eGameState.WaitingForPlayers )
	}

	level.ui.disableDev = IsMatchmakingServer()
}

function AddFlinch( entity attackedEnt, damageInfo )
{
	if( NON_FLINCH_MODES_BITMASK & ( 1 << Playlist() ) || NON_FLINCH_DAMAGE_BITMASK & ( 1 << DamageInfo_GetDamageSourceIdentifier( damageInfo ) ) )
	{
		DamageInfo_SetFlinchDirection( damageInfo, FLINCH_DIRECTION_NO_FLINCH )
		return
	}

	Assert( IsValid_ThisFrame( attackedEnt ), "attackedEnt not valid this frame" )

	//(mk): next flinch time block was commented , uncommented
	if ( !( "nextFlinchTime" in attackedEnt.s ) )
		attackedEnt.s.nextFlinchTime <- 0
	if ( Time() < attackedEnt.s.nextFlinchTime )
		return
	attackedEnt.s.nextFlinchTime = Time() + RandomFloatRange( 2.0, 4.0 )

	vector damageAngles = VectorToAngles( DamageInfo_GetDamageForce( damageInfo ) )
	vector entAngles = attackedEnt.EyeAngles()

	float damageYaw = (damageAngles.y + 180) - entAngles.y

	damageYaw = AngleNormalize( damageYaw )

	if ( damageYaw < 0 )
		damageYaw += 360

	if ( damageYaw < 45 )
		DamageInfo_SetFlinchDirection( damageInfo, FLINCH_DIRECTION_BACKWARDS );
	else if ( damageYaw < 135 )
		DamageInfo_SetFlinchDirection( damageInfo, FLINCH_DIRECTION_RIGHT );
	else if ( damageYaw < 225 )
		DamageInfo_SetFlinchDirection( damageInfo, FLINCH_DIRECTION_FORWARDS );
	else if ( damageYaw < 315 )
		DamageInfo_SetFlinchDirection( damageInfo, FLINCH_DIRECTION_LEFT );
	else
		DamageInfo_SetFlinchDirection( damageInfo, FLINCH_DIRECTION_BACKWARDS );
}


bool function IsProtectedFromFriendlyFire_MP( entity attacker, entity ent, var damageInfo )
{
	// no suicide protection
	if ( attacker == ent )
		return false

	if( file.flowstate_allow_friendly_damage )
		return false
	
	if ( DamageIgnoresFriendlyFire( damageInfo ) )
		return false

	if ( attacker.GetTeam() == ent.GetTeam() && !IsTeamRabid( attacker.GetTeam() ) )
		return true

	//if ( ent.GetOwner() != attacker && ent.GetBossPlayer() != attacker )
	//	return true

	if ( ent.e.noOwnerFriendlyFire == true )
		return true

	if ( ent.IsNPC() && ent.ai.preventOwnerDamage )
		return true

	return false
}

bool function IsProtectedFromNPCFire( entity attacker, entity ent )
{
	if ( attacker == ent )
		return false
	if ( attacker.IsNPC() && ent.IsNPC() && ent.ai.invulnerableToNPC == true )
		return true
	return false
}


bool function IsProtectedFromFriendlyFire_SP( entity attacker, entity ent, var damageInfo )
{
	// no suicide protection
	if ( attacker == ent )
		return false

	if ( attacker.GetTeam() == ent.GetTeam() )
	{
		if ( attacker.IsNPC() )
		{
			// dont titanfall me!
			if ( ent.IsPlayer() )
				return true

			// bullets dont damage same team of npcs
			if ( DamageInfo_GetCustomDamageType( damageInfo ) & DF_BULLET )
				return true
		}
		else if ( attacker.IsPlayer() )
		{
			if ( ent.IsNPC() )
			{
				if ( ent.IsTitan() )
					return true

				return !ent.AISetting_ShootableByFriendlyPlayer()
			}
			if ( ent.IsProjectile() )
				return false
			return true
		}

		if ( DamageIgnoresFriendlyFire( damageInfo ) )
			return false

		if ( ent.IsNPC() && ent.ai.preventOwnerDamage )
		{
			if ( attacker == ent.GetOwner() || attacker == ent.GetBossPlayer() )
				return true
		}
	}

	return false
}

bool function DamageIgnoresFriendlyFire( damageInfo )
{
	if ( DamageInfo_GetCustomDamageType( damageInfo ) & DF_DOOMED_HEALTH_LOSS )
		return true

	int damageSourceID = DamageInfo_GetDamageSourceIdentifier( damageInfo )

	switch ( damageSourceID )
	{
		case eDamageSourceId.damagedef_creeping_bombardment_detcord_explosion:
		case eDamageSourceId.damagedef_defensive_bombardment:
			return true
		// case eDamageSourceId.suicideSpectreAoE:
		// case eDamageSourceId.mp_titanweapon_stun_laser: // for energy transfer functionality. Preventing FF damage in the callback.
		// case eDamageSourceId.mp_titanability_smoke: // For FD Vanguard Shield Upgrades. Preventing FF damage in the callback.
		default:
			return false
	}

	return false
}

bool function ScriptCallback_ShouldEntTakeDamage( entity ent, damageInfo )
{
	if ( ent.IsInvulnerable() )
		return false

	entity attacker = DamageInfo_GetAttacker( damageInfo )
	entity inflictor = DamageInfo_GetInflictor( damageInfo )
	bool entIsPlayer = ent.IsPlayer()

	if ( !attacker )
		return false

	int damageType = DamageInfo_GetCustomDamageType( damageInfo )

	if ( attacker == ent || IsValid( inflictor ) && inflictor == ent )
	{
		if ( (damageType & DF_NO_SELF_DAMAGE) > 0  )
			return false
	}

	if ( file.isProtectedFromFriendlyFire( attacker, ent, damageInfo ) )
		return false

	if ( IsProtectedFromNPCFire( attacker, ent ) )
		return false

	// if ( !ShouldEntTakeDamage_SPMP( ent, damageInfo ) )
	// 	return false

	if ( (inflictor != null) )
	{
		if ( inflictor.IsProjectile() )
		{
			entity attacker0 = DamageInfo_GetAttacker( damageInfo )
			if ( attacker0 == ent )
			{
				bool shouldDamageOwner = inflictor.GetProjectileWeaponSettingBool( eWeaponVar.explosion_damages_owner )
				if ( !shouldDamageOwner )
					return false

				if ( entIsPlayer )
				{
					array<string> mods = inflictor.ProjectileGetMods()
					foreach ( mod in mods )
					{
						if ( mod == "jump_kit" )
						{
							float damageAmount = DamageInfo_GetDamage( damageInfo )
							damageAmount *= 0.75
							DamageInfo_SetDamage( damageInfo, damageAmount )
						//	DamageInfo_SetDamageForce( damageInfo, DamageInfo_GetDamageForce( damageInfo ) * 2.0 )
						}
					}
				}
			}
		}

		if ( inflictor.e.onlyDamageEntitiesOnce == true && inflictor.e.damagedEntities.contains( ent ) )
			return false

		if ( inflictor.e.onlyDamageEntitiesOncePerTick == true )
		{
			float currentTime = Time()
			if ( currentTime != inflictor.e.lastDamageTickTime )
			{
				inflictor.e.damagedEntities.clear()
				inflictor.e.lastDamageTickTime = currentTime
			}
			else if ( inflictor.e.damagedEntities.contains( ent ) )
			{
				return false
			}
		}
	}

	if ( ent.IsPlayer() )
	{
		return ShouldPlayerTakeDamage( ent, damageInfo )
	}

	return true
}

bool function ShouldPlayerTakeDamage( entity player, damageInfo )
{
	if ( player.IsGodMode() )
		return false

	if ( player.IsPhaseShifted()
		&& !(DamageInfo_GetCustomDamageType( damageInfo ) & DF_DOOMED_HEALTH_LOSS)
		&& !IsDamageFromDamageTrigger( damageInfo ) )
		return false

	// if ( player.IsInvulnerable() ) // this is checked in calling func
		// return false

	return true
}


void function HandlePainSounds( entity ent, var damageInfo )
{
	if( Playlist() == ePlaylists.fs_lgduels_1v1 )
		return

	//exit if the thing is dead
	if ( ent.GetHealth() < DamageInfo_GetDamage( damageInfo ) )
		return

	PlayPainSounds( ent, damageInfo )
}

float function GetHeadshotDamageMultiplierFromDamageInfo( var damageInfo )
{
	entity inflictor = DamageInfo_GetInflictor( damageInfo )
	if ( IsValid( inflictor ) && inflictor.IsProjectile() )
	{
		float result = inflictor.GetProjectileWeaponSettingFloat( eWeaponVar.damage_headshot_scale )
		return result
	}

	entity weapon = DamageInfo_GetWeapon( damageInfo )
	if ( weapon )
	{
		float result = weapon.GetWeaponSettingFloat( eWeaponVar.damage_headshot_scale )
		return result
	}

	return 1.0
}

float function GetLegDamageMultiplierFromDamageInfo( var damageInfo )
{
	entity inflictor = DamageInfo_GetInflictor( damageInfo )
	if ( IsValid( inflictor ) && inflictor.IsProjectile() )
		return inflictor.GetProjectileWeaponSettingFloat( eWeaponVar.damage_leg_scale )

	entity weapon = DamageInfo_GetWeapon( damageInfo )
	if ( IsValid( weapon ) )
		return weapon.GetWeaponSettingFloat( eWeaponVar.damage_leg_scale )

	return 1.0
}

const DMG_LOCATION_DEBUG = false

function HandleLocationBasedDamage( entity ent, var damageInfo )
{
	// Don't allow non-players to get headshots or any other location bonuses
	entity attacker = DamageInfo_GetAttacker( damageInfo )
	if ( !IsValid( attacker ) || !attacker.IsPlayer() )
		return
		
	int hitGroup = DamageInfo_GetHitGroup( damageInfo )

	#if DMG_LOCATION_DEBUG
		printt( "---------------------" )
		printt( "LOCATION BASED DAMAGE" )
		printt( "HIDGROUP ID:", hitGroup )
		if ( hitGroup == HITGROUP_GENERIC )
			printt( "HITGROUP: HITGROUP_GENERIC" )
		else if ( hitGroup == HITGROUP_HEAD )
			printt( "HITGROUP: HITGROUP_HEAD" )
		else if ( hitGroup == HITGROUP_CHEST )
			printt( "HITGROUP: HITGROUP_CHEST" )
		else if ( hitGroup == HITGROUP_STOMACH )
			printt( "HITGROUP: HITGROUP_STOMACH" )
		else if ( hitGroup == HITGROUP_LEFTARM )
			printt( "HITGROUP: HITGROUP_LEFTARM" )
		else if ( hitGroup == HITGROUP_RIGHTARM )
			printt( "HITGROUP: HITGROUP_RIGHTARM" )
		else if ( hitGroup == HITGROUP_LEFTLEG )
			printt( "HITGROUP: HITGROUP_LEFTLEG" )
		else if ( hitGroup == HITGROUP_RIGHTLEG )
			printt( "HITGROUP: HITGROUP_RIGHTLEG" )
		else if ( hitGroup == HITGROUP_GEAR )
			printt( "HITGROUP: HITGROUP_GEAR" )
		else
			printt( "HITGROUP: UNKNOWN" )
	#endif

	bool isValidHeadShot = IsValidHeadShot( damageInfo, ent )
	if ( isValidHeadShot )
		DamageInfo_AddCustomDamageType( damageInfo, DF_HEADSHOT )

	float damageMult_location = 1.0

	//(mk): removing the following code, as weaponName is not used, and we don't need 
	//spectre / stalker currently
	
	// var weaponName // TODO: If set to type string, will cause errors because weaponName can be ""
	// if ( DamageInfo_GetWeapon( damageInfo ) )
		// weaponName = DamageInfo_GetWeapon( damageInfo ).GetWeaponClassName()
	// else if ( DamageInfo_GetInflictor( damageInfo ) && (DamageInfo_GetInflictor( damageInfo ) instanceof CProjectile ) )
		// weaponName = DamageInfo_GetInflictor( damageInfo ).ProjectileGetWeaponClassName()

	/* 	
	if ( IsSuperSpectre( ent ) )
	{
		if ( CritWeaponInDamageInfo( damageInfo ) && IsCriticalHit( attacker, ent, DamageInfo_GetHitBox( damageInfo ), DamageInfo_GetDamage( damageInfo ), DamageInfo_GetDamageType( damageInfo ) ) )
		{
			damageMult_location = GetCriticalScaler( ent, damageInfo )
			DamageInfo_AddCustomDamageType( damageInfo, DF_CRITICAL )
		}
	}
	else if ( IsStalker( ent ) )
	{
		// note: stalker location based damage is done in _ai_stalker.gnut.
		switch ( hitGroup )
		{
			case HITGROUP_GEAR:
				DamageInfo_AddCustomDamageType( damageInfo, DF_CRITICAL )
				break
		}
	}
	else  
	*/
	if ( isValidHeadShot )
	{
		damageMult_location = GetHeadshotDamageMultiplierFromDamageInfo( damageInfo )
	}
	else if ( IsLegDamage( ent, damageInfo ) )
	{
		if ( ShouldTakeLegDamage( ent ) )
			damageMult_location = GetLegDamageMultiplierFromDamageInfo( damageInfo )
	}

	// modify damage value based on where we hit
	if ( damageMult_location != 1.0 )
	{
		#if DMG_LOCATION_DEBUG
			printt( "Multiplier:", damageMult_location )
			printt( "---------------------" )
		#endif

		DamageInfo_ScaleDamage( damageInfo, damageMult_location )
	}

	if ( isValidHeadShot )
	{
		RunClassHeadshotCallbacks( ent, damageInfo )
	}
}

bool function ShouldTakeLegDamage( entity ent )
{
	if ( !ent.IsPlayer() )
		return true

	if ( GetCurrentPlaylistVarBool( "low_profile_no_leg_damage", true ) && PlayerHasPassive( ent, ePassives.PAS_LOWPROFILE ) )
		return false

	return true
}

function PlayerDamageFeedback( entity ent, damageInfo, int shieldDamage = 0 )
{
	if( Playlist() == ePlaylists.fs_dm_fast_instagib )
		return

	entity attacker = DamageInfo_GetAttacker( damageInfo )
	Assert( IsValid( attacker ) )
	
	if ( attacker.IsNPC() )
	{
		Assert( CanNPCDoDamageOnBehalfOfPlayer(attacker) )

		entity playerOwner = attacker.GetBossPlayer()
		if ( IsValid( playerOwner ) )
		{
			attacker = playerOwner
		}
		else
		{
			//player might have DC'd (or died)
			return
		}
	}
	
	int customDamageType = DamageInfo_GetCustomDamageType( damageInfo )

	if ( IsMaxRangeShot( damageInfo ) )
		customDamageType = customDamageType | DF_MAX_RANGE
	
	if ( ent.GetHealth() - DamageInfo_GetDamage( damageInfo ) <= 0 )
	{
		if ( (!ent.IsNPC() || ent.ai.killShotSound) && ShouldDoKillFeedback( ent ) )
			customDamageType = customDamageType | DF_KILLSHOT
	}

	DamageInfo_SetDidDamage( damageInfo, shieldDamage )

	float damage = DamageInfo_GetDamage( damageInfo )

	if ( shieldDamage > 0 )
		attacker.NotifyDidDamage( ent, DamageInfo_GetHitBox( damageInfo ), DamageInfo_GetDamagePosition( damageInfo ), customDamageType, shieldDamage, DamageInfo_GetDamageFlags( damageInfo ), DamageInfo_GetHitGroup( damageInfo ), DamageInfo_GetWeapon( damageInfo ), DamageInfo_GetDistFromAttackOrigin( damageInfo ) )
	else if ( DamageInfo_GetDamage( damageInfo ) > 0 )
		attacker.NotifyDidDamage( ent, DamageInfo_GetHitBox( damageInfo ), DamageInfo_GetDamagePosition( damageInfo ), ClearBitFlag( customDamageType, DF_SHIELD_DAMAGE ), DamageInfo_GetDamage( damageInfo ), DamageInfo_GetDamageFlags( damageInfo ), DamageInfo_GetHitGroup( damageInfo ), DamageInfo_GetWeapon( damageInfo ), DamageInfo_GetDistFromAttackOrigin( damageInfo ) )
}

bool function ShouldDoKillFeedback( entity ent )
{
	if ( !ent.IsPlayer() )
		return true
	if ( ent.IsShadowForm() )// && !IsInForgedShadows( ent ) )
		return false
	return true
}
void function UpdateLastDamageTime( entity ent )
{
	if ( ent.IsPlayer() )
		ent.p.lastDamageTime = Time()
	
	if ( ent.IsNPC() )
		ent.ai.lastDamageTime = Time()
}

void function PlayerDealtTitanDamage( entity attacker, entity victim, float savedDamage, var damageInfo )
{
	if ( attacker != victim )
	{
		attacker.p.titanDamageDealt += savedDamage
	}
}

function UpdateAttackerInfo( entity ent, entity attacker, damage )
{
	entity attackerPlayer = GetPlayerFromEntity( attacker )
	if ( !attackerPlayer )
		return

	// cannot be your own last attacker
	if ( attackerPlayer == ent )
		return

	if ( damage <= 0 )
		return

	if ( !("attackerInfo" in ent.s) )
		ent.s.attackerInfo <- {}
	else if ( ent.GetHealth() == ent.GetMaxHealth() )
		ent.s.attackerInfo.clear()

	if ( !(attackerPlayer.weakref() in ent.s.attackerInfo ) )
		ent.s.attackerInfo[attackerPlayer.weakref()] <- 0

	ent.s.attackerInfo[attackerPlayer.weakref()] += damage

	ent.e.lastAttacker = attackerPlayer
}

entity function GetAttackerPlayerOrBossPlayer( entity attacker )
{
	if ( !IsValid( attacker ) )
		return null

	if ( attacker.IsPlayer() )
		return attacker

	entity bossPlayer = attacker.GetBossPlayer()
	if ( !IsValid( bossPlayer ) )
		return null

	return bossPlayer
}

entity function GetAttackerOrLastAttacker( entity ent, var damageInfo )
{
	entity attacker = DamageInfo_GetAttacker( damageInfo )
	if ( !ShouldGetLastAttacker( ent, attacker ) )
	{
		Assert( IsValid( attacker ) )
		return attacker
	}

	entity lastAttacker = GetLastAttacker( ent ) //Attacker doesn't work, get last attacker
	if ( IsValid( lastAttacker ) )
		return lastAttacker

	//last attacker doesn't work, get latestAssistingPlayerInfo
	AssistingPlayerStruct attackerInfo = GetLatestAssistingPlayerInfo( ent )
	if ( IsValid( attackerInfo.player ) )
		return attackerInfo.player

	if ( IsValid( attacker ) ) //No Last Attacker and No Lastest Assisting Player, e.g. when you suicide before taking damage. Just return the attacker if valid
		return attacker

	Assert( false, "" )
	return svGlobal.worldspawn
}

bool function ShouldGetLastAttacker( entity ent, entity attacker )
{
	if ( IsValid( attacker ) == false )
		return true

	if ( attacker == ent ) //suicide
		return true

	if ( attacker.IsPlayer() == false && attacker.IsNPC() == false ) //Environmental damage
		return true

	return false
}

function ClearLastAttacker( entity ent )
{
	ent.e.lastAttacker = null
}

entity function GetLastAttacker( entity ent )
{
	if ( ent.IsTitan() && IsValid( ent.GetTitanSoul() ) ) // JFS: second check is defensive
	{
		entity soul = ent.GetTitanSoul()
		if ( soul.lastAttackInfo && "attacker" in soul.lastAttackInfo && IsValid( soul.lastAttackInfo.attacker ) )
			return expect entity( soul.lastAttackInfo.attacker )
	}

	if ( !IsValid( ent.e.lastAttacker ) )
		return null

	return ent.e.lastAttacker
}

void function PlayerOrNPCKilled( entity ent, var damageInfo )
{
	bool gamePlayingOrSuddenDeath = GamePlayingOrSuddenDeath() // Storing this off here, the game state can change in the callbacks below which may cause kills to not count

	int damageSourceID = DamageInfo_GetDamageSourceIdentifier( damageInfo )

	if ( damageSourceID == eDamageSourceId.round_end )
		return

	entity attackerRaw = GetAttackerOrLastAttacker( ent, damageInfo )
	entity attacker    = attackerRaw
	Assert( IsValid( attacker ) )

	if ( ent.IsPlayer() )
	{
		LogPlayerMatchStat_Death( ent )

		if ( attacker.IsPlayer() && (attacker != ent) )
			LogPlayerMatchStat_KilledAPilot( attacker )
	}

	if ( !attacker.IsPlayer() )
	{
		entity newAttacker = GetPlayerFromEntity( attacker )
		if ( IsValid( newAttacker ) )
			attacker = newAttacker
	}

	if ( ent.IsPlayer() )
	{
		//Do callbacks. Main reason we call this here as opposed to CodeCallback_OnPlayerKilled() is legacy script compatibility reasons.
		//For example: In script immediately above this we change the attacker to get the player behind the kill, e.g. owner of a pet titan, etc. Bunch of registered callbacks depends on this.
		foreach ( callbackFunc in svGlobal.onPlayerKilledCallbacks )
			callbackFunc( ent, attacker, damageInfo )
	}
	else if ( ent.IsNPC() )
	{
		//Do callbacks. Main reason we call this here as opposed to CodeCallback_OnNPCKilled() is legacy script compatibility reasons.
		//For example: In script immediately above this we change the attacker to get the player behind the kill, e.g. owner of a pet titan, etc. Bunch of registered callbacks depends on this.
		foreach ( callbackFunc in svGlobal.onNPCKilledCallbacks )
			callbackFunc( ent, attacker, damageInfo )
	}

	if ( !attacker.IsPlayer() )
	{
		// This gets the last player that did damage to the entity so that we can give him the kill
		AssistingPlayerStruct attackerInfo = GetLatestAssistingPlayerInfo( ent )

		if ( IsValid( attackerInfo.player ) )
		{
			attacker = attackerInfo.player
			// Hack - attacker history isn't on client to calculate if a player should get credit for a kill when AI steals the final killing shot while a player is damaging them.
			array<entity> playerArray = GetPlayerArray()
			foreach ( player in playerArray )
				Remote_CallFunction_Replay( player, "ServerCallback_SetAssistInformation", attackerInfo.damageSourceId, attacker.GetEncodedEHandle(), ent.GetEncodedEHandle(), attackerInfo.assistTime )
		}
	}

	if ( attacker.IsPlayer() )
		DoPlayerScoreEventsForKill( attacker, ent, damageInfo, gamePlayingOrSuddenDeath )
	else if ( ent.IsPlayer() )
		ent.p.numberOfDeathsByWorld++ //still want to track total deaths regardless of whether killed by a player or not
}

int function GetTotalNumberOfDeaths( entity player )
{
	//total number of deaths at the hands of other players or world damage (falls, rings, etc)
	return ( player.p.numberOfDeathsByWorld + player.p.numberOfDeaths )
}

void function DoPlayerScoreEventsForKill( entity player, entity victim, var damageInfo, bool gamePlayingOrSuddenDeath )
{
	PreScoreEventUpdateStats( player, victim )
	if ( IsEnemyTeam( victim.GetTeam(), player.GetTeam() ) )
	{
		if ( victim.IsPlayer() )
			ScoreEvent_PlayerKilled( victim, player, damageInfo )
	}
	PostScoreEventUpdateStats( player, victim )

	if ( IsFriendlyTeam( victim.GetTeam(), player.GetTeam() ) )
		return

	if ( gamePlayingOrSuddenDeath )
	{
		if ( victim.IsPlayer() )
		{
			if ( victim.IsTitan() )
			{
				//if we killed a player in a titan count two kills (one for the pilot, one for the titan )
				player.AddToPlayerGameStat( PGS_KILLS, 2 )
				player.AddToPlayerGameStat( PGS_TITAN_KILLS, 1 )
				player.AddToPlayerGameStat( PGS_PILOT_KILLS, 1 )
			}
			else
			{
				player.AddToPlayerGameStat( PGS_KILLS, 1 )
				player.AddToPlayerGameStat( PGS_PILOT_KILLS, 1 )
			}
		}
		else
		{
			if ( victim.IsTitan() )
				player.AddToPlayerGameStat( PGS_TITAN_KILLS, 1 )

			if ( !IsMarvin( victim ) && !victim.IsTitan() )
				player.AddToPlayerGameStat( PGS_NPC_KILLS, 1 )
		}
	}
}

void function UpdateNextRespawnTime( entity player, float time )
{
	player.nv.nextRespawnTime = time
}


bool function ShouldSetObserverTarget( entity attacker )
{
	if ( !IsValid( attacker ) )
		return false

	if ( !GetCurrentPlaylistVarBool( "deathcam_enabled", false ) )
		return false

	if ( !IsAlive( attacker ) )
		return false

	if ( attacker.IsPlayer() && attacker.IsObserver() )
		return false

	return true
}

float function CalculateLengthOfKillReplay( float attackerTimeSinceSpawning )
{
	return GetKillReplayBeforeTime( attackerTimeSinceSpawning ) + GetKillReplayAfterTime()
}

float function CalculateReplayDelay( float currentTime, float timeOfDeath, float attackerTimeSinceSpawning )
{
	return GetKillReplayBeforeTime( attackerTimeSinceSpawning ) + ( Time() - timeOfDeath )
}

float function GetKillReplayBeforeTime( float attackerTimeSinceSpawning )
{
	float playlistTime
	if ( !GamePlayingOrSuddenDeath() )
	{
		playlistTime = GetCurrentPlaylistVarFloat( "killreplay_before_time_short", 3.5 )
	}
	else
	{
		playlistTime = GetCurrentPlaylistVarFloat( "killreplay_before_time", 3.5 )
	}

	return min( playlistTime, attackerTimeSinceSpawning )
}

float function GetKillReplayAfterTime()
{
	if ( !GamePlayingOrSuddenDeath() )
		return GetCurrentPlaylistVarFloat( "killreplay_after_time_short", 1.0 )

	return GetCurrentPlaylistVarFloat( "killreplay_after_time", 1.0 )
}

bool function ShouldDoReplay( entity player, entity attacker, float replayTime, int methodOfDeath )
{
	if ( !ShouldDoReplayForGameState() )
	{
		print( "ShouldDoReplay(): Not doing a replay because ShouldDoReplayForGameState returned false\n" )
		return false
	}
	
	if ( GetCurrentPlaylistVarInt( "replay_disabled", 1 ) == 1 )
	{
		print( "ShouldDoReplay(): Not doing a replay because 'replay_disabled' is enabled in the current playlist.\n" )
		return false
	}

	switch ( methodOfDeath )
	{
		case eDamageSourceId.human_execution:
		case eDamageSourceId.titan_execution:
		{
			print( "ShouldDoReplay(): Not doing a replay because the player died from an execution.\n" )
			return false
		}
	}

	if ( Time() - player.p.connectTime <= replayTime ) //Bad things happen if we try to do a kill replay that lasts longer than the player entity existing on the server
	{
		print( "ShouldDoReplay(): Not doing a replay because the player is not old enough.\n" )
		return false
	}

	if ( player == attacker )
	{
		print( "ShouldDoReplay(): Not doing a replay because the attacker is the player.\n" )
		return false
	}

	if ( player.IsBot() == true )
	{
		print( "ShouldDoReplay(): Not doing a replay because the player is a bot.\n" )
		return false
	}

	return AttackerShouldTriggerReplay( attacker )
}

bool function ShouldDoReplayForGameState()
{
	if ( !GamePlayingOrSuddenDeath() )
	{
		print( "ShouldDoReplayForGameState(): Not doing a replay because gamestate is invalid.\n" )
		return false
	}

	return true
}

// Don't let things like killbrushes show replays
bool function AttackerShouldTriggerReplay( entity attacker )
{
	if ( !IsValid( attacker ) )
	{
		print( "AttackerShouldTriggerReplay(): Not doing a replay because the attacker is not valid.\n" )
		return false
	}

	if ( attacker.IsPlayer() )
	{
		print( "AttackerShouldTriggerReplay(): Doing a replay because the attacker is a player.\n" )
		return true
	}

	if ( attacker.IsNPC() )
	{
		print( "AttackerShouldTriggerReplay(): Doing a replay because the attacker is an NPC.\n" )
		return true
	}

	print( "AttackerShouldTriggerReplay(): Not doing a replay by default.\n" )
	return false
}

function TrackDestroyTimeForReplay( entity attacker, table replayTracker )
{
	float startTime = Time()
	// tracks the time until the attacker becomes invalid
	EndSignal( replayTracker, "OnDestroy" )

	OnThreadEnd(
		function () : ( replayTracker, startTime )
		{
			replayTracker.validTime = Time() - startTime
		}
	)

	string signal = "OnDestroy"

	if ( IsAlive( attacker ) )
		attacker.WaitSignal( signal )
	else
		WaitSignalOnDeadEnt( attacker, signal )
}

bool function ClientCommand_SelectRespawn( entity player, array<string> args )
{
	if ( IsAlive( player ) )
		return true

	if ( args.len() == 0  )
		return true

	int index = args[ 0 ].tointeger()

	switch ( index )
	{
		case 1:
			player.SetPersistentVar( "spawnAsTitan", true )
			break
		case 2:
			player.SetPersistentVar( "spawnAsTitan", false )
			break
	}

	return true
}

bool function ClientCommand_RespawnPlayer( entity player, array<string>args )
{
	if ( IsSingleplayer() )
		return true

	if ( IsAlive( player ) )
		return true

	if ( args.len() != 1 )
		return true

	string opParm = args[ 0 ]

	if ( opParm.find( "burncard" ) != 0 )
	{
		//int burnCard = opParm.tointeger()
		//SetPlayerBurnCardSlotToActivate( player, burnCard )
		return true
	}
	else if ( opParm == "Titan" )
	{
		player.SetPersistentVar( "spawnAsTitan", true )
	}
	else if ( opParm == "Pilot" )
	{
		player.SetPersistentVar( "spawnAsTitan", false )
	}

	float deathCamLength = GetDeathCamLength()
	float skipBufferTime = 0.5
	if ( Time() > (player.p.postDeathThreadStartTime + deathCamLength) - skipBufferTime )
	{
		player.s.respawnSelectionDone = true
		player.Signal( "RespawnMe" )
	}

	return true
}

// If the attacker in damageinfo is an NPC that is owned by a player, for replay we consider the attacker to be that player and the inflictor to be their owned NPC
entity function GetAttackerForKillreplayFromDamageInfo( entity damageInfoAttacker )
{
	if ( damageInfoAttacker.IsNPC() && IsValidPlayer( damageInfoAttacker.GetBossPlayer() ) )
	{
		return damageInfoAttacker.GetBossPlayer()
	}

	return damageInfoAttacker
}

// if the inflictor is a projectile shot by an NPC owned by a player, use the NPC as the inflictor
entity function GetInflictorForKillreplayFromDamageInfo( entity damageInfoAttacker, entity damageInfoInflictor )
{
	if ( damageInfoAttacker.IsNPC() && IsValidPlayer( damageInfoAttacker.GetBossPlayer() ) && damageInfoInflictor.IsProjectile() && damageInfoInflictor.GetOwner() == damageInfoAttacker )
	{
		return damageInfoAttacker
	}

	return damageInfoInflictor
}
		
function AIChatter( string alias, int team, vector origin )
{
	array<entity> ai = GetNearbyFriendlyGrunts( origin, team )

	if ( ai.len() > 0 )
	{
		PlaySquadConversationToAll( alias, ai[0] )
	}
}

const MAX_ACTIVITY_DISABLED = 0
const MAX_ACTIVITY_PILOTS = 1
const MAX_ACTIVITY_TITANS = 2
const MAX_ACTIVITY_PILOTS_AND_TITANS = 3
const MAX_ACTIVITY_CONGER_MODE = 4

bool function GetPilotBotFlag()
{
	// IMPORTANT: Please call this consistently instead of Flag( "PilotBot" )
	// Force titan or pilot bots according to max activity mode if it is enabled.
	// Otherwise, leave the "pilotBot" flag alone and do what the game mode wants.
	int max_activity_mode = GetConVarInt( "max_activity_mode" )
	if ( max_activity_mode == MAX_ACTIVITY_PILOTS || max_activity_mode == MAX_ACTIVITY_PILOTS_AND_TITANS )
		return true
	else if ( max_activity_mode == MAX_ACTIVITY_TITANS )
		return false
	else if ( max_activity_mode == MAX_ACTIVITY_CONGER_MODE )
		return rand() % 2 != 0    // conger mode: 50/50 pilot and titan bots!
	else
		return Flag( "PilotBot" )

	unreachable
}

function DoRespawnPlayer( entity player, entity spawnPoint )
{
	if( IsAlive( player ) )
		return

	player.p.lastSpawnPoint = spawnPoint
	player.RespawnPlayer( spawnPoint ) //(mk): This will send "OnRespawned" signal, killing the thread if started from PostDeathThread // Also sends OnRespawnPlayer first
}

function SetupPilotSpawnOnRematch( entity player )
{
	// clear respawn countdown message
	if ( GetWaveSpawnType() == eWaveSpawnType.DROPSHIP )
		MessageToPlayer( player, eEventNotifications.Clear )

	player.SetOrigin( player.p.rematchOrigin )

	if ( GetWaveSpawnType() == eWaveSpawnType.DISABLED )
		wait 0.9

	if ( IsAlive( player ) )//HACK: This seems terrible, we shouldn't have to do this
	{
		printt( "This happened one time, in retail." )
		return
	}

	if ( ShouldGivePlayerInfoOnSpawn() )
		thread GivePlayerInfoOnSpawn( player )

	return
}

bool function ShouldGivePlayerInfoOnSpawn()
{
	return GetCurrentPlaylistVarInt( "minimap_sonar_pulse_on_respawn", 0 ) > 0
}

function GivePlayerInfoOnSpawn( entity player )
{
	player.EndSignal( "OnDeath" )

	//PrintFunc()

	while( player.IsWatchingKillReplay() )
		WaitFrame()

	//printt( " GivePlayerInfoOnSpawn Player isn't watching kill replay anymore!" )

	wait 0.2 //Hack: Have to wait even though player should not be watching kill replay anymore...

	//This needed a wait, probably because at this time we haven't given them loadouts yet, so when we do give them loadouts it strips out the passive?
	//thread ScanMinimap( player, true, 0.5 ) //x second minimap pulse
}

bool function ShouldStartSpawn( entity player )
{
	// if ( Riff_FloorIsLava() )
	// 	return false

	if ( Flag( "ForceStartSpawn" ) )
		return true

	if ( Flag( "IgnoreStartSpawn" ) )
		return false

	if ( GetGameState() <= eGameState.Prematch )
		return true

	if ( player.s.respawnCount )
		return false

	return GameTime_PlayingTime() < START_SPAWN_GRACE_PERIOD
}

void function PlayerSpawnsIntoPetTitan( entity player )
{
	// player.EndSignal( "OnDestroy" )

	// entity titan = player.GetPetTitan()

	// vector origin = titan.GetOrigin() + Vector( 0, 0, 600 )
	// vector angles = titan.GetAngles()

	// entity camera = CreateTitanDropCamera( origin, Vector(90,angles.y,0) )
	// player.SetViewEntity( camera, false )

	// player.isSpawning = true // set this to prevent .isSpawning checks from returning false

	// angles.x = 70

	// player.SetOrigin( origin )
	// player.SnapEyeAngles( angles )
	// player.SetVelocity( Vector( 0.0, 0.0, 0.0 ) )

	// OnThreadEnd(
	// 	function() : ( player )
	// 	{
	// 		if ( IsValid( player ) )
	// 		{
	// 			player.ClearViewEntity()
	// 			player.ClearSpawnPoint()
	// 			player.isSpawning = null
	// 		}
	// 	}
	// )

	// wait 0.2

	// local criteria = {
	// 	embark = "above_close",
	// 	titanCanStandRequired = true
	// }

	// local embarkAction
	// embarkAction = FindEmbarkActionForCriteria( criteria )
	// if ( embarkAction == null )
	// 	embarkAction = GetRandomEmbarkAction()

	// if ( IsValid( camera ) )
	// {
	// 	// camera can be invalid for a moment when server shuts down
	// 	// camera.FireNow( "Disable", "!activator", null, player )
	// 	camera.Destroy()
	// }

	// DoRespawnPlayer( player, null )

	// if ( PlayerCanSpawnIntoTitan( player ) )
	// {
	// 	table action = expect table( GenerateEmbarkActionTable( player, titan, embarkAction ) )
	// 	PlayerEmbarksTitan( player, titan, action )
	// }
}

entity function CreateTitanDropCamera( origin, angles )
{
	entity viewControl = CreateEntity( "point_viewcontrol" )
	viewControl.kv.spawnflags = 56 // infinite hold time, snap to goal angles, make player non-solid

	viewControl.SetOrigin( origin )
	viewControl.SetAngles( angles )
	DispatchSpawn( viewControl )

	return viewControl
}

entity function CreateDropPodViewController( entity pod )
{
	entity viewControl = CreateEntity( "point_viewcontrol" )
	viewControl.kv.spawnflags = 56 // infinite hold time, snap to goal angles, make player non-solid

	viewControl.SetOrigin( pod.GetOrigin() + Vector( 44, -64, 520 ) )
	float yaw = pod.GetAngles().y
	viewControl.SetAngles( Vector( 90, yaw + 10, 0 ) )
	DispatchSpawn( viewControl )

	viewControl.SetParent( pod )

	return viewControl
}


function ClearEntInUseOnDestroy( dropPoint, dropPod )
{
	dropPod.WaitSignal( "OnDestroy" )
	dropPoint.e.spawnPointInUse = false
}

float function GetPlayerLastRespawnTime( entity player )
{
	return expect float( player.s.respawnTime )
}

entity function GetEmbarkPlayer( entity titan )
{
	if ( "embarkingPlayer" in titan.s )
		return expect entity( titan.s.embarkingPlayer )

	return null
}

entity function GetDisembarkPlayer( entity titan )
{
	if ( "disembarkingPlayer" in titan.s )
		return expect entity( titan.s.disembarkingPlayer )

	return null
}

entity function GetEmbarkDisembarkPlayer( entity titan )
{
	entity result = GetEmbarkPlayer( titan )

	if ( IsValid( result ) )
		return result

	result = GetDisembarkPlayer( titan )
	if ( IsValid( result ) )
		return result

	return null
}

void function CodeCallback_OnNPCKilled( entity npc, var damageInfo )
{
	if ( IsSingleplayer() )
	{
		OnNPCKilled_SP( npc, damageInfo )
		return
	}

	HandleDeathPackage( npc, damageInfo )

	if ( npc.IsTitan() )
	{
		// if a player is getting in, kill him too
		entity player = GetEmbarkPlayer( npc )
		if ( IsAlive( player ) )
		{
			// kill the embarking player
			//printt( "Killed embarking player" )
			KillFromInfo( player, damageInfo )
		}

		if ( !GetDoomedState( npc ) )
		{
			// Added via AddCallback_OnTitanDoomed
			foreach ( callbackFunc in svGlobal.onTitanDoomedCallbacks )
			{
				callbackFunc( npc, damageInfo )
			}
		}
	}

	PlayerOrNPCKilled( npc, damageInfo )
}

void function OnNPCKilled_SP( entity npc, var damageInfo )
{
	HandleDeathPackage( npc, damageInfo )

	if ( npc.IsTitan() )
	{
		// if a player is getting in, kill him too
		entity player = GetEmbarkPlayer( npc )
		if ( IsAlive( player ) )
		{
			// kill the embarking player
			//printt( "Killed embarking player" )
			KillFromInfo( player, damageInfo )
		}

		if ( !GetDoomedState( npc ) )
		{
			// Added via AddCallback_OnTitanDoomed
			foreach ( callbackFunc in svGlobal.onTitanDoomedCallbacks )
			{
				callbackFunc( npc, damageInfo )
			}
		}
	}

	entity attacker = GetAttackerOrLastAttacker( npc, damageInfo )
	if ( !IsValid( attacker ) )
		return

	if ( !attacker.IsPlayer() )
	{
		entity newAttacker = GetPlayerFromEntity( attacker )
		if ( IsValid( newAttacker ) )
			attacker = newAttacker
	}

	foreach( callbackFunc in svGlobal.onNPCKilledCallbacks )
	{
		callbackFunc( npc, attacker, damageInfo )
	}

	if ( npc.IsTitan() )
		thread TitanVO_DelayedTitanDown( npc )
}

void function CodeCallback_OnEntityDestroyed( entity ent )
{
	foreach ( callbackFunc in ent.e.onEntityDestroyedCallbacks ) //Cafe was here
	{
		callbackFunc( ent )
	}
}

function AddEntityDestroyedCallback( entity ent, void functionref( entity ) callbackFunc )
{
	if( !(ent.e.onEntityDestroyedCallbacks.contains( callbackFunc ) ) )
		ent.e.onEntityDestroyedCallbacks.append( callbackFunc )

	// set this or else the ent won't run CodeCallback_OnEntityDestroyed at all
	ent.SetDoDestroyCallback( true )
}

bool function WeaponInterruptsCloak( entity weapon )
{
	if ( !IsValid( weapon ) )
		return false

	return weapon.GetWeaponInfoFileKeyField( "does_not_interrupt_cloak" ) != 1
}

void function CodeCallback_WeaponFireInCloak( entity player, entity something )
{
	if ( !WeaponInterruptsCloak( player.GetActiveWeapon( eActiveInventorySlot.mainHand ) ) )
		return

	if ( player.IsTitan() )  // Fix timing issue with auto-eject cloak and firing your weapon as a Titan cancelling it.  This assumes we never want cloaked titans!
		return

	// if ( player.cloakedForever )
	// {
	// 	player.SetCloakFlicker( 1.0, 2.0 )
	// 	return
	// }

	// // Check if we are allowed some cloaked shots based on ability selection
	// if ( player.s.cloakedShotsAllowed > 0 )
	// {
	// 	player.s.cloakedShotsAllowed--
	// 	return
	// }

	if ( IsMultiplayer() )
	{
		//player.SetCloakFlicker( 1.0, 2.0 )

		DisableCloak( player, 0.5 )
		entity weapon = player.GetOffhandWeapon( OFFHAND_LEFT )
		//printt( "weapon", weapon.GetWeaponClassName() )
		// JFS; need code feature to properly reset next attack time/cooldown stuff
		if ( IsValid( weapon ) && weapon.GetWeaponClassName() == "mp_ability_cloak" )
		{
			player.TakeOffhandWeapon( OFFHAND_LEFT )
			player.GiveOffhandWeapon( "mp_ability_cloak", OFFHAND_LEFT )
			weapon = player.GetOffhandWeapon( OFFHAND_LEFT )
			weapon.SetWeaponPrimaryClipCountAbsolute( 0 )
		}
	}
	else
	{
		DisableCloak( player, 0.5 )
	}
}

// need "you will change class next time" message
function OnPlayerCloseClassMenu( entity player )
{
	if ( GetGameState() <= eGameState.Prematch )
		return

	if ( player.IsEntAlive() )
		return

	if ( player.s.inPostDeath )
		return

	if ( IsValid( player.isSpawning ) )
		return

	thread DecideRespawnPlayer( player )	// there is a wait that happens later when using rematch burncard in Frontier Defense.
}

//  playerconnected Reload
void function CodeCallback_OnClientReloadConnectionCompleted( entity player )
{
	FinishClientScriptInitialization( player )

	// Added via AddCallback_OnClientReloadConnected
	foreach ( callbackFunc in svGlobal.onClientReloadConnectedCallbacks )
	{
		callbackFunc( player )
	}
}


bool function ShouldPlayerHaveLossProtection( entity player )
{
	if ( level.nv.matchProgress < GetCurrentPlaylistVarInt( "matchLossProtectionThreshold", 10 ) )
		return false

	if ( IsPrivateMatch() )
		return false

	if ( IsFFAGame() )
		return true

	int team = player.GetTeam()
	int otherTeam = GetOtherTeam( team )
	int teamScore = IsRoundBased() ? GameRules_GetTeamScore2( team ) : GameRules_GetTeamScore( team )
	int otherTeamScore = IsRoundBased() ? GameRules_GetTeamScore2( otherTeam ) : GameRules_GetTeamScore( otherTeam )

	if ( teamScore < otherTeamScore )
		return true

	return false
}

// This server will recieve this command from the client once they have loaded/run all of their scripts
// Any client hud initialization should be done here
function FinishClientScriptInitialization( entity player )
{
	//printt( "Player client script initialization complete: " + player );

	player.p.clientScriptInitialized = true

	SyncServerVars( player )
	SyncEntityVars( player )
	SyncUIVars( player )

	Remote_CallFunction_Replay( player, "ServerCallback_ClientInitComplete" )
}

function NotifyClientsOfConnection( entity player, state )
{
	int playerEHandle = player.GetEncodedEHandle()
	array<entity> players = GetPlayerArray()
	foreach ( ent in players )
	{
		if ( ent != player )
			Remote_CallFunction_Replay( ent, "ServerCallback_PlayerConnectedOrDisconnected", playerEHandle, state )
	}
}

function NotifyClientsOfTeamChange( entity player, int oldTeam, int newTeam )
{
	int playerEHandle = player.GetEncodedEHandle()
	array<entity> players = GetPlayerArray()
	foreach ( ent in players )
	{
		//if ( ent != player )
		Remote_CallFunction_Replay( ent, "ServerCallback_PlayerChangedTeams", playerEHandle, oldTeam, newTeam )
	}
}


bool function IsValidNPCTarget( entity ent )
{
	switch ( ent.GetClassName() )
	{
		case "npc_marvin":
		case "npc_soldier":
		case "npc_spectre":
		case "npc_stalker":
		case "npc_super_spectre":
		case "npc_prowler":
		case "npc_drone":
		case "npc_titan":
		case "npc_turret_sentry":
		case "npc_turret_mega":
		case "npc_dropship":
			return true
	}

	return false
}

int function CodeCallback_GetWeaponDamageSourceId( entity weapon )
{
	string classname = weapon.GetWeaponClassName()

	#if DEVELOPER
		if ( ("devWeapons" in level) && classname in level.devWeapons )
			return 0

	#endif
	//Filter out abilities for now
	if ( !(classname in eDamageSourceId) )
		return damagedef_unknown

	//Assert( classname in getconsttable().eDamageSourceId, classname + " not added to eDamageSourceId enum" )
	int damageSourceInt = eDamageSourceId[ classname ]
	return damageSourceInt
}




function TriggerHurtSetup()
{
	file.hurtTriggers.extend( GetEntArrayByClass_Expensive( "trigger_hurt" ) )
	
	if( Flowstate_DisableAllMapTriggers() )
		return

	foreach( trigger in file.hurtTriggers )
	{
		trigger.ConnectOutput( "OnStartTouch", TriggerHurtEnter )
	}
}

void function TriggerHurtEnter( entity trigger, entity ent, entity caller, var value )
{
	if ( ent.e.destroyTriggerHurt )
		ent.Destroy()
}

#if MP
table< entity, table< entity, bool > > oob_triggerEntPairs

void function SetupOutOfBoundsTrigger( entity trigger )
{
	if ( !(trigger in oob_triggerEntPairs) )
		oob_triggerEntPairs[trigger] <- {}
}
#endif

function OutOfBoundsSetup()
{
	file.outOfBoundsTriggers.extend( GetEntArrayByClass_Expensive( "trigger_out_of_bounds" ) )

	if( Flowstate_DisableAllMapTriggers() )
		return

	foreach( trigger in file.outOfBoundsTriggers )
	{
		#if MP
			SetupOutOfBoundsTrigger( trigger )
			trigger.ConnectOutput( "OnStartTouch", EntityEnterOutOfBoundsTrig )
			trigger.ConnectOutput( "OnEndTouch", EntityLeaveOutOfBoundsTrig )
		#else
			trigger.ConnectOutput( "OnStartTouch", EntityOutOfBounds )
			trigger.ConnectOutput( "OnEndTouch", EntityBackInBounds )
		#endif
	}

	AddCallback_GameStateEnter( eGameState.Postmatch, OutOfBoundsDisable )
}

void function OutOfBoundsDisable()
{
	if( Flowstate_DisableAllMapTriggers() )
		return
		
	foreach( trigger in file.outOfBoundsTriggers )
	{
		try 
		{
			#if MP
				foreach ( ent, val in oob_triggerEntPairs[trigger] )
					oob_triggerEntPairs[trigger][ent] = false
				trigger.DisconnectOutput( "OnStartTouch", EntityEnterOutOfBoundsTrig )
				trigger.DisconnectOutput( "OnEndTouch", EntityLeaveOutOfBoundsTrig )
			#else
				trigger.DisconnectOutput( "OnStartTouch", EntityOutOfBounds )
				trigger.DisconnectOutput( "OnEndTouch", EntityBackInBounds )
			#endif
		}
		catch( e )
		{
			#if DEVELOPER 
				Warning( "Track this down: " + e )
			#endif 
		}
	}
}

bool function IsPointOutOfBounds( vector point )
{
	foreach ( trigger in file.outOfBoundsTriggers )
	{
		if ( trigger.ContainsPoint( ClampToWorldspace( point ) ) )
			return true
	}
	return false
}

#if MP
void function EntityEnterOutOfBoundsTrig( entity trigger, entity ent, entity caller, var value )
{
	if ( !IsValid( ent ) || !ent.IsPlayer() )
	{
		EntityOutOfBounds( trigger, ent, null, null )
		return
	}

	if ( !(ent in oob_triggerEntPairs[trigger]) )
	{
		oob_triggerEntPairs[trigger][ent] <- true
		thread EntityCheckOutOfBoundsThread( trigger, ent )
	}
	else
	{
		oob_triggerEntPairs[trigger][ent] = true
		// thread is already running
	}
}

void function EntityLeaveOutOfBoundsTrig( entity trigger, entity ent, entity caller, var value )
{
	if ( !(ent in oob_triggerEntPairs[trigger]) )
	{
		EntityBackInBounds( trigger, ent, null, null )
		return
	}

	oob_triggerEntPairs[trigger][ent] = false // tell thread to stop
}

bool function TriggerIsTouchingPlayerHullAtPoint( entity player, entity trigger, float triggerminz, vector pos, float radius )
{
	if ( trigger.GetClassName() == "trigger_cylinder" )
	{
		array<entity> touchingEnts = trigger.GetTouchingEntities()
		return touchingEnts.contains( player )
	}
	else
	{
		return BrushTriggerIsTouchingPlayerHullAtPoint( trigger, triggerminz, pos, radius )
	}

	unreachable
}

bool function BrushTriggerIsTouchingPlayerHullAtPoint( entity trigger, float triggerminz, vector pos, float radius )
{
	if ( pos.z < triggerminz )
		return false

	radius *= 1.0824 // expand by 1/cos(22.5) so that an octagon circumscribes the circle

	if ( trigger.ContainsPoint( pos ) ||
		trigger.ContainsPoint( pos + <radius,0,0> ) ||
		trigger.ContainsPoint( pos + < -radius,0,0> ) ||
		trigger.ContainsPoint( pos + <0,radius,0> ) ||
		trigger.ContainsPoint( pos + <0,-radius,0> ) )
		return true

	float radius45 = radius * 0.7071

	if ( trigger.ContainsPoint( pos + <radius45,radius45,0> ) ||
		trigger.ContainsPoint( pos + < -radius45,-radius45,0> ) ||
		trigger.ContainsPoint( pos + <radius45,-radius45,0> ) ||
		trigger.ContainsPoint( pos + < -radius45,radius45,0> ) )
		return true

	return false
}

void function EntityCheckOutOfBoundsThread( entity trigger, entity ent )
{
	float minz = trigger.GetOrigin().z + trigger.GetBoundingMins().z
	float radius = ent.GetBoundingMaxs().x

	bool wasTouching = false
	for ( ;; )
	{
		wait 0.099

		if ( !IsValid( ent ) )
			break

		if ( !oob_triggerEntPairs[trigger][ent] )
			break

		bool isTouching
		if ( ent.IsOnGround() )
		{
			if ( ent.IsWallRunning() && !ent.IsWallHanging() )
			{
				isTouching = TriggerIsTouchingPlayerHullAtPoint( ent, trigger, minz, ent.GetOrigin() + <0,0,10>, radius )
			}
			else
			{
				isTouching = true
			}
		}
		else
		{
			vector startpos = ent.GetOrigin()
			vector endpos = startpos
			endpos.z -= 2048

			TraceResults result = TraceHull( startpos, endpos, ent.GetBoundingMins(), ent.GetBoundingMaxs(), ent, TRACE_MASK_PLAYERSOLID, TRACE_COLLISION_GROUP_PLAYER )
			if ( result.startSolid || result.fraction >= 1 || TriggerIsTouchingPlayerHullAtPoint( ent, trigger, minz, result.endPos + <0,0,40>, radius ) )
			{
				//DebugDrawLine( startpos, result.endPos, 255,255,255, true, 3.0 )
				isTouching = true
			}
			else
			{
				//DebugDrawLine( startpos, result.endPos, 255,0,0, true, 3.0 )
				isTouching = false
			}
		}

		if ( isTouching == wasTouching )
			continue

		wasTouching = isTouching
		if ( isTouching )
		{
			EntityOutOfBounds( trigger, ent, null, null )
		}
		else
		{
			EntityBackInBounds( trigger, ent, null, null )
		}
	}

	if ( wasTouching )
	{
		EntityBackInBounds( trigger, ent, null, null )
	}

	delete oob_triggerEntPairs[trigger][ent]
}
#endif

void function EntityOutOfBounds( entity trigger, entity ent, entity caller, var value )
{
	if(GetGameState() != eGameState.Playing)
		return
	
	if( !IsValid( ent ) || !ent.IsPlayer() || ent.Player_IsFreefalling() )
		return
	
	//printt( "ENTITY", ent, "IS OUT OF BOUNDS ON TRIGGER", trigger )

	if ( ent.e.destroyOutOfBounds )
		ent.Destroy()

	if ( !IsValidOutOfBoundsEntity( ent, trigger ) )
		return

	//printt( "Valid Out OfBounds Entity, EntityOutOfBounds" )

	if ( !(ent in file.outOfBoundsTable) ) //Note that we never remove the ent from the table after adding it
	{
		OutOfBoundsDataStruct initialDataStruct
		initialDataStruct.timeBackInBound = max( 0, Time() - OUT_OF_BOUNDS_DECAY_TIME )

		ManageAddEntToOutOfBoundsTable( ent,  initialDataStruct  )
	}

	OutOfBoundsDataStruct dataStruct = file.outOfBoundsTable[ ent ]

	dataStruct.outOfBoundsTriggersTouched++

	Assert( dataStruct.outOfBoundsTriggersTouched > 0 )

	// Not already touching another trigger
	if ( dataStruct.outOfBoundsTriggersTouched == 1 )
	{
		float decayTime = max( 0, Time() - dataStruct.timeBackInBound - OUT_OF_BOUNDS_DECAY_DELAY )
		float outOfBoundsTimeRegained = decayTime * ( OUT_OF_BOUNDS_TIME_LIMIT / OUT_OF_BOUNDS_DECAY_TIME )
		float deadTime = clamp( dataStruct.timeLeftBeforeDyingFromOutOfBounds + outOfBoundsTimeRegained, 0.0, OUT_OF_BOUNDS_TIME_LIMIT )

		//printt( "Decay Time: " + decayTime + ", outOfBoundsTimeRegained:" + outOfBoundsTimeRegained + ", timeLeftBeforeDyingFromOutOfBounds: " + dataStruct.timeLeftBeforeDyingFromOutOfBounds + ", deadTime: " + deadTime  )

		dataStruct.timeLeftBeforeDyingFromOutOfBounds = deadTime

		if ( MapName() == eMaps.mp_rr_aqueduct || MapName() == eMaps.mp_rr_aqueduct_night || MapName() == eMaps.mp_rr_arena_skygarden )
		{
			ent.SetOutOfBoundsDeadTime( Time() + 5 )
		}
		else
		{
			ent.SetOutOfBoundsDeadTime( Time() + deadTime )
		}

		thread KillEntityOutOfBounds( ent, trigger )
	}

	//printt( "ent.GetOutOfBoundsDeadTime():", ent.GetOutOfBoundsDeadTime() )
}

bool function EntityIsOutOfBounds( entity ent )
{
	if ( !( ent in file.outOfBoundsTable ) )
		return false
	return file.outOfBoundsTable[ ent ].outOfBoundsTriggersTouched > 0
}

void function EntityBackInBounds( entity trigger, entity ent, entity caller, var value )
{
	//printt( "ENTITY", ent, "IS BACK IN BOUNDS OF TRIGGER", trigger )

	if ( !IsValidOutOfBoundsEntity( ent, trigger ) )
		return

	//printt( "Valid Out OfBounds Entity, EntityBackInBounds" )

		if ( !(ent in file.outOfBoundsTable) )  //Can go back in bounds even though we went out of bounds as an invalid ent, e.g. in a dropship
		{
			OutOfBoundsDataStruct initialDataStruct
			ManageAddEntToOutOfBoundsTable( ent,  initialDataStruct  )

			ent.SetOutOfBoundsDeadTime( 0.0 )
			ent.Signal( "BackInBounds" )

			return
		}
		else
		{
			OutOfBoundsDataStruct dataStruct = file.outOfBoundsTable[ ent ]

			dataStruct.outOfBoundsTriggersTouched--
			if ( dataStruct.outOfBoundsTriggersTouched < 0 ) //You can exit from bounds while being an invalid ent from out of bounds on the way in, e.g. during dropship anims, etc
				 dataStruct.outOfBoundsTriggersTouched = 0

			if ( dataStruct.outOfBoundsTriggersTouched == 0 )
			{
				dataStruct.timeBackInBound = Time()
				dataStruct.timeLeftBeforeDyingFromOutOfBounds =  max( 0, ent.GetOutOfBoundsDeadTime() - Time() )
				ent.SetOutOfBoundsDeadTime( 0.0 )
				ent.Signal( "BackInBounds" )
				return
			}
		}
}

void function KillEntityOutOfBounds( entity ent, entity trigger )
{
	if ( GetGameState() < eGameState.Playing )
		return

	Assert( ent.GetOutOfBoundsDeadTime() != 0 )
	Assert( Time() <= ent.GetOutOfBoundsDeadTime() )

	ent.EndSignal( "OnDeath" )
	ent.Signal( "OutOfBounds" )
	ent.EndSignal( "OutOfBounds" )
	ent.EndSignal( "BackInBounds" )

	OnThreadEnd(
		function() : ( ent )
		{
			if ( IsValid( ent ) && !IsAlive( ent ) )
			{
				file.outOfBoundsTable[ ent ].outOfBoundsTriggersTouched = 0
				ent.SetOutOfBoundsDeadTime( 0 )
			}
		}
	)

	wait ent.GetOutOfBoundsDeadTime() - Time()

	if ( !IsValidOutOfBoundsEntity( ent, trigger ) )
		return

	if ( ent.GetOutOfBoundsDeadTime() == 0 )
		return

	ent.Die( svGlobal.worldspawn, svGlobal.worldspawn, { scriptType = DF_INSTANT, damageSourceId = eDamageSourceId.outOfBounds } )
}

bool function IsValidOutOfBoundsEntity( entity ent, entity trigger )
{
	if ( !IsValid( ent ) )
		return false

	if ( !IsAlive( ent ) )
		return false

	int triggerTeam = expect int( trigger.kv.teamnumber.tointeger() )

	Assert( triggerTeam >= 0 )

	if ( triggerTeam != 0  && ent.GetTeam() != triggerTeam )
		return false

	// Temp hack for tday intro, might not keep this
	if ( "disableOutOfBounds" in level && level.disableOutOfBounds == true )
		return false

	if ( ent.IsPlayer() )
	{
		if ( ent.IsNoclipping() && !ent.Anim_IsActive() ) //Need to check for Anim_IsActive because PlayAnim() calls will set IsNoclipping() to true. This caused a bug with ejecting out of a OutOfBounds trigger
			return false

		entity parentEnt = ent.GetParent()
		if ( IsValid( parentEnt ) && IsDropship( parentEnt ) )
			return false

		return true
	}

	if ( ent.IsNPC() && ent.IsTitan() )
		return true

	return false
}

void function OnTitanBecomesPilot_OutOfBoundsCheck( entity pilot, entity npc_titan )
{
	if ( pilot.GetOutOfBoundsDeadTime() == 0 )
		return

	npc_titan.SetOrigin( npc_titan.GetOrigin() ) //Kinda a hack to force redetection of the Titan touching the out of bounds trigger
}

void function ManageAddEntToOutOfBoundsTable( entity ent, OutOfBoundsDataStruct dataStruct  ) //Might be overkill, but: suggested by Haggerty to avoid leak of constantly adding ents to the file table without removing them
{
	//First clean up dead references in table
	table< entity, OutOfBoundsDataStruct> tempTable = clone file.outOfBoundsTable

	foreach( ent0, dataStruct0 in tempTable )
	{
		if ( !IsValid( ent0 ) )
		{
			delete file.outOfBoundsTable[ ent0 ]
		}
	}

	//Now add the new ent

	file.outOfBoundsTable[ ent ] <- dataStruct
}

bool function PlayerCanSpawn( entity player )
{
	if ( IsAlive( player ) )
		return false

	if ( player.isSpawning )
		return false

	return true
}

// function SetTitanAvailable( entity player )
// {
// 	Assert( player.entindex() < 32 )
// 	int shiftIndex = player.entindex() - 1
// 	int elimMask = (1 << shiftIndex)

// 	level.nv.titanAvailableBits = level.nv.titanAvailableBits | elimMask

// 	#if MP
// 		PIN_PlayerAbilityReady( player, "titanfall" )
// 	#endif
// }

function ClearTitanAvailable( entity player )
{
	Assert( player.entindex() < 32 )
	int shiftIndex = player.entindex() - 1
	int elimMask = (1 << shiftIndex)

	level.nv.titanAvailableBits = level.nv.titanAvailableBits & (~elimMask)
}



function SetRespawnAvailable( entity player )
{
	Assert( player.entindex() < 32 )
	int shiftIndex = player.entindex() - 1
	int elimMask = (1 << shiftIndex)

	level.nv.respawnAvailableBits = level.nv.respawnAvailableBits | elimMask
}


function ClearRespawnAvailable( entity player )
{
	Assert( player.entindex() < 32 )
	int shiftIndex = player.entindex() - 1
	int elimMask = (1 << shiftIndex)

	level.nv.respawnAvailableBits = level.nv.respawnAvailableBits & (~elimMask)
}

//Cafe's rework
void function SetPlayerEliminated( entity player )
{
	if( !IsValid( player ) )
		return

	if( !(player.GetPlatformUID() in EliminatedPlayers) )
	{
		EliminatedPlayerData data
		data.name = player.GetPlayerName()
		data.team = player.GetTeam()
		
		EliminatedPlayers[ player.GetPlatformUID() ] <- data
		
		printt( "PLAYER ELIMINATED SAVED - EA ID: " + player.GetPlatformUID() + " - NAME: " + data.name + " - TEAM: " + data.team )
	}
}

void function ClearPlayerEliminated( entity player )
{
	if( !IsValid( player ) )
		return

	if( player.GetPlatformUID() in EliminatedPlayers )
	{
		EliminatedPlayerData data = EliminatedPlayers[ player.GetPlatformUID() ]
		printt( "CLEARING ELIMINATED STATE FOR PLAYER " + player.GetPlatformUID() + " - NAME: " + data.name + " - TEAM: " + data.team )
		
		delete EliminatedPlayers[ player.GetPlatformUID() ]
	}
}

bool function IsPlayerEliminated( entity player )
{
	// printt("CHECKING IF PLAYER IS ELIMINATED " + player.GetPlayerName() + " - " + player.GetPlatformUID())

	return ( player.GetPlatformUID() in EliminatedPlayers )
}

EliminatedPlayerData function GetPlayerEliminatedData( entity player )
{
	return EliminatedPlayers[ player.GetPlatformUID() ]
}

bool function IsTeamEliminated( int team )
{
	array<entity> players = GetPlayerArrayOfTeam( team )

	foreach ( player in players )
	{
		if ( IsPlayerEliminated( player ) != true )
			return false
	}

	return true
}

// Clears all scoreboard data for the player to make sure we never use old data
void function ClearPostGameScoreboardData( entity player )
{
	if ( !IsValid( player ) || !player.IsPlayer() )
		return

	player.SetPersistentVar( "isPostGameScoreboardValid", false )
	player.SetPersistentVar( "isFDPostGameScoreboardValid", false )
}

bool function ShouldShowLossProtectionOnEOG( entity player )
{
	if ( player.p.hasMatchLossProtection != true )
		return false

	if ( player.GetTeam() == GetWinningTeam() )
		return false

	if ( IsPrivateMatch() )
		return false

	return true
}

// bool function GameModeRemove( entity ent )
// {
// 	string gameMode = GameRules_GetGameMode()
// 	switch ( gameMode )
// 	{
// 		// These game modes have checkboxes in leveled
// 		case LAST_TITAN_STANDING:
// 		case TEAM_DEATHMATCH:
// 		case ATTRITION:
// 		case CAPTURE_POINT:
// 		case CAPTURE_THE_FLAG:
// 		case FORT_WAR:
// 		case FFA:
// 		case FD:
// 			break

// 		// These game modes use tdm spawns
// 		case PILOT_SKIRMISH:
// 		case WINGMAN_PILOT_SKIRMISH:
// 		case MARKED_FOR_DEATH_PRO:
// 		case MARKED_FOR_DEATH:
// 		case T_DAY:
// 		case AI_TDM:
// 		case BOMB:
// 		case HARDCORE_TDM:
// 		case COLISEUM:
// 		case HUNTED:
// 		case DON:
// 		case TITAN_BRAWL:
// 		case SPEEDBALL:
// 			gameMode = TEAM_DEATHMATCH
// 			break

// 		case RAID:
// 		case ATCOOP:
// 		case CONQUEST:
// 		case PVE_SANDBOX:
// 			gameMode = ATTRITION
// 			break

// 		case LTS_BOMB:
// 		case WINGMAN_LAST_TITAN_STANDING:
// 			gameMode = LAST_TITAN_STANDING
// 			break

// 		case FREE_AGENCY:
// 			gameMode = FFA
// 			break

// 		default:
// 			// If a game mode is not handled in here, spawnpoints won't have checkboxes that correspond to it, so all spawnpoints will be used in that mode, which is probably bad.
// 			Assert( false, "Game mode " + gameMode + " not handled in GameModeRemove()" )
// 	}

// 	AT_CollisionCleanup( ent )

// 	string gamemodeKey = "gamemode_" + gameMode
// 	if ( ent.HasKey( gamemodeKey ) && (ent.kv[gamemodeKey] == "0" || ent.kv[gamemodeKey] == "") )
// 	{
// 		// printt( "Removing ent " + ent.GetClassName() + " with " + gamemodeKey + " = \"" + ent.kv[gamemodeKey] + "\" at " + ent.GetOrigin() )
// 		ent.Destroy()
// 		return true
// 	}
// 	//printt( "keeping ent", ent.GetClassName() )

// 	return false
// }

void function AT_CollisionCleanup( entity spawnPoint )
{
	if ( spawnPoint.GetScriptName() == "at_mega_turret" )
	{
		if ( spawnPoint.GetLinkEnt() != null ) // assuming this is func_brush_navmesh_separator
		{
			entity brush = spawnPoint.GetLinkEnt()
			brush.NotSolid()
		}
	}
}


void function EntityFire( entity ent, string fire )
{
	ent.Fire( fire )
}

void function EntityFireDelayed( entity ent, string fire, string parm, float delay )
{
	ent.Fire( fire, parm, delay )
}

entity function AddOutOfBoundsTriggerWithParams( vector org, float radius = 250.0, float height = 700.0 )
{
	entity trigger = CreateEntity( "trigger_cylinder" )
	trigger.SetRadius( radius )
	trigger.SetAboveHeight( height ) //Still not quite a sphere, will see if close enough
	trigger.SetBelowHeight( 80 )
	trigger.SetOrigin( org )
	DispatchSpawn( trigger )
	SetupOutOfBoundsTrigger( trigger )
	trigger.SetEnterCallback( OnOOBTriggerEnter )
	trigger.SetLeaveCallback( OnOOBTriggerLeave )
	trigger.SetPhaseShiftCanTouch( true )
	
	#if DEVELOPER
	DebugDrawHemiSphere( org, Vector(0,0,0), radius, 20, 210, 255, false, 999.0 )
	#endif
	
	return trigger
}

entity function AddDeathTriggerWithParams( vector org, float radius = 250.0, float below = 700.0 )
{
	entity trigger = CreateEntity( "trigger_cylinder" )
	trigger.SetRadius( radius )
	trigger.SetAboveHeight( 50 ) //Still not quite a sphere, will see if close enough
	trigger.SetBelowHeight( below )
	trigger.SetOrigin( org )
	DispatchSpawn( trigger )
	trigger.SetEnterCallback( OnDeathTriggerEnter )
	trigger.SearchForNewTouchingEntity()
	
	#if DEVELOPER
	DebugDrawHemiSphere( org, Vector(0,0,0), radius, 20, 210, 255, false, 999.0 )
	#endif
	
	return trigger
}

void function OnDeathTriggerEnter( entity trigger, entity ent )
{
	if ( !IsAlive( ent ) )
		return

	if ( ent.IsPlayer() && IsValid( ent.e.lastAttacker ) && ent.e.lastAttacker.IsPlayer() && IsAlive( ent.e.lastAttacker ) && ent.GetHealth() > 0 )
	{
		ent.TakeDamage( ent.GetHealth() + 1, ent.e.lastAttacker, trigger, { damageSourceId = eDamageSourceId.fall, scriptType = DF_BYPASS_SHIELD | DF_SKIPS_DOOMED_STATE } )
		//ent.Die( ent.e.lastAttacker, trigger, { damageSourceId = eDamageSourceId.fall, scriptType = DF_BYPASS_SHIELD | DF_SKIPS_DOOMED_STATE } )
	} else if( ent.IsPlayer() && ent.GetHealth() > 0 )
	{
		ent.TakeDamage( ent.GetHealth() + 1, svGlobal.worldspawn, trigger, { damageSourceId = eDamageSourceId.fall, scriptType = DF_BYPASS_SHIELD | DF_SKIPS_DOOMED_STATE } )
		//ent.Die( svGlobal.worldspawn, trigger, { damageSourceId = eDamageSourceId.fall, scriptType = DF_BYPASS_SHIELD | DF_SKIPS_DOOMED_STATE } )
	}
}

void function OnOOBTriggerEnter( entity trigger, entity ent )
{
	EntityEnterOutOfBoundsTrig( trigger, ent, null, 0 )
}

void function OnOOBTriggerLeave( entity trigger, entity ent )
{
	EntityLeaveOutOfBoundsTrig( trigger, ent, null, 0 )
}

//(mk): ranges may need tweaked during playtests
void function RingDamagePunch( entity ent, var damageInfo )
{
	if( !ent.IsPlayer() )
		return
		
	vector origin = GetPlayerCrosshairOrigin( ent )
	
	float multiplier = DamageInfo_GetViewPunchMultiplier( damageInfo )
	
	float softAmount = RandomFloatRange( 0.5, 1.0 ) * multiplier
	float hardAmount = RandomFloatRange( 1.0, 1.5 ) * multiplier
	float randomBoost = RandomFloatRange( 0.5, 1.5 )
	
	ent.ViewPunch( origin, softAmount, hardAmount, randomBoost )
}