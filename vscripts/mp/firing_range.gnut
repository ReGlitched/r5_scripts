global function FiringRangeGameMode_Init

global const float FIRINGRANGE_DISSOLVE_TIME = 1.0 // ITEM NEEDS TO BE DISSOLVE BEFORE SurvivalLoot_OnPhysicsDisabled ON PROP ENTITY
global const float FIRINGRANGE_RACK_RESPAWN_TIME = 0.5
global const float FIRINGRANGE_RACK_OFFSET = 32

global const int FIRINGRANGE_ATTACHMENTS_MAX_COLUMNS = 6
global const int FIRINGRANGE_ITEMS_MAX_COLUMNS = 6
global const int FIRINGRANGE_ORDNANCE_MAX_COLUMNS = 2
global const int FIRINGRANGE_AMMO_ROWS = 2

global const string FIRING_RANGE_TARGET_FLIP_SCRIPTNAME = "fr_target_flip"
global const string FIRING_RANGE_TARGET_FOLD_SCRIPTNAME = "fr_target_fold"

const asset TARGET_FOLDING_MODEL = $"mdl/barriers/shooting_range_target_01.rmdl"
global const asset FIRINGRANGE_FLICK_TARGET_ASSET = $"mdl/fx/plasma_sphere_01.rmdl"
global const asset FIRINGRANGE_FLICK_TARGET_PARTICLE_HIT = $"P_crypto_drone_explosion"
global const string FIRINGRANGE_FLICK_TARGET_SOUND = "Player.Hitbeep_headshot.Human_3P_vs_1P"

const asset TARGET_SPINNING_BASE = $"mdl/barriers/shooting_range_target_02_stand.rmdl"
const asset TARGET_SPINNING_MODEL = $"mdl/barriers/shooting_range_target_02.rmdl"
global const asset FIRINGRANGE_BLUE_TARGET_ASSET = $"mdl/barriers/shooting_range_target_02.rmdl"
global const asset FIRINGRANGE_BLUE_STAND_ASSET = $"mdl/barriers/shooting_range_target_02_stand.rmdl"
global const string TARGET_MOVER_SCRIPTNAME = "target_mover"

global const asset FIRINGRANGE_ITEM_RESPAWN_PARTICLE = $"P_impact_shieldbreaker_sparks"

global const asset FIRINGRANGE_BUTTON_ASSET = $"mdl/props/global_access_panel_button/global_access_panel_button_console_w_stand.rmdl"
global const string FIRINGRANGE_BUTTON_SOUND = "UI_Menu_back"

global const asset FIRINGRANGE_DOOR_ASSET = $"mdl/door/canyonlands_door_single_02.rmdl"

global const asset FIRINGRANGE_128x128_ASSET = $"mdl/thunderdome/thunderdome_cage_floor_128x128_01.rmdl"
global const asset FIRINGRANGE_256x128_ASSET = $"mdl/thunderdome/thunderdome_cage_wall_256x128_03.rmdl"
global const asset FIRINGRANGE_256x256_ASSET = $"mdl/thunderdome/thunderdome_cage_ceiling_256x256_06.rmdl"
global const asset FIRINGRANGE_GRATE_ASSET = $"mdl/industrial/landing_mat_metal_02_large.rmdl"
global const asset FIRINGRANGE_QUARRY_BLOCK_ASSET = $"mdl/rocks/thunderdome_quarry_block_01_orange.rmdl"

#if SERVER
// To be used outside if needed
global int firingrange_infinite_ammo = 0
global function FiringRangeProps
global function CreateFRButton

bool toggledFriendlyFire = false
global function CreateGunRangeTargetsForRealm
#endif

#if CLIENT
global function SCB_BroadcastFriendlyFireChange
#endif // CLIENT

struct RackGroup
{
	entity point = null
	string ammoType = ""
	array<entity> racks = []
}

struct sMovingTarget
{
	entity targetBase
	entity slideTarget
	bool headedTowardEnd
	vector start
	vector end
	string soundfx = ""
}

table< int,  array< sMovingTarget > > fr_MovingTargets
global table < int, int > frIntSettings_Defaults

global enum eGunRangeTargetTypes
{
	SPINNING,
	FOLDING,
}

global enum eFRSettingType
{
	// ----- Personal FR Bool Settings.
	// To add new Personal Settings, add to the end of this section.
	SHOWRUI,				// Show the Settings RUI Overlay?
	SHOWDYNSTATS,			// Show Dynamic Stats?
	SHOWDYNTIMER,			// Show Dynamic Stats Timer?
	LEGENDUPGRADES_RESET,	// Reset Legend Upgrades.
	INFINITEMAGS,			// Infinite Reloads: ON/OFF
	SHOWHITMARKS,			// Hit Markers: ON/OFF
	SHOW3RDPERSON,			// 3rd-Person Mode: ON/OFF
	                    
		LEGENDUPGRADESENABLED,
                           

	// ----- Shared FR bool Settings.
	// To add new Shared Settings, add to the end of this section.
	FRIENDLYFIRE,			// Friendly Fire: ON/OFF
	FRDUMMIEHELMETMATCHSHIELDS,	// Dummie Helmets Match Shield Levels.
	                   
	DYNAMICDUMMIESON,	// Dynamic Dummies Enabled/Disabled
	DUMMIEHIGHLIGHTSON,	// Whether or not to highlight dummies.
       
	//	// ----- Shared Int Settings.
	// To add new Shared Int Setting:
	//		- add to the end of this section
	//		- register a new NetVar and PVar.
	//		- follow the function patterns established by targetspeed and frdummieshieldlvl.
	//			- UCB_SV_FRSetting_<SettingName>_Change(): called from UI.
	//			- FRSetting_<SettingName>_Set_OnPlayer(): called from above to set the data.
	//			- SCB_Broadcast_FRSettings_<SettingName>_Change(): Remote called from above to notify players of change.
	TARGETSPEED,			// TARGET SPEED: < number >
	FRDUMMIESHIELDLVL,		// FIRING RANGE DUMMIE SHIELD LEVEL: < number >
	FRDUMMIESPEED,
	FRDUMMIEMOVEMENT,
	FRDUMMIESTANCE,
                   
	FRDUMMIESHOOTING,
	FRDUMMIESPAWNDISTS,
      
	COUNT_
}

struct {
	table<string, array<LootData> > weaponsPerAmmoType
	table<string, array<string> > attachmentsPerAmmoType
	array< array<LootData> > equipmentsPerIndex
	array<LootData> items
	array<LootData> ordnance

	array<RackGroup> rackSpawns

	vector training_mov = <1,0,0>
	vector trackingTraining_pos = <32000,-7853,-29033>
	vector flickTraining_pos = <32000,-6720,-29033>
	vector flickTraining_ang = <0,-180,0>
	float flickTraining_dist = 320
	float trackingTraining_speed = 300
	bool trackingTraining_speedRand = false

	array<entity> doors
	vector doorResetButton_pos = <30754,-9885,-25972>
	vector doorResetButton_ang = <0,270,0>
	vector doorSingle_pos = <30582,-9725,-25972>
	vector doorSingle_ang = <0,90,0>
	vector doorDouble_pos = <30550,-10025,-25972>
	vector doorDouble_ang = <0,90,0>
} file

void function FiringRangeGameMode_Init()
{
	if ( !IsFiringRangeGameMode() )
		return

	PrecacheModel( FIRINGRANGE_BLUE_STAND_ASSET )
	PrecacheModel( FIRINGRANGE_FLICK_TARGET_ASSET )
	PrecacheModel( TARGET_FOLDING_MODEL )
	PrecacheModel( TARGET_SPINNING_MODEL )
	PrecacheParticleSystem( FIRINGRANGE_FLICK_TARGET_PARTICLE_HIT )

	RegisterSignal( "GunRangeTargetDamaged" )
	RegisterSignal( "SlideTargetSpeedReset" )
	RegisterSignal( "SlideTargetThinkStart" )
	RegisterSignal( "SlideTargetWaitForReset" )

	#if SERVER
	AddSpawnCallback( "prop_survival", OnPropSurvivalSpawned )
	#endif
	
	if( Playlist() != ePlaylists.survival_firingrange )
		return

	//PrecacheParticleSystem( FIRINGRANGE_ITEM_RESPAWN_PARTICLE )

	ScriptRemote_RegisterClientFunction( "SCB_BroadcastFriendlyFireChange", "entity" )

	#if SERVER
		AddCallback_EntitiesDidLoad( OnEntitiesDidLoad )
		AddCallback_OnClientConnected( WaitForPlayerSpawn )
		AddCallback_OnPlayerKilled( OnPlayerKilled )
		//AddCallback_OnWeaponAttack( OnWeaponAttack )
		AddCallback_ItemFlavorLoadoutSlotDidChange_AnyPlayer( Loadout_CharacterClass(), OnTeammateLoadoutSelectionChanged, false )
		AddClientCommandCallback( "firingrange_toggle_friendlyfire", ClientCommand_ToggleFriendlyFire )

		firingrange_infinite_ammo = GetCurrentPlaylistVarBool( "survival_infinite_ammo", false ) ? 1 : 2
	#endif
	#if CLIENT
		IntroDisplayThread()
	#endif //CLIENT
}

#if CLIENT
void function SCB_BroadcastFriendlyFireChange( entity playerThatChanged )
{
	entity localPlayer = GetLocalClientPlayer()
	bool isEnabled = IsTeamRabid( localPlayer.GetTeam() )
	string mainText = (isEnabled ? "#NOTIFY_FRIENDLY_FIRE_ON" : "#NOTIFY_FRIENDLY_FIRE_OFF")
	string subText = (IsValid( playerThatChanged ) ? Localize( "#NOTIFY_FRIENDLY_FIRE_SUBTEXT", playerThatChanged.GetPlayerName() ) : "")
	vector titleColor = (isEnabled ? ENEMY_COLOR : FRIENDLY_COLOR)
	AnnouncementMessage( localPlayer, mainText, subText, titleColor )
}

#endif //

void function OnEntitiesDidLoad()
{
	#if SERVER
	array<entity> lootbins = GetEntArrayByScriptName("staging_loot_bin")
	foreach(entity lootbin in lootbins)
		lootbin.Destroy()

	thread FiringRangeProps()

	//array< entity > dummypts = GetEntArrayByScriptName( "spawnnpoint_frdummy" )
	//foreach( dummypt in dummypts)
	SpawnDummy(<31541,-7964,-29200>, <0,179,0>)
	SpawnDummy(<31541,-6705,-29200>, <0,179,0>)
	SpawnDummy(<31541,-5885,-29200>, <0,179,0>)

	// Doors
	//SpawnDoors_Init()

	// Map Props
	//SpawnMapProps()

	// Targets
	//SpawnTrainingTarget(file.flickTraining_pos, file.flickTraining_ang, OnTrainingTargetDamagedReposition)
	//thread MoveTrainingTargetAround(
		//SpawnTrainingTarget(file.trackingTraining_pos, file.flickTraining_ang, OnTrainingTargetDamagedNothing))

		CreateGunRangeTargetsForRealm()
	//SpawnTargets()
	// - - - -
	#endif
}

#if SERVER
void function FiringRangeProps()
{
	// Init
	CreateLegendaryRack()//Create 6th weapon rack to support sniper ammo
	CreateBowRack()//Create 7th weapon rack to support arrows
	array<entity> movers = GetEntArrayByScriptName("script_mover_lightweight")

	foreach(entity e in GetEntArrayByScriptName("weapon_racks"))
	{
		RackGroup r;	r.point = e
		file.rackSpawns.append(r)
	}

	FillWeaponTable() // load first to know where the rest goes
	FillAttachmentTable() // requires weapons to be loaded
	FillEquipmentTable() // armor + helmet + bp + shield
	FillOrdnanceTable() // nades
	FillItemTable() // health + batts + the rest
	
	CreateRackGroups()
	if ( !IsSurvivalTraining() )
	{
		SpawnEquipments()
		SpawnOrdnance()
		SpawnItems()
		SpawnAttachments()
	}
	SpawnAmmo()
}
entity function CreateLegendaryRack()
{
	entity Rack_Index_Six = CreateEntity( "info_target" )
	Rack_Index_Six.SetOrigin( <30655, -6680, -29164> )
	Rack_Index_Six.SetAngles( <0,0,0> )
	Rack_Index_Six.SetScriptName( "weapon_racks" )
	DispatchSpawn( Rack_Index_Six )
	return Rack_Index_Six
}

entity function CreateBowRack()
{
	entity Rack_Index_Seven = CreateEntity( "info_target" )
	Rack_Index_Seven.SetOrigin( <30655, -5283, -29164> )
	Rack_Index_Seven.SetAngles( <0,0,0> )
	Rack_Index_Seven.SetScriptName( "weapon_racks" )
	DispatchSpawn( Rack_Index_Seven )
	return Rack_Index_Seven
}

bool function ClientCommand_ToggleFriendlyFire( entity player, array<string> args )
{
	toggledFriendlyFire = !toggledFriendlyFire
	SetTeamIsRabid( player.GetTeam(), toggledFriendlyFire )
	foreach( targetPlayer in GetPlayerArray() )
		Remote_CallFunction_NonReplay( targetPlayer, "SCB_BroadcastFriendlyFireChange", player )

	return true
}

void function SpawnDummy(vector origin, vector angles)

{
    entity dummy = CreateEntity( "npc_dummie" )
    SetSpawnOption_AISettings( dummy, "npc_training_dummy" )
    dummy.SetOrigin( origin )
    dummy.SetAngles( angles )
	DispatchSpawn( dummy )
	dummy.SetShieldHealthMax( 100 )
	dummy.SetShieldHealth( 100 )
	dummy.SetMaxHealth( 100 )
	dummy.SetHealth( 100 )
	dummy.SetTakeDamageType( DAMAGE_YES )
	dummy.SetDamageNotifications( true )
	dummy.SetDeathNotifications( true )
	dummy.SetValidHealthBarTarget( true )
	SetObjectCanBeMeleed( dummy, true )
	dummy.SetSkin(1)
	dummy.DisableHibernation()
	dummy.GiveWeapon("mp_weapon_rspn101", WEAPON_INVENTORY_SLOT_ANY)
    SetTeam(dummy, 99)

	thread OnDummyKilled(dummy)
}

void function OnDummyKilled(entity dummy)
{
	//printt("Flowstate DEBUG - Dummy killed, spawning it.")
	vector pos = dummy.GetOrigin()
	vector angles = dummy.GetAngles()
	dummy.WaitSignal( "OnDeath" )
	wait 2
	//StartParticleEffectInWorld( GetParticleSystemIndex( FIRINGRANGE_ITEM_RESPAWN_PARTICLE ), pos, angles )
	thread SpawnDummy( pos, angles)
}

// ==================================================
//					PLAYER EQUIP
// ==================================================


void function OnPlayerKilled( entity victim, entity attacker, var damageInfo )
{
	victim.SetPlayerNetInt( "respawnStatus", eRespawnStatus.WAITING_FOR_DELIVERY )
	WaitForPlayerSpawn(victim)
}

void function WaitForPlayerSpawn( entity player )
{
	thread WaitForPlayerSpawn_Thread(player)
}

void function WaitForPlayerSpawn_Thread(entity player)
{
	while(IsValid(player) && !IsAlive(player))
		wait 1
	player.SetOrigin(<26539, -5637, -27479>)
	player.SetAngles(<0, 0, 0>)
	SetPlayerInventory( player, [] )
	thread OnPlayerRespawned(player)
}

void function OnPlayerRespawned(entity player)
{
	array<entity> weapons = player.GetMainWeapons()

	entity primary = player.GiveWeapon("mp_weapon_semipistol", WEAPON_INVENTORY_SLOT_PRIMARY_1, [])
	//entity secondary = player.GiveWeapon("mp_weapon_semipistol", WEAPON_INVENTORY_SLOT_PRIMARY_1, ["bullets_mag_l3","optic_cq_threat"])
	player.SetActiveWeaponByName( eActiveInventorySlot.mainHand, "mp_weapon_semipistol" )
	entity weapon = player.GetActiveWeapon( eActiveInventorySlot.mainHand )

	foreach(string ammo in ["bullet"])
	{
		entity loot = SpawnGenericLoot( ammo, player.GetOrigin(), player.GetAngles(),
			20-SURVIVAL_CountItemsInInventory( player, ammo ) )

		if(!Survival_PickupItem(loot, player))
			loot.Destroy()
	}

	player.SetShieldHealth( player.GetShieldHealthMax() )
	
	player.UnfreezeControlsOnServer()
}

void function OnTeammateLoadoutSelectionChanged( EHI playerEHI, ItemFlavor unused )
{
	entity player = FromEHI( playerEHI )
	ClientCommand( player, "Sur_UpdateCharacterLock 0" )
	if( IsAlive( player ) && Bleedout_IsBleedingOut( player ) )
		player.Die( null, null, { damageSourceId = eDamageSourceId.damagedef_despawn } )
}

// ==================================================
//					ITEM SPAWNING
// ==================================================


// Get All weapons, arange them in a table per ammo type
void function FillWeaponTable()
{
	foreach ( string lootRef, LootData lootData in SURVIVAL_Loot_GetLootDataTable() )
	{
		if ( lootData.lootType != eLootType.MAINWEAPON )
			continue

		if ( lootData.ref.find("_gold") > 0)
			continue

		if(!(lootData.ammoType in file.weaponsPerAmmoType))
			file.weaponsPerAmmoType[lootData.ammoType] <- []

		file.weaponsPerAmmoType[lootData.ammoType].append(lootData)
	}
}

// Get All attachments, check if can be put on each gun per ammo
// Add it if missing to our list
void function FillAttachmentTable()
{
	foreach ( string ammoType, array<LootData> weapons in file.weaponsPerAmmoType )
	{
		if ( ammoType == "arrows" )
			continue
			
		if ( ammoType.len() == 0 )
			continue

		array<LootData> allAttachments = SURVIVAL_Loot_GetByType( eLootType.ATTACHMENT )
		array<LootData> unSortedAttachments = []

		foreach(LootData weapon in weapons)
		{
			array<LootData> attachments = []
			foreach ( LootData data in allAttachments )
			{
				if ( !CanAttachToWeapon( data.ref, weapon.ref ) )
					continue
				attachments.append(data)
			}
			ExtendLootDataArrayIfMissing(attachments, unSortedAttachments)
		}

		// Make the hopups last, rest alphabetical
		array<string> strHopups = []
		array<string> strAttachments = []
		foreach(LootData a in unSortedAttachments)
		{
			if(a.ref.slice(0,a.ref.find("_")) != "hopup")
				strAttachments.append(a.ref)
			else
				strHopups.append(a.ref)
		}
		strAttachments.sort()
		strAttachments.extend(strHopups)

		file.attachmentsPerAmmoType[ammoType] <- strAttachments
	}
}

// Append all equipments
void function FillEquipmentTable()
{
	file.equipmentsPerIndex.append(SURVIVAL_Loot_GetByType( eLootType.ARMOR ))
	file.equipmentsPerIndex.append(SURVIVAL_Loot_GetByType( eLootType.HELMET ))
	file.equipmentsPerIndex.append(SURVIVAL_Loot_GetByType( eLootType.INCAPSHIELD ))
	file.equipmentsPerIndex.append(SURVIVAL_Loot_GetByType( eLootType.BACKPACK ))
}

// Append all items
void function FillItemTable()
{
	file.items.extend(SURVIVAL_Loot_GetByType( eLootType.HEALTH ))
	file.items.extend(SURVIVAL_Loot_GetByType( eLootType.RESOURCE ))
	//file.items.extend(SURVIVAL_Loot_GetByType( eLootType.SURVIVAL ))
	//file.items.extend(SURVIVAL_Loot_GetByType( eLootType.CUSTOMPICKUP ))
	file.items.extend(SURVIVAL_Loot_GetByType( eLootType.JUMPKIT ))
}

// Append all ordnances
void function FillOrdnanceTable()
{
	file.ordnance.extend(SURVIVAL_Loot_GetByType( eLootType.ORDNANCE ))
}

// Add string only if missing
void function ExtendLootDataArrayIfMissing(array<LootData> from, array<LootData> to)
{
	foreach(LootData f in from)
	{
		bool add = true
		foreach(LootData t in to)
			if(t == f){	add = false; break	}
		if(add) to.append(f)
	}
}

// Spawn nades at the left of the racks
void function SpawnOrdnance()
{
	const float cornerOffset = 40.0
	const float itemOffsetX = 16.0
	const float itemOffsetY = 16.0
	const float itemOffsetZ = 4.0
	foreach(RackGroup rackGroup in file.rackSpawns)
	{
		if( rackGroup.ammoType == "" )
			continue
			
		if ( rackGroup.ammoType == "arrows" )
			continue

		entity rack = rackGroup.point
		vector rght = rack.GetRightVector()
		vector fwd = rack.GetForwardVector()
		vector up = rack.GetUpVector()

		vector firstPos = rack.GetOrigin() + (rght*rackGroup.racks.len()*FIRINGRANGE_RACK_OFFSET)/2 + rack.GetRightVector()*cornerOffset

		int col = 0
		int row = 0
		for(int i = 0; i<file.ordnance.len(); i++)
		{
			// Double it
			for(int j = 0; j<2; j++)
			{
				if(col >= FIRINGRANGE_ORDNANCE_MAX_COLUMNS)
				{
					row++
					col = 0
				}

				LootData item = file.ordnance[i]
				vector pos = firstPos + rght*itemOffsetX*col + fwd*itemOffsetY*row + up*itemOffsetZ

				entity loot = SpawnGenericLoot(item.ref, pos, <0,90,0>, 1)
				thread OnPickupGenericThread(loot, item.ref)

				col++
			}
		}
	}
}

// Spawn ammo at the left of the racks
void function SpawnAmmo()
{
	const float cornerOffset = -4
	const float itemOffsetX = 20.0
	const float itemOffsetY = 20.0

	foreach(RackGroup rackGroup in file.rackSpawns)
	{
		if(rackGroup.ammoType == "")
			continue

		entity rack = rackGroup.point
		vector rght = rack.GetRightVector()
		vector fwd = rack.GetForwardVector()
		vector up = rack.GetUpVector()

		vector firstPos = rack.GetOrigin() + (rght*rackGroup.racks.len()*FIRINGRANGE_RACK_OFFSET)/2 + rack.GetRightVector()*cornerOffset

		int ammoStack = SURVIVAL_Loot_GetLootDataByRef( rackGroup.ammoType ).countPerDrop * 2

		for(int i = 0; i<2; i++)
		{
			for(int j = 0; j<FIRINGRANGE_AMMO_ROWS; j++)
			{
				vector pos = firstPos + rght*itemOffsetX*i + fwd*itemOffsetY*j

				entity loot = SpawnGenericLoot(rackGroup.ammoType, pos, <0,90,0>, ammoStack)
				thread OnPickupGenericThread(loot, rackGroup.ammoType, ammoStack)
			}
		}
	}
}

// Spawn all items at the opposite right of the racks
void function SpawnItems()
{
	const float otherSideOffset = 512.0
	const float cornerOffset = 0.0
	const float itemOffsetX = 32.0
	const float itemOffsetY = 24.0
	foreach(RackGroup rackGroup in file.rackSpawns)
	{
		if( rackGroup.ammoType == "" )
			continue
		
		if ( rackGroup.ammoType == "arrows" )
			continue

		entity rack = rackGroup.point
		vector rght = rack.GetRightVector()
		vector fwd = rack.GetForwardVector()

		vector firstPos = rack.GetOrigin() + fwd*otherSideOffset + rght*cornerOffset

		int col = 0
		int row = 0
		for(int i = 0; i<file.items.len(); i++)
		{
			if(col >= FIRINGRANGE_ITEMS_MAX_COLUMNS)
			{
				row++
				col = 0
			}

			LootData item = file.items[i]
			vector pos = firstPos + rght*itemOffsetX*col - fwd*itemOffsetY*row

			entity loot = SpawnGenericLoot(item.ref, pos, <0,90,0>, 1)
			thread OnPickupGenericThread(loot, item.ref)

			col++
		}
	}
}

// Spawn all equipments at the opposite left of the racks
void function SpawnEquipments()
{
	const float otherSideOffset = 512.0
	const float cornerOffset = 256.0
	const float itemOffsetX = 32.0
	const float itemOffsetY = 24.0
	foreach(RackGroup rackGroup in file.rackSpawns)
	{
		if( rackGroup.ammoType == "" )
			continue
			
		if ( rackGroup.ammoType == "arrows" )
			continue
		
		entity rack = rackGroup.point
		vector rght = rack.GetRightVector()
		vector fwd = rack.GetForwardVector()

		vector firstPos = rack.GetOrigin() + fwd*otherSideOffset - rght*cornerOffset

		for(int i = 0; i<file.equipmentsPerIndex.len(); i++)
		{
			array<LootData> group = file.equipmentsPerIndex[i]

			for(int j = 0; j<group.len(); j++)
			{
				LootData item = group[j]
				vector pos = firstPos + rght*itemOffsetX*j - fwd*itemOffsetY*i

				entity loot = SpawnGenericLoot(item.ref, pos, <0,90,0>, 1)
				thread OnPickupGenericThread(loot, item.ref)
			}
		}
	}
}

// Spawn attachments at the right of the racks
void function SpawnAttachments()
{
	const float cornerOffset = 128.0
	const float placementOffset = 24.0
	int ammoIndex = 0
	foreach ( string ammoType, array<LootData> arr in file.weaponsPerAmmoType) // Correspond to each rack
	{
		foreach(string ammoType2, array<string> refs in file.attachmentsPerAmmoType)
		{
			if( ammoType != ammoType2 || ammoType == "" )
				continue
				
			if ( ammoType == "arrows" )
				continue

			entity r = file.rackSpawns[ammoIndex].point
			vector firstPos = r.GetOrigin() - r.GetRightVector()*cornerOffset

			int row = 0
			int col = 0
			foreach(string ref in refs)
			{
				if(col >= FIRINGRANGE_ATTACHMENTS_MAX_COLUMNS)
				{
					row++
					col = 0
				}

				vector pos = firstPos - r.GetRightVector()*col*placementOffset + r.GetForwardVector()*row*placementOffset

				entity loot = SpawnGenericLoot( ref, pos, <0,0,0>, 1 )
				thread OnPickupGenericThread(loot, ref)
				col++
			}
		}
		ammoIndex++
	}
}

// Create weapon racks per ammo type
void function CreateRackGroups()
{
	int ammoIndex = 0
	foreach ( string ammoType, array<LootData> arr in file.weaponsPerAmmoType)
	{
		if(ammoIndex >= file.rackSpawns.len() )
			break

		float rOffset = (arr.len()*FIRINGRANGE_RACK_OFFSET)/2

		for(int i = 0; i<arr.len(); i++)
		{
			entity r = file.rackSpawns[ammoIndex].point
			vector pos = r.GetOrigin() + r.GetRightVector()*i*FIRINGRANGE_RACK_OFFSET - r.GetRightVector()*rOffset
			vector ang = r.GetAngles()

			entity rack = CreateWeaponRack(pos, ang, arr[i].ref)

			file.rackSpawns[ammoIndex].racks.append(rack)
			file.rackSpawns[ammoIndex].ammoType = ammoType

			thread OnPickupFromRackThread(GetWeaponFromRack(rack), arr[i].ref)
		}
		ammoIndex++
	}
}

// When the weapon is grabbed from the rack -> respawn it
void function OnPickupFromRackThread(entity item, string ref)
{
	entity rack = item.GetParent()
	item.WaitSignal("OnItemPickup")

	wait FIRINGRANGE_RACK_RESPAWN_TIME

	entity newWeapon = SpawnWeaponOnRack(rack, ref)
	//StartParticleEffectInWorld( GetParticleSystemIndex( FIRINGRANGE_ITEM_RESPAWN_PARTICLE ), newWeapon.GetOrigin(), newWeapon.GetAngles() )
	thread OnPickupFromRackThread(newWeapon, ref)
}

// When the item is grabbed -> respawn it
void function OnPickupGenericThread(entity item, string ref, int amount = 1)
{
	vector pos = item.GetOrigin()
	vector angles = item.GetAngles()
	item.WaitSignal("OnItemPickup")

	wait FIRINGRANGE_RACK_RESPAWN_TIME

	//StartParticleEffectInWorld( GetParticleSystemIndex( FIRINGRANGE_ITEM_RESPAWN_PARTICLE ), pos, angles )
	thread OnPickupGenericThread(SpawnGenericLoot(ref, pos, angles, amount), ref, amount)
}

// On item dropped
void function OnPropSurvivalSpawned(entity prop)
{
	thread OnPropSurvivalSpawned_Thread(prop)
}

void function OnPropSurvivalSpawned_Thread(entity prop)
{
	wait FIRINGRANGE_DISSOLVE_TIME
	if(prop == null || IsValid(prop) == false)
		return

	entity par = prop.GetParent()
	if(par && par.GetClassName() == "prop_physics")
		prop.Dissolve(ENTITY_DISSOLVE_CORE, <0,0,0>, 200)
}



// ==================================================
//					TARGET PRACTICE
// ==================================================

void function PlayTrainingTargetReaction(entity ent, var damageInfo)
{
	entity attacker = DamageInfo_GetAttacker(damageInfo);
	if (IsValid(attacker) && attacker.IsPlayer())
	{
		EmitSoundOnEntityOnlyToPlayer( attacker, attacker, FIRINGRANGE_FLICK_TARGET_SOUND )

		attacker.NotifyDidDamage
		(
			ent,
			DamageInfo_GetHitBox( damageInfo ),
			DamageInfo_GetDamagePosition( damageInfo ),
			DamageInfo_GetCustomDamageType( damageInfo ),
			DamageInfo_GetDamage( damageInfo ),
			DamageInfo_GetDamageFlags( damageInfo ),
			DamageInfo_GetHitGroup( damageInfo ),
			DamageInfo_GetWeapon( damageInfo ),
			DamageInfo_GetDistFromAttackOrigin( damageInfo )
		)
	}
}

void function MoveTrainingTargetAround(entity ent)
{
	entity o = ent.GetParent()
	float dist = file.flickTraining_dist * 0.75
	while(IsValid(ent))
	{
		vector next

		int tries = 0
		while(Distance(ent.GetOrigin(),next) < 30 || Distance(ent.GetOrigin(),next) > dist*0.7)
		{
			if(tries>20)
				break

			next = o.GetOrigin() +
				RandomFloatRange(-dist,dist)*o.GetUpVector()*0.75*file.training_mov.y +
				RandomFloatRange(-dist,dist)*o.GetRightVector()*file.training_mov.x;

			tries++
		}

		float t = Distance(ent.GetOrigin(),next) / (file.trackingTraining_speedRand ? RandomFloatRange(260,450) : file.trackingTraining_speed)
		ent.NonPhysicsMoveTo(next, t, 0, 0 )
		wait t
	}
}

void function OnTrainingTargetDamagedNothing(entity ent, var damageInfo)
{
	PlayTrainingTargetReaction(ent, damageInfo)
}

void function OnTrainingTargetDamagedReposition(entity ent, var damageInfo)
{
	StartParticleEffectInWorld( GetParticleSystemIndex( FIRINGRANGE_FLICK_TARGET_PARTICLE_HIT ), ent.GetOrigin(), ent.GetAngles() )
	PlayTrainingTargetReaction(ent, damageInfo)

	entity root = ent.GetParent()
	vector newPos = root.GetOrigin() +
					RandomFloatRange(-file.flickTraining_dist,file.flickTraining_dist)*root.GetUpVector()*0.5*file.training_mov.y +
					RandomFloatRange(-file.flickTraining_dist,file.flickTraining_dist)*root.GetRightVector()*file.training_mov.x;

	ent.SetOrigin(newPos)

	ent.Signal( "OnActivate" )
	thread ResetTrainingTarget(ent)
}

void function ResetTrainingTarget(entity ent)
{
	EndSignal( ent, "OnActivate" )
	wait 4
	ent.SetOrigin(ent.GetParent().GetOrigin())
	//StartParticleEffectInWorld( GetParticleSystemIndex( FIRINGRANGE_ITEM_RESPAWN_PARTICLE ), ent.GetOrigin(), <0,0,0> )
}

entity function SpawnTrainingTarget(vector pos, vector ang, void functionref( entity, var ) onDamaged )
{
	entity root = CreateScriptMover( pos, ang)

	entity target = CreateEntity( "script_mover" )
	target.kv.solid = 6
	target.SetValueForModelKey( FIRINGRANGE_FLICK_TARGET_ASSET )
	target.kv.SpawnAsPhysicsMover = 0
	target.SetOrigin( root.GetOrigin() )
	target.SetAngles( root.GetAngles() )
	DispatchSpawn( target )
	target.Hide()
	target.SetDamageNotifications( true )
	target.SetParent(root)

	entity visual = CreatePropDynamic(FIRINGRANGE_BLUE_TARGET_ASSET, root.GetOrigin(), root.GetAngles(), 6, -1)
	visual.SetParent(target)
	visual.SetModelScale(0.45)
	visual.NotSolid()

    AddEntityCallback_OnDamaged(target, onDamaged)
	return target
}

entity function SpawnBigTrainingTarget(vector pos, vector ang, void functionref( entity, var ) onDamaged )
{
	entity target = CreateEntity( "prop_dynamic" )
	target.kv.solid = 6
	target.SetValueForModelKey( FIRINGRANGE_BLUE_TARGET_ASSET )
	target.kv.SpawnAsPhysicsMover = 0
	target.SetOrigin( pos )
	target.SetAngles( ang )
	DispatchSpawn( target )
	target.SetDamageNotifications( true )

    AddEntityCallback_OnDamaged(target, onDamaged)
	return target
}

entity function SpawnTarget(vector pos, vector ang )
{
	entity stand = CreateEntity( "prop_dynamic" )
	stand.kv.solid = 6
	stand.SetValueForModelKey( FIRINGRANGE_BLUE_STAND_ASSET )
	stand.SetOrigin( pos )
	stand.SetAngles( ang )
	stand.AllowMantle()
	DispatchSpawn( stand )
	entity target = SpawnBigTrainingTarget(pos+<0,0,120>,stand.GetAngles(),OnTrainingTargetDamagedNothing)
	target.SetParent(stand)
	return stand
}

void function SpawnTargets()
{
	array<entity> props = GetEntArrayByClass_Expensive( "prop_dynamic" )
	foreach(entity t in GetEntArrayByScriptName("shooting_range_rotating_target"))
	{
		// Check if it's inside a custom map prop
		bool skip = false
		foreach(entity p in props)
		{
			if(Distance(p.GetOrigin(),t.GetOrigin()) < 256)
			{
				skip = true
				break
			}
		}

		if(skip)
			continue

		// Skip if they're moving targets, they're useless
		if(t.GetLinkEntArray().len() > 0)
			continue

		SpawnTarget(t.GetOrigin(), t.GetAngles() )
	}
	SpawnTarget(<35819.4961, -6457.02588, -26410.3125>, <0,180,0> )
	SpawnTarget(<31240.9922, -10316.9521, -27762.9805>, <0,90,0> )
	
}

void function CreateGunRangeTargetsForRealm( bool autoReset = true, bool doBling = false )
{
	                         
	foreach ( ent in GetEntArrayByScriptName( "shooting_range_rotating_target" ) )
	{
			{
				thread CreateGunRangeTarget( ent, eGunRangeTargetTypes.SPINNING, autoReset, doBling )
			}

		if ( doBling )
			WaitFrame()
	}

	foreach ( ent in GetEntArrayByScriptName( "shooting_range_folding_target" ) )
	{
		thread CreateGunRangeTarget( ent, eGunRangeTargetTypes.FOLDING, autoReset, doBling )
		if ( doBling )
			WaitFrame()
	}
}

entity function CreateGunRangeTarget( entity ent, int type, bool autoReset, bool doBling )
{
	entity targetMover
	entity targetGeo
	vector anglesReady  = < 0, 0, 0 >
	vector anglesShot   = < 0, 0, 0 >
	float rotateDuration = 0.0
	float resetDuration = autoReset ? 3.0 : -1.0
	{
		vector origin = ent.GetOrigin()

		entity slideTarget = ent.GetLinkEnt()

		if ( type == eGunRangeTargetTypes.FOLDING )
		{
			//printt( "| Creating Gun Range Target (Folding) Realm:", realm )

			targetMover = CreateScriptMover_NEW( TARGET_MOVER_SCRIPTNAME, origin, ent.GetAngles() )

			origin = OffsetPointRelativeToVector( origin, < 26, 2, 0 >, ent.GetForwardVector() )
			targetGeo = CreatePropDynamic( TARGET_FOLDING_MODEL, origin, ent.GetAngles(), SOLID_OBB, 50000 )
			targetGeo.SetScriptName( FIRING_RANGE_TARGET_FOLD_SCRIPTNAME )

			entity collision = CreatePropDynamic( TARGET_FOLDING_MODEL, origin, ent.GetAngles(), SOLID_VPHYSICS, 50000 )
			collision.kv.collisionGroup = TRACE_COLLISION_GROUP_PLAYER

			//DispatchSpawn( collision )

			collision.SetParent( targetGeo )
			collision.Hide()

			anglesReady = targetMover.GetAngles()
			anglesShot = AnglesCompose( anglesReady, < -85, 0, 0 > )
			rotateDuration = 0.1

		}
		else if ( type == eGunRangeTargetTypes.SPINNING )
		{
			//printt( "| Creating Gun Range Target (Spinning) Realm:", realm )

			entity targetBase
				{
					targetBase = CreateScriptMoverModel( TARGET_SPINNING_BASE, origin, ent.GetAngles(), SOLID_VPHYSICS, 50000 )
				}

			//AddStagingCleanupEnt( targetBase )

			origin = OffsetPointRelativeToVector( origin, < 0, 0, 128 >, ent.GetForwardVector() )

			targetMover = CreateScriptMover_NEW( TARGET_MOVER_SCRIPTNAME, origin, ent.GetAngles() )
			targetMover.NonPhysicsSetRotateModeLocal( true )

				{
					targetGeo = CreatePropDynamic( TARGET_SPINNING_MODEL, origin, ent.GetAngles(), SOLID_OBB, 50000 )
				}	

			targetGeo.SetScriptName( FIRING_RANGE_TARGET_FLIP_SCRIPTNAME )

			entity collision

				{
					collision = CreatePropDynamic( TARGET_SPINNING_MODEL, origin, ent.GetAngles(), SOLID_VPHYSICS, 50000 )
				}			

			collision.kv.collisionGroup = TRACE_COLLISION_GROUP_PLAYER

			collision.SetParent( targetGeo )
			collision.Hide()
	
			anglesReady = targetMover.GetLocalAngles()
			anglesShot = AnglesCompose( targetMover.GetLocalAngles(), < 180, 0, 0 > )
			rotateDuration = 0.0

			if ( IsValid( slideTarget ) )
			{
				targetMover.SetParent( targetBase, "", true )

				// Save slideTarget to do Instant Speed Change upon speed change via a signal.
				sMovingTarget newMovingTarget = MovingTarget_Register( targetBase, slideTarget )
				thread MovingGunRangeTargetThink( newMovingTarget )
			}
			else // Not sliding target, so we don't need scripted base.
			{
				//targetBase.Destroy()
			}
		}

		Assert( IsValid( targetGeo ) )
		Assert( IsValid( targetMover ) )

		if ( doBling )
		{
			Highlight_SetNeutralHighlight( targetGeo, "staging_gun_range_target_appear" )
		}

		targetGeo.SetParent( targetMover, "", true )
		targetMover.SetPusher( true )

		AddEntityCallback_OnPostDamaged( targetGeo, StagingAreaEntity_OnDamaged )

		thread GunRangeTargetThink( targetGeo, targetMover, type, anglesReady, anglesShot, rotateDuration, resetDuration )
	}
	return targetGeo
}

sMovingTarget function MovingTarget_Register( entity targetBase, entity slideTarget )
{
	sMovingTarget newTarget
	newTarget.targetBase = targetBase
	newTarget.slideTarget = slideTarget
	newTarget.headedTowardEnd = true
	newTarget.start = targetBase.GetOrigin()
	newTarget.end = slideTarget.GetOrigin()

	return newTarget
}

void function StagingAreaEntity_OnDamaged( entity ent, var damageInfo )
{
	if ( !IsValid( ent ) )
		return

	if ( DamageInfo_GetDamage( damageInfo ) <= 0 )
		return

	entity attacker = DamageInfo_GetAttacker( damageInfo )
	int hitGroup = DamageInfo_GetHitGroup( damageInfo )
	table data
	data["attacker"] <- attacker
	data["hitgroup"] <- hitGroup

	ent.Signal( "GunRangeTargetDamaged", data )

	HandleLocationBasedDamage( ent, damageInfo )

	if ( attacker.IsPlayer() )
	{
		attacker.NotifyDidDamage(
			ent, DamageInfo_GetHitBox( damageInfo ),
			DamageInfo_GetDamagePosition( damageInfo ), DamageInfo_GetCustomDamageType( damageInfo ),
			DamageInfo_GetDamage( damageInfo ), DamageInfo_GetDamageFlags( damageInfo ),
			DamageInfo_GetHitGroup( damageInfo ), DamageInfo_GetWeapon( damageInfo ),
			DamageInfo_GetDistFromAttackOrigin( damageInfo )
		)
	}
}

void function GunRangeTargetThink( entity targetGeo, entity targetMover, int type, vector anglesReady, vector anglesShot, float rotateDuration, float resetDuration )
{
	int TargetHealth = 100 // 10000
	targetGeo.SetTakeDamageType( DAMAGE_EVENTS_ONLY )
	targetGeo.SetDamageNotifications( true )
	targetGeo.SetMaxHealth( 10000 )
	targetGeo.SetHealth( 10000 )

	EndSignal( targetGeo, "OnDestroy" )
	EndSignal( targetMover, "OnDestroy" )

	bool hasSkinnedTargets = false//Has_SkinnedTargets()

	vector readyPos =  targetMover.GetOrigin()
	vector anglesShotFromBack = AnglesCompose( anglesReady, < 85, 0, 0 > ) // fall the other way.

	while( true )
	{
		WaitFrame()
		table data = WaitSignal( targetGeo, "GunRangeTargetDamaged" )
		entity attacker = expect entity( data.attacker )

		if ( IsValid( attacker ) && attacker.IsPlayer() )
		{
			EmitSoundOnEntityExceptToPlayer( targetGeo, attacker, "Canyonlands_Scr_RangeTarget_Hit_3P" )
		}
		else
		{
			EmitSoundOnEntity( targetGeo, "Canyonlands_Scr_RangeTarget_Hit_3P" )
		}

		targetGeo.e.isDisabled = true
		if ( rotateDuration > 0 )
		{
			vector collapsePos = targetMover.GetOrigin()
			vector anglesShotToUse = anglesShot
			if( IsValid( attacker ) )
			{
			 	vector ToAttacker = attacker.GetOrigin() - targetMover.GetOrigin()
				ToAttacker.z = 0
				if( DotProduct( ToAttacker, targetMover.GetForwardVector() ) < 0 )
				{
					// Slighter angle collapse and upward displacement if shot from behind to prevent clipping.
					anglesShotToUse = anglesShotFromBack
					collapsePos = collapsePos + < 0, 0, 11 > // Shift up slightly so target doesn't clip.
				}
			}
			targetMover.NonPhysicsRotateTo( anglesShotToUse, rotateDuration, 0.0, 0.0 )
			targetMover.NonPhysicsMoveTo( collapsePos, rotateDuration, 0.0, 0.0 )
			wait rotateDuration
		}
		else
		{
                      
				//if( hasSkinnedTargets )
					//thread Target_Do_HitSkin_Thread( targetGeo, data  )
				//else
					targetMover.SetLocalAngles( anglesShot )
        
                                            
               
                            
		}

		if(( type == eGunRangeTargetTypes.SPINNING ))
		{
			EmitSoundOnEntity( targetGeo, "Canyonlands_Scr_RangeTarget_Spin" )
		}

		if ( resetDuration < 0 )
			return

                     
			//if( !Has_SkinnedTargets() )
				wait resetDuration
       
                     
        

		if(( type == eGunRangeTargetTypes.SPINNING ))
		{
			EmitSoundOnEntity( targetGeo, "Canyonlands_Scr_RangeTarget_Spin" )
		}

		if ( rotateDuration > 0 )
		{
			targetMover.NonPhysicsRotateTo( anglesReady, rotateDuration, 0.0, 0.0 )
			targetMover.NonPhysicsMoveTo( readyPos, rotateDuration, 0.0, 0.0 )
			wait rotateDuration
		}
		else
		{
			{
				targetMover.SetLocalAngles( anglesReady )
				WaitFrame()
			}
		}

		targetGeo.e.isDisabled = false
	}
}


void function MovingGunRangeTargetThink( sMovingTarget movingTarget )
{
	if( !IsValid( movingTarget ) )
		return

	if( !IsValid( movingTarget.targetBase ) )
		return

	if( !IsValid( movingTarget.slideTarget ) )
		return

	OnThreadEnd(
		function() : ( movingTarget )
		{
			// Space intentionally left in case there is cleanup needed later.
		}
	)

	Signal( movingTarget.targetBase, "SlideTargetWaitForReset" )
	EndSignal( movingTarget.targetBase, "SlideTargetWaitForReset", "OnDestroy" )
	EndSignal( movingTarget.slideTarget, "OnDestroy" )

	thread MovingGunRangeTargetMove( movingTarget, true )
	
	while( true )
	{
		WaitSignal( movingTarget.targetBase, "SlideTargetSpeedReset" )
		WaitFrame()
		thread MovingGunRangeTargetMove( movingTarget, false )
	}
}

bool function HasPlaylistVarVariableSpeedTargets()
{
	return( GetCurrentPlaylistVarBool( "has_variable_speed_targets", true ))
}

void function MovingGunRangeTargetMove( sMovingTarget movingTarget, bool initStartPos = true )
{
	if( !IsValid( movingTarget ) )
		return

	if( !IsValid( movingTarget.targetBase ) )
		return

	if( !IsValid( movingTarget.slideTarget ) )
		return

	Signal( movingTarget.targetBase, "SlideTargetThinkStart" )
	EndSignal( movingTarget.targetBase, "SlideTargetThinkStart", "OnDestroy" )
	EndSignal( movingTarget.slideTarget, "OnDestroy" )

	// Grab the info from the struct.
	vector start = movingTarget.start
	vector end = movingTarget.end

	float moveDuration
	float accelDecel = moveDuration * 0.25

	WaitFrame()

	// Randomly flip the starting direction for variety
	if( initStartPos )
	{
		if( CoinFlip() )
		{
			movingTarget.headedTowardEnd = false
			movingTarget.targetBase.SetOrigin( end )
		}

		// Wait random time so all targets aren't in sync
		wait RandomFloat( 1.5 )
	}

                          
		//If we're in training, this value isn't in the map, but is needed down the road
		if ( !(eFRSettingType.TARGETSPEED in frIntSettings_Defaults) )
		{
			frIntSettings_Defaults	[ eFRSettingType.TARGETSPEED ] 		<- 2
		}

		// Actual speeds desired, in units/sec.,
		table< int, float > targetSpeedsActual
		targetSpeedsActual[ 0 ] <- 80
		targetSpeedsActual[ 1 ] <- 80
		targetSpeedsActual[ 2 ] <- 200
		targetSpeedsActual[ 3 ] <- 300
		targetSpeedsActual[ 4 ] <- 600

		// TODO: Stop Previous sound and do new appropriate sound
		/*
		FiringRangeMu1_Emit_TargetConveyor_CrouchWalk
		FiringRangeMu1_Emit_TargetConveyor_Run
		FiringRangeMu1_Emit_TargetConveyor_Walk
		FiringRangeMu1_Emit_TargetConveyor_Zipline
		*/
		table< int, string > targetSpeedSounds
		targetSpeedSounds[ 0 ] <- "FiringRangeMu1_Emit_TargetConveyor_CrouchWalk"
		targetSpeedSounds[ 1 ] <- "FiringRangeMu1_Emit_TargetConveyor_CrouchWalk"
		targetSpeedSounds[ 2 ] <- "FiringRangeMu1_Emit_TargetConveyor_Walk"
		targetSpeedSounds[ 3 ] <- "FiringRangeMu1_Emit_TargetConveyor_Run"
		targetSpeedSounds[ 4 ] <- "FiringRangeMu1_Emit_TargetConveyor_Zipline"

		float distance
		vector destination

		while( true )
		{
			int targetSpeedNDX = 1//FRSetting_TargetSpeed_Get( realm )
			destination = movingTarget.headedTowardEnd ? end : start
			distance = Distance2D( movingTarget.targetBase.GetOrigin(), destination )
			if( distance > 0 )
			{
				// UPDATE SOUND BEING PLAYED.
				if( movingTarget.soundfx != targetSpeedSounds[ targetSpeedNDX ] )
				{
					if( movingTarget.soundfx != "" )
					{
						StopSoundOnEntity( movingTarget.targetBase, movingTarget.soundfx )
					}
					movingTarget.soundfx = targetSpeedSounds[ targetSpeedNDX ]
					EmitSoundOnEntity( movingTarget.targetBase, movingTarget.soundfx )
				}

				moveDuration = distance / targetSpeedsActual[ targetSpeedNDX ]
				movingTarget.targetBase.NonPhysicsMoveTo( destination, moveDuration , accelDecel, accelDecel )
				wait moveDuration
			}
			movingTarget.headedTowardEnd = !movingTarget.headedTowardEnd
		}    
}

// ==================================================
//					MAP PROPS
// ==================================================

entity function CreateFRButton(vector pos, vector ang, string prompt)
{
	entity button = CreateEntity("prop_dynamic")
	button.kv.solid = 6
	button.SetValueForModelKey($"mdl/props/global_access_panel_button/global_access_panel_button_console_w_stand.rmdl")
	button.SetOrigin(pos)
	button.SetAngles(ang)
	DispatchSpawn(button)
	button.SetUsable()
	button.SetUsableByGroup("pilot")
	button.SetUsePrompts(prompt, prompt)
	return button
}

void function SpawnMapProps()
{
	// BUTTONS
	{
		entity third = CreateFRButton(<35757.1289, -7238.68506, -28342.2422>, <0,270,0>, "%&use% TOGGLE THIRDPERSON")
		AddCallback_OnUseEntity( third, void function(entity panel, entity user, int input)
		{
			EmitSoundOnEntityOnlyToPlayer( user, user, FIRINGRANGE_BUTTON_SOUND )

			if ( user.IsThirdPersonShoulderModeOn() )
				user.SetThirdPersonShoulderModeOff()
			else
				user.SetThirdPersonShoulderModeOn()
		})

		entity ammo = CreateFRButton(<31457.6055, -4903.65918, -29222.959>, <0,-45,0>, GetInfiniteAmmoText(firingrange_infinite_ammo))
		AddCallback_OnUseEntity( ammo, void function(entity panel, entity user, int input)
		{
			EmitSoundOnEntityOnlyToPlayer( user, user, FIRINGRANGE_BUTTON_SOUND )

			if(firingrange_infinite_ammo == 0) firingrange_infinite_ammo = 1
			else if(firingrange_infinite_ammo == 1) firingrange_infinite_ammo = 2
			else firingrange_infinite_ammo = 0

			foreach(entity weapon in GetEntArrayByClass_Expensive("weaponx"))
				FixWeapon(weapon)

			string prompt = GetInfiniteAmmoText(firingrange_infinite_ammo)
			panel.SetUsePrompts(prompt,prompt)
		})

		entity target = CreateFRButton(<31446.1016, -7281.54932, -29235.9824>, <0,270,0>, GetTrainingTargetMovementText(file.training_mov))
		AddCallback_OnUseEntity( target, void function(entity panel, entity user, int input)
		{
			EmitSoundOnEntityOnlyToPlayer( user, user, FIRINGRANGE_BUTTON_SOUND )
			if(file.training_mov == <1,1,0>)
				file.training_mov = <1,0,0>
			else if(file.training_mov == <1,0,0>)
				file.training_mov = <0,1,0>
			else
				file.training_mov = <1,1,0>

			string prompt = GetTrainingTargetMovementText(file.training_mov)
			panel.SetUsePrompts(prompt,prompt)
		})

		entity speed = CreateFRButton(<31672.3145, -8201.04395, -29235.9824>, <0,270,0>, "%&use% Speed: ("+file.trackingTraining_speed+")")
		AddCallback_OnUseEntity( speed, void function(entity panel, entity user, int input)
		{
			EmitSoundOnEntityOnlyToPlayer( user, user, FIRINGRANGE_BUTTON_SOUND )
			if(file.trackingTraining_speed == -1)
			{
				file.trackingTraining_speedRand = false
				file.trackingTraining_speed = 86.75
			}
			else if(file.trackingTraining_speed == 86.75) file.trackingTraining_speed = 147.48
			else if(file.trackingTraining_speed == 147.48) file.trackingTraining_speed = 173.5
			else if(file.trackingTraining_speed == 173.5) file.trackingTraining_speed = 260
			else if(file.trackingTraining_speed == 260)	file.trackingTraining_speed = 300
			else if(file.trackingTraining_speed == 300)	file.trackingTraining_speed = 400
			else if(file.trackingTraining_speed == 400)	file.trackingTraining_speed = 500
			else if(file.trackingTraining_speed == 500)
			{
				file.trackingTraining_speedRand = true
				file.trackingTraining_speed = -1
			}

			string prompt = "%&use% Speed: ("+(file.trackingTraining_speedRand ? "RAND" : string(file.trackingTraining_speed))+")"
			panel.SetUsePrompts(prompt,prompt)
		})
	}
}

string function GetTrainingTargetMovementText(vector range)
{
	string s = "%&use% Target Movement\n               "
	if(range.x > 0 && range.y > 0)
		return s+"X | Y | (XY)"
	else if(range.x > 0)
		return s+"(X) | Y | XY"
	else
		return s+"X | (Y) | XY"

	unreachable
}

string function GetInfiniteAmmoText(int number)
{
	string s = "%&use% Ammo Style\n               "
	if(number > 1)
		return s+"INFINITE RESERVE"
	else if(number == 1)
		return s+"INFINITE MAGS"
	else
		return s+"INVENTORY"

	unreachable
}

void function TeleportFRPlayer(entity player, vector pos, vector ang)
{
	if (IsValid(player) && IsAlive(player) && player.IsPlayer())
	{
		player.SetOrigin(pos)
		player.SetAngles(ang)
		EmitSoundOnEntityOnlyToPlayer( player, player, "PhaseGate_Enter_1p" )
		EmitSoundOnEntityExceptToPlayer( player, player, "PhaseGate_Enter_3p" )
	}
}

entity function CreateFRProp(asset a, vector pos, vector ang, bool mantle = false, float fade = 2000)
{

	entity e = CreatePropDynamic(a,pos,ang,SOLID_VPHYSICS,15000)
	e.kv.fadedist = fade
	if(mantle) e.AllowMantle()
	return e
}

void function SpawnDoors_Init()
{
	entity button = CreateFRButton(file.doorResetButton_pos, file.doorResetButton_ang, "%&use% RESPAWN DOORS")
	AddCallback_OnUseEntity( button, void function(entity panel, entity user, int input)
	{
		EmitSoundOnEntityOnlyToPlayer( user, user, FIRINGRANGE_BUTTON_SOUND )
		SpawnDoors()
	})

	SpawnDoors()
}

void function SpawnDoors()
{
	foreach(entity door in file.doors)
	{
		if(IsValid(door))
			door.Destroy()
	}
	file.doors.clear()

	entity singleDoor = CreateEntity("prop_door")
	singleDoor.SetValueForModelKey(FIRINGRANGE_DOOR_ASSET)
	singleDoor.SetOrigin(file.doorSingle_pos)
	singleDoor.SetAngles(file.doorSingle_ang)
	DispatchSpawn(singleDoor)

	float offset

	entity ddl = CreateEntity("prop_door")
	ddl.SetValueForModelKey(FIRINGRANGE_DOOR_ASSET)
	ddl.SetAngles(file.doorDouble_ang)
	ddl.SetOrigin(file.doorDouble_pos + ddl.GetRightVector() * 60)
	DispatchSpawn(ddl)

	entity ddr = CreateEntity("prop_door")
	ddr.SetValueForModelKey(FIRINGRANGE_DOOR_ASSET)
	ddr.SetAngles(file.doorDouble_ang + <0,180,0>)
	ddr.SetOrigin(file.doorDouble_pos + ddr.GetRightVector() * 60)
	ddr.LinkToEnt( ddl )
	DispatchSpawn(ddr)

	file.doors.append(singleDoor)
	file.doors.append(ddl)
	file.doors.append(ddr)
}

void function OnWeaponAttack( entity player, entity weapon, string weaponName, int ammoUsed, vector attackOrigin, vector attackDir )
{
	FixWeapon(weapon)
}

void function FixWeapon(entity weapon)
{
	/*try
	{
		switch(firingrange_infinite_ammo)
		{
			case 0:
				if(!weapon.HasMod( "survival_finite_ammo" )) weapon.AddMod( "survival_finite_ammo")
				break
			case 1:
				weapon.SetWeaponPrimaryClipCount(weapon.GetWeaponPrimaryClipCountMax())
			default:
				if(weapon.HasMod( "survival_finite_ammo" )) weapon.RemoveMod( "survival_finite_ammo")
				break
		}
	}
	catch(error){}*/
}
#endif





#if(false)




































//





//


//











//


//


































































































#endif //

#if(CLIENT)

void function IntroDisplayThread()
{
	thread function() : ()
	{
		FlagWait( "EntitiesDidLoad" )
		wait 3.0

		entity viewPlayer = GetLocalViewPlayer()
		if ( IsValid( viewPlayer ) )
			MapZones_ZoneIntroText( viewPlayer, ("#" + GetMapName()), -1 )
	}()
}
#endif //


#if(false)



//













//



//
//








//












//










//










//

























#endif //
