global function PIN_Init
global function PIN_ItemPickup
global function PIN_GameStart
global function PIN_PlanePath
global function PIN_SetGameStartTime
global function PIN_GameStartedForPlayer
global function PIN_CircleLocation
global function GameSummary_GetPlayerData
global function PIN_RoundEnd
global function PIN_GameEnd
global function PIN_AddPlayer
global function PIN_PlayerLeft
global function PIN_PlayerSpawned
global function PIN_PlayerDowned
global function PIN_PlayerRevived
global function PIN_PlayerKilled
global function PIN_DamageDone
global function PIN_DamageDoneToPlayerForWeapon
global function PIN_PlayerEquip
global function PIN_PlayerUse
global function PIN_PlayerOutResource
global function PIN_Interact
global function PIN_PlayerAbility
global function PIN_PlayerAbilityReady
global function PIN_AddToPlayerCountStat
global function PIN_OnWeaponAttack
global function PIN_Ping
global function PIN_OnPlayerHealed
global function PIN_PlayerLandedOnGround
global function PIN_PlayerJumpedFromPlane
global function PIN_Training

///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////

global const LOG_ERRORS = true




//do not edit below this line


// ╔══════╗
// ║ mkos ║
// ╚══════╝
// SHARED GLOBAL //TODO: Reduce repeat declares between tracker/non tracker

global function g__InternalCheckReload //todo: move somewhere ideal
global function SavePlayerData
global function Tracker_FetchPlayerData
global function Tracker_SavePlayerData
global function SetAfkToRest
global function ArrayRemoveBot //todo move to code
global function ClientCommand_RequestStat
global function Tracker_SetStartLog

#if TRACKER
	global const bool STUB = false
#else
	global const bool STUB = true 
#endif 

#if STUB
	
	//flags
	global function bAfkToRest
	global function bGlobalStats
	global function bLog
	global function bEnc
	
	global struct GameSummarySquadData 
	{
		string uid
		int kills
		int damageDealt
		int survivalTime
		int revivesGiven
		int respawnsGiven
		int deaths 
	}
	
	//shared
	global function bBotEnabled
	global function IsBotEnt //needs to go
	global function SendServerMessage
	global function Tracker_GetCurrentEventByPlayerHandle_expensive
	global function Tracker_GetCurrentEventForAttackerOnVictim
	
	//utility 
	global function Tracker_IsRestrictedServer
	global function Tracker_SetRestrictedServer
	global function Tracker_BuildAllPlayerMetrics
	global function Tracker_GetStartUnixTime
	
	#if !HAS_TRACKER_DLL
		global function sqprint
		global function sqerror
	#endif
	
	global struct DamageEvent 
	{
		int weaponSource
		array<int> weaponOrder
		
		int attackerHandle //encoded ehandle
		int victimHandle
		
		int hitCount
		float bulletsHit
		float damage
		int headshots
		float actionTimestamp
		int lastWeaponSource
		float lastHitTimestamp
		
		bool isNew
		float shotIdentifier
		bool isValid = false
	};
	
#endif
///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////






// ██████  ███████ ██████     ██████  ███████ ██    ██     ████████ ██████   █████   ██████ ██   ██ ███████ ██████ 
// ██   ██ ██      ██   ██    ██   ██ ██      ██    ██        ██    ██   ██ ██   ██ ██      ██  ██  ██      ██   ██ 
// ██████  ███████ ██████     ██   ██ █████   ██    ██        ██    ██████  ███████ ██      █████   █████   ██████  
// ██   ██      ██ ██   ██    ██   ██ ██       ██  ██         ██    ██   ██ ██   ██ ██      ██  ██  ██      ██   ██ 
// ██   ██ ███████ ██   ██ ██ ██████  ███████   ████          ██    ██   ██ ██   ██  ██████ ██   ██ ███████ ██   ██ 
// r5r.dev by mkos


//Todo: Remove custom tracker logic from pin files and make standalone. Restore pin stubs.
typedef SerializedData string

#if TRACKER
global function CodeCallback_BatchStatsLoaded
global function CodeCallback_PlayerStatsReady
global function CodeCallback_VerifyEaAccount

global function AddCallback_OnBatchStatsLoaded
global function RemoveCallback_OnBatchStatsLoaded
global function AddCallback_PlayerDataFullyLoaded
global function AddCallback_PlayerData

global function Tracker_IsBatchStatsLoaded
global function Tracker_GetCurrentEventByPlayerHandle_expensive
global function Tracker_GetCurrentEventForAttackerOnVictim
global function Tracker_IsPlayerMetricsInitialized
global function Tracker_BuildAllPlayerMetrics
global function Tracker_GetPlayerMetricsArray
global function Tracker_GetPlayerLeftFlag
global function Tracker_RegisterStat
global function Tracker_RegisterAllSettings
global function Tracker_StatsMetricsByUID
global function Tracker_EndFight
global function Tracker_AddDamageEventsToDeleteQueue
global function Tracker_StatLocalAllowed
global function Tracker_IgnoreResync

global function __TrackerStatsHook_Damage

global function GetDefaultLock1v1Setting //todo deprecate
global function GetDefaultEnableInputBannerSetting //todo deprecate

///////////////////////////// QUERIES ////////////////////////////////////////////
// usage=   AddCallback_QueryString("category:query", resultHandleFunction )	//
// 			see r5r.dev/info for details about available categories.		 	//
// 			verfified hosts: Add custom queries from host cp				 	//
//																				//
//			EX: restricted_rank:500   returns minimum player score for var "500"//
//////////////////////////////////////////////////////////////////////////////////
global function Tracker_QueryInit
global function AddCallback_QueryString
//For getting settings via query system by key.  (todo: rework)
global function Tracker_GetQueryString
global function Tracker_GetQueryFloat
global function Tracker_GetQueryInt
global function Tracker_GetQueryBool

global function Tracker_SetPlayerAsChampion
global function Tracker_GetMaxWaitForBatchLoad
global function Tracker_Credits //not used
global function Tracker_IsBatchFetchQueued
global function Tracker_IsRestrictedServer
global function Tracker_SetRestrictedServer
global function Tracker_SetForceUpdatePlayerData
global function Tracker_GetStartUnixTime

//Todo: port to indev 
global function Tracker_SetShouldShip

global function Tracker_ReturnSuperglides
global function Tracker_ReturnKills
global function Tracker_ReturnDeaths
global function Tracker_ReturnDamage
global function Tracker_ReturnChampion
global function Tracker_ReturnShots 
global function Tracker_ReturnHits

global function bAfkToRest  //todo deprecate
global function bGlobalStats //todo deprecate
global function bLog //todo deprecate
global function bEnc //todo deprecate

global function __executeEventStart_messages
global function GetMessageBotEnt //todo move to code
global function IsBotEnt //todo move to code
global function SendServerMessage //todo move to code
global function bBotEnabled //todo move to code
global function isIntervalThreadRunning //todo rename
global function UpdateStartInRestSetting //move

global function NULL_PDATA
global function Gamemode1v1_PlayerDataCallbacks //TODO: this probably shouldn't be here, but a bit of logic needs sorted into it's gamemode file (will do soonTM)

const DEBUGDMG = false
#if DEVELOPER
	global function DEV_GetPlayerMetricsIndexByUID
	global function DEV_SetMetricSafe
	
	#if DEBUGDMG
		global function DEV_DamageInfo
	#endif
#endif

global function DEV_StartIntervalThread
global function DEV_ManualLogStart
global function DEV_ManualLogKill
global function LogError
global function GetTrackerErrorArray

const int 	MAX_SECONDS_WAIT_FOR_BATCH_LOAD 	= 5
const float MAX_FIGHT_HISTORY_TIME 				= 20
const float MAX_WAIT_FOR_LOGGING_THREAD 		= 10 //5 seconds
const float DAMAGE_LOOKBACK_TIME_WINDOW 		= 20.0
const int 	MAX_SAY_MSG 						= 255
const int 	RESTRICTED_ACCESS_STATUS_REQUIRED 	= 7 // refer to CheckIfPlayerHasAccess()
const int 	REQUIRED_SYNC_DATA_FIELDS 			= 1  //amount of fields returned by stats the scripts require (non-settings values)
const float TRACKER_VERSION 					= 2.1

const array<string> SERVER_MSG_EVENT_TYPES = 
[
	"start",
	"end"		
]
	

//(respawns) game summary
global struct GameSummarySquadData
{
	string uid
	int kills
	int damageDealt
	int survivalTime
	int revivesGiven
	int respawnsGiven
	int deaths
}

global struct DamageEvent 
{
    int weaponSource
	array<int> weaponOrder
	
	int attackerHandle //encoded ehandle
	int victimHandle
	
    int hitCount
    float bulletsHit
    float damage
	int headshots
	float actionTimestamp
	int lastWeaponSource
	float lastHitTimestamp = 0
	
	bool isNew
	float shotIdentifier
	bool isValid = false	
}

typedef SettingsTable table< string, string >
struct PlayerSettings 
{
	string uid 
	SettingsTable settings
}
typedef PlayerSettingsUpdate array< PlayerSettings >
typedef UpdateFunc void functionref( table < string, SettingsTable > )
typedef SyncFunc void functionref( PlayerSettingsUpdate )
typedef AppendFunc void functionref( string )
typedef CheckFunc bool functionref( string, string  )
typedef SerializeFunc string functionref( PlayerSettingsUpdate )
typedef InstanceFunc PlayerSettings functionref( string, SettingsTable )
typedef SaveSettingsFunc void functionref( string, table<string, string >, bool )
typedef RegisterShipFunc void functionref( void functionref( string ), bool = false )
typedef RunShipFunc void functionref( string )

global struct Tracker
{
	array< string > settingsArr
	array< void functionref( string ) > shipFunctions
	table< void functionref( string ), bool > shipFunctionsWhen
	
	UpdateFunc 			update	
	SyncFunc 			_updateSettingsPlayers
	AppendFunc 			appendSetting
	CheckFunc 			check
	SerializeFunc 		serialize
	InstanceFunc 		settingsInstance
	SaveSettingsFunc	SavePlayerData
	RegisterShipFunc	RegisterShipFunction
	RunShipFunc			RunShipFunctions
} 
global Tracker tracker

struct DeleteEvents 
{
	int victim_handle
	int attacker_handle	
	float fightEndTime
}

//verify struct
struct PlayerVerifyCount 
{
    string playerID
    int verifyCount
}

// array of player structs containing various new metrics
struct PlayerMetrics 
{
    string playerID
	string playername
	entity ent
	
    array<float> JumpTimestamps //internal only
    table<int, array< float > > WeaponShotsTimestamps //internal only
	array<float> SuperglideTimestamps //internal only
	
	int kills
	int deaths
	float damage
	int shots
	int hits

	bool hadleft = false
	bool playerleft = false
	bool ignore_sync_flag = false
	
	bool previous_champion = false	
	int previous_score = 0
	
	bool isValid
};

//tables
table< string, bool > PlayerDidJump
table< string, int > PlayerIdMap

//script arrays
array< DamageEvent > allDamageEvents
table< int, DamageEvent > allDamageEventsMap = {}
array< PlayerMetrics > PlayerMetricsArray
array< PlayerVerifyCount > playerVerifyCounts
array< DeleteEvents > DeleteEventTaskList // queue for managing event deletion //TODO rework

#if SERVER   
bool function Logging_ShipStats() 				{ return GetCurrentPlaylistVarBool("logging_shipstats", false) }
bool function Enable_CC_Administration() 		{ return GetCurrentPlaylistVarBool("cc_administration", false) }
bool function Ea_Verify_Server()				{ return ( GetConVarInt( "sv_onlineAuthEnable" ) == 1 && GetCurrentPlaylistVarBool( "ea_verify_server", false ) ) }
#endif

struct PlayerData 
{
	string playerUID 
	string playerName 
};

enum eLogState 
{ 
    READY = 1,
    BUSY = 2,
	SAFE = 3	
} 

struct //Todo: move appropriate to tracker.var 
{
	table< int, PlayerData > HandleToPlayerData
	
	//queries 
	bool bQueryComplete = false
	table <string, array<void functionref( string retData )> > queryStringInitFuncs
	table <string, array<void functionref( string retData )> > queryStringCallbackFuncs
	table <string,string> Global_R5RDEV_StringSettings
	table <string,float> Global_R5RDEV_FloatSettings
	table <string,int> Global_R5RDEV_IntSettings
	table <string,bool> Global_R5RDEV_BoolSettings
	
	table<string, array<void functionref( entity player, string data )> > PlayerSettingsMap = {}
	table<string, table<string,string> > PlayerData = {}// playerUID = setting,value
	array<void functionref( entity player ) > syncDataFullyLoadedCallbacks = []
	table<string, array< void functionref(entity player) > > registeredStatCallbackFuncs = {}
	array<void functionref() > batchStatsLoadedCallbacks = []
	array<string> statsLocalAllowed
	
	string requestedStatsList = ""
	string requestedSettingsList = ""
	bool _registerAllSettings = false
	float maxWaitForBatchLoad
	
	int fightIdCounter = 0
	bool PIN_GameState_Start = false
	bool global_stats

	bool LogOn = false
	bool LogE = true
	bool scriptLogthreadRunning = false
	bool restricted_server
	bool bSyncedGlobal
	bool bSafeLog = true
	bool bShouldShip = false
	bool bCheckShip
	bool update_discord_player_counts
	bool gamemode_type_1v1 // tell stat calculations only one attacker
	bool afk_to_rest_enabled = true // bool to reflect state of cc (chat command) cc afk 1/0
	bool superglideDetect = false
	bool bBatchFetchInit = false
	bool bForceUpdatePlayerData = false
	bool bStatsShipped = false 
	bool stats_discord_webhook_matches_enabled
	bool bClientCommandAdminEnabled
	
	bool sg_counter_msg
	float FS_MaxHealth
	int ibmm_wait_limit

	string DISCORD_PLAYERS_WEBHOOK
	string DISCORD_MATCHES_WEBHOOK
	string superglide_msg
	string superglidetitle
	
	// Server MOTD
	bool bMotdEnabled = false
	bool bUseOnlineMOTD = false
	string localFlowstate_MOTD = "" //configure in playlist.
	string onlineMOTD = ""
	
	// Chatbot Messages
	array<string> BotAllowedModes = [ "fs_1v1", "fs_lgduels_1v1", "fs_scenarios", "fs_dm", "fs_haloMod", "fs_movementrecorder", "fs_realistic_ttv" ]
	bool bBotAllowed
	bool bChatbotEnabled
	bool bIntervalThreadRunning
	int iLoopMessagesTime
	
	string sBotName
	int iBotID
	entity entityBotEnt
	
	table < int, array<string> > MessageEvents
	array<string> Messages_EventStart
	array<string> Messages_EventEnd
	array<string> arrayLoopMessages = []
	
	bool DefaultLock1v1Setting
	bool DefaultEnableInputBannerSetting
	bool DefaultStartInRestSetting
	
	int flowstateRoundtime
	int launchStartUnixTime
	
	//restricted settings ( configure in playlists file )
	array< string > whitelist
	int restricted_gamesplayed = 0
	int restricted_kills = 0
	int restricted_playtime = 0
	int restricted_rank = 0
	float restricted_kd = 0.0
	string restricted_join_message = "You are able to play on this restricted server."
	string restricted_whitelist_message = "You are whitelisted to play on this restricted server."
	string restricted_admin_message = "You are an admin."
	
	table<int,float> DamagePerBullet = {}
	table<int,int> SpecialWeaponsBulletsPerShot = {}
	
	//debug 
	array<string> errorArray
	
	#if DEVELOPER
		var damageInfo 
	#endif
	
} file

void function __internals()
{
	tracker.serialize				= __t_serial
	tracker.settingsInstance 		= __t_settings
	tracker.check 					= __t_check
	tracker.appendSetting 			= __t_append
	tracker.update					= __t_update
	tracker._updateSettingsPlayers 	= __t_sync	
	tracker.SavePlayerData			= __t_set
	tracker.RegisterShipFunction	= __t_reg
	tracker.RunShipFunctions		= __t_runship
}

PlayerSettings function __t_settings( string uid, SettingsTable settingsData )
{
	PlayerSettings playerSettingsData
	
	playerSettingsData.uid 			= uid 
	playerSettingsData.settings  	= settingsData
		
	return playerSettingsData
}

bool function __t_check( string _setting, string _value )
{
	return tracker.settingsArr.contains( _setting ) && IsSafeString( _value )
}

void function __t_append( string _setting )
{
	if( tracker.settingsArr.contains( _setting ) )
		mAssert( false, "Tried to add same setting twice: \"" + _setting + "\"" )
		
	if( !IsSafeString( _setting ) )
		mAssert( false, "Invalid characters in setting." )
		
	tracker.settingsArr.append( _setting )
}

void function __t_update( table< string, SettingsTable > playersToUpdate )
{
	PlayerSettingsUpdate update
	{
		foreach( string uid, SettingsTable settingsTbl in playersToUpdate )
			update.append( tracker.settingsInstance( uid, settingsTbl ) )
	}
	
	if( update.len() )
		tracker._updateSettingsPlayers( update )
}

void function __t_sync( PlayerSettingsUpdate update )
{
	__UpdateLiveStats_internal( tracker.serialize( update ) )
}

void function __t_set( string uid, SettingsTable settingsTbl, bool sync )
{
	if( empty( uid ) )
		mAssert( false, "Tried to set empty uid" )
	
	foreach( string setting, string value in settingsTbl )
		Tracker_SavePlayerData( uid, setting, value )
		
	table< string, SettingsTable > tbl 
	tbl[ uid ] <- settingsTbl
	
	if( sync )
		tracker.update( tbl )
}

void function __t_reg( void functionref( string ) callbackFunc, bool bRunOnDisconnect = false )
{
	if( tracker.shipFunctions.contains( callbackFunc ) )
	{
		mAssert( false, "Tried to add callbackFunc " + string( callbackFunc ) + " but already exists in shipFunctions" )
		return 
	}
	
	if( bRunOnDisconnect )
		tracker.shipFunctionsWhen[ callbackFunc ] <- true
	else 
		tracker.shipFunctionsWhen[ callbackFunc ] <- false
		
	tracker.shipFunctions.append( callbackFunc )
}

void function __t_runship( string uid )
{
	foreach( callback in tracker.shipFunctions )
		callback( uid )
}

void function __t_runshipDisconnect( string uid )
{
	foreach( callback in tracker.shipFunctions )
	{
		if( tracker.shipFunctionsWhen[ callback ] == true )
			callback( uid )
	}
}

void function ShipFunction_OnDisconnected( entity player )
{
	if( !IsValid_ThisFrame( player ) )
		return //should always still be valid tbh
		
	__t_runshipDisconnect( player.p.UID )
}


void function CodeCallback_BatchStatsLoaded()
{
	svGlobal.levelEnt.Signal( "BatchFetchComplete" ) //Todo: This should be a flag.
	
	#if DEVELOPER
		printt( "CodeCallback_BatchStatsLoaded" )
	#endif
	
	foreach( callbackFunc in file.batchStatsLoadedCallbacks )
		callbackFunc()
}

bool function Tracker_IsBatchStatsLoaded()
{
	return expect bool( GetServerVar( "batch_fetch_complete" ) )
}

void function AddCallback_OnBatchStatsLoaded( void functionref() callbackFunc )
{
	mAssert( !file.batchStatsLoadedCallbacks.contains( callbackFunc ), "Tried to add callback func " + string( callbackFunc ) + "() to batchStatsLoadedCallbacks but already exists" )
	file.batchStatsLoadedCallbacks.append( callbackFunc )
}

void function RemoveCallback_OnBatchStatsLoaded( void functionref() callbackFuncToRemove )
{
	mAssert( file.batchStatsLoadedCallbacks.contains( callbackFuncToRemove ), "Tried to remove callback func " + string( callbackFuncToRemove ) + "() from batchStatsLoadedCallbacks but it does not exist in this array" )
	file.batchStatsLoadedCallbacks.fastremovebyvalue( callbackFuncToRemove )
}

void function CodeCallback_PlayerStatsReady( string uid )
{
	if( empty( uid ) )
	{
		#if DEVELOPER 
			Warning( "Player uid was empty in " + FUNC_NAME() + "()" )
		#endif
		
		return
	}
	
	entity player = GetPlayerEntityByUID( uid )
	
	if( !IsValid( player ) )
		return
		
	player.Signal( "PlayerStatsReady" )	
	
	#if DEVELOPER
		printt( "CodeCallback_PlayerStatsReady:", player )
	#endif
}

array<PlayerMetrics> function Tracker_GetPlayerMetricsArray()
{
	return PlayerMetricsArray
}

void function DEV_ManualLogStart()
{
	FlagSet( "START_LOG" )
	thread __CONTROLLED_LogInit()
}

void function DEV_ManualLogKill( bool ship )
{
	if( ship )
	{
		LogEvent__internal( Tracker_BuildAllPlayerMetrics( true ), file.LogE )
		__UpdateMetricsNow()
	}
	
	#if LOG_ERRORS
		DEV_WriteAllTrackerErrors()
		#if DEVELOPER 
			Tracker_BuildAllPlayerMetrics(false) //console
		#endif 
	#endif 
	
	file.PIN_GameState_Start = false
	svGlobal.levelEnt.Signal( "TrackerNoLog" )
	stopLogging__internal( ship )
}

void function NULL_PDATA( entity player, string data ){}

#if DEVELOPER
	const table<string,string> PLAYER_METRICS_EXPECT =
	{
		[ "playerID" ] 				= "string",
		[ "playername" ] 			= "string",
		[ "ent" ]					= "entity",
		[ "kills" ] 					= "int",
		[ "deaths" ] 				= "int",
		[ "damage" ] 				= "float",
		[ "previous_champion" ] 		= "bool",
		[ "playerleft" ] 			= "bool",
		[ "ignore_sync_flag" ] 		= "bool"
	}

	bool function DEV_SetMetricSafe( string uid, string metricKey, ... )
	{
		if( !( metricKey in PLAYER_METRICS_EXPECT ) )
		{
			Warning( "Key \"" + metricKey + "\" does not exist in PlayerMetrics struct." )
			return false
		}
		
		if( vargc < 1 )
			return false
		
		string expected = PLAYER_METRICS_EXPECT[ metricKey ]
		string dataType = typeof vargv[ 0 ]
		
		if( dataType != expected )
		{
			Warning( "Datatype (" + dataType + ") passed to " + FUNC_NAME() + "() for key \"" + metricKey + "\" does not match expected type of: (" + expected + ")" )
			return false
		}
		
		var data = vargv[0]
		
		switch( metricKey )
		{		
			case "playerID":
				Tracker_StatsMetricsByUID( uid ).playerID = expect string( data )
				return true 
			case "playername":
				Tracker_StatsMetricsByUID( uid ).playername = expect string( data )
				return true 
			case "ent":
				Tracker_StatsMetricsByUID( uid ).ent = expect entity( data )
				return true
			case "kills":
				Tracker_StatsMetricsByUID( uid ).kills = expect int( data )
				return true 
			case "deaths":
				Tracker_StatsMetricsByUID( uid ).deaths = expect int( data )
				return true
			case "damage":
				Tracker_StatsMetricsByUID( uid ).damage = expect float( data )
				return true
			case "playerleft":
				Tracker_StatsMetricsByUID( uid ).playerleft = expect bool( data )
				return true
			case "ignore_sync_flag":
				Tracker_StatsMetricsByUID( uid ).ignore_sync_flag = expect bool( data )
				return true
			case "previous_champion":
				Tracker_StatsMetricsByUID( uid ).previous_champion = expect bool( data )
				return true
			default:
				return false
		}
		
		unreachable
	}
#endif

bool function bLog()
{
	return file.LogOn
}

bool function bEnc( bool ornull setting = null )
{
	if( setting != null )
	{
		file.LogE = expect bool( setting )
	}
	
	return file.LogE
}

bool function bGlobalStats()
{
	return file.global_stats
}

void function Tracker_SetShouldShip( bool value )
{
	file.bShouldShip = value
}

string function GetPlayerUIDFromHandle( int handle )
{
	if( handle in file.HandleToPlayerData )
		return file.HandleToPlayerData[ handle ].playerUID
	
	return handle.tostring()
}

string function GetPlayerNameFromHandle( int handle )
{
	if( handle in file.HandleToPlayerData )
		return file.HandleToPlayerData[ handle ].playerName
	
	return handle.tostring()
}

table <string,string> function GetAllStringQueries()
{
	return file.Global_R5RDEV_StringSettings
}

table <string,float> function GetAllFloatQueries()
{
	return file.Global_R5RDEV_FloatSettings
}

table <string,int> function GetAllIntQueries()
{
	return file.Global_R5RDEV_IntSettings
}

table <string,bool> function GetAllBoolQueries()
{
	return file.Global_R5RDEV_BoolSettings
}

string function Tracker_GetQueryString( string setting, string none = "" )
{
	if ( setting in file.Global_R5RDEV_StringSettings )
	{
		return file.Global_R5RDEV_StringSettings[ setting ]
	}
	
	return none;
}

float function Tracker_GetQueryFloat( string setting, float none = 0.0 )
{
	if ( setting in file.Global_R5RDEV_FloatSettings )
	{
		return file.Global_R5RDEV_FloatSettings[ setting ]
	}
	
	return none;
}

int function Tracker_GetQueryInt( string setting, int none = 0 )
{
	if ( setting in file.Global_R5RDEV_IntSettings )
	{
		return file.Global_R5RDEV_IntSettings[ setting ]
	}
	
	return none;
}

bool function Tracker_GetQueryBool( string setting, bool none = false )
{
	if ( setting in file.Global_R5RDEV_BoolSettings )
	{
		return file.Global_R5RDEV_BoolSettings[ setting ]
	}
	
	return none;
}

void function Tracker_RegisterAllSettings()
{
	mAssert( !GetServerVar( "batch_fetch_complete" ), "Called Tracker_RegisterAllSettings() but query has already been made." )
	file._registerAllSettings = true
}

bool function Tracker_StatExists( string stat )
{
	return Stats__GetStatKeys().contains( stat )
}

////////////////////////////////////////////
////////		QUERY Data			////////

void function __QueryString_Callbacks( string setting, string value )
{	
	if( !( setting in file.queryStringCallbackFuncs ) )
		return 
		
	foreach ( callbackFunc in file.queryStringCallbackFuncs[ setting ] )
		callbackFunc( value )
}

void function NULL_QUERY( string retData ){}
typedef QueryFunc void functionref( string )

//usage=   AddCallback_QueryString("category:query", resultHandleFunction ) // see r5r.dev/info for details about available categories.
bool function AddCallback_QueryString( string query, QueryFunc ornull callbackFuncOrNull = null )
{	
	if( query.find(":") == -1 || split( query, ":" ).len() < 2 )
	{
		sqerror( "Tried to add query without criteria. Query = " + query )
		return false
	}
	
	QueryFunc callbackFunc = NULL_QUERY
	
	if( callbackFuncOrNull != null )
		callbackFunc = expect QueryFunc ( callbackFuncOrNull )
	
	if( file.bQueryComplete )
	{
		sqerror( "Tried to add callback with " + FUNC_NAME( 2 ) + " for callbackFunc " + string( callbackFunc ) + "() but server has already executed the query list." )
		return false 
	}
	
	if( !( query in file.queryStringInitFuncs ) )
		file.queryStringInitFuncs[ query ] <- []
	
	if( file.queryStringInitFuncs[ query ].contains( callbackFunc ) )
	{
		sqerror( "Tried to add callback with " + FUNC_NAME( 2 ) + " but callbackFunc " + string( callbackFunc ) + "() already exists in queryStringInitFuncs" )
		return false
	}
	
	file.queryStringInitFuncs[ query ].append( callbackFunc )
	return true
}

string function GetQueryDataString()
{
	string query_data_string;

	int omitFinalCommaOn = file.queryStringInitFuncs.len() //number of queries as keys
	
	int iter = 0
	foreach( string query, callbackArray in file.queryStringInitFuncs )
	{
		iter++;
		
		string queryFormatted = StringReplace( query, ",", "" )
		
		if( queryFormatted.find( ":" ) == -1 )
		{
			queryFormatted += ":"
		}
		
		query_data_string += queryFormatted + ( iter != omitFinalCommaOn ? "," : "" )
		
		int querySlice = query.find( ":" )
		file.queryStringCallbackFuncs[query.slice( 0, querySlice )] <- callbackArray //returns setting and sets as key 
	}
	
	return query_data_string
}

void function INIT_Global_R5RDEV_VarTable()
{	
	Script_RegisterAllQueries()
	
	file.bQueryComplete = true
	string QueryDataString = GetQueryDataString()	
	
	if( empty( QueryDataString ) )
	{
		#if DEVELOPER
			printt( "No querydatastring was constructed. " )
		#endif
		
		return 
	}
	
	string settings_string = FetchGlobalSettingsFromR5RDEV__internal( QueryDataString )
	
	#if DEVELOPER 
		sqprint( "QueryDataString: " + QueryDataString )
		sqprint( "settings_string: " + settings_string )
	#endif
	
	array<string> categories = split( settings_string, "`" )
	
	foreach ( settings in categories )
	{
		array<string> values = split( settings, "," )
		
		if( values.len() >= 1)
		{
			string data_type = trim(values[0]);
			
			int i;
			for (i = 1; i < values.len(); i++)
			{	
				
				array<string> setting = split( values[i], ":" )
				
				switch(data_type)
				{
					case "[bool]":
						
						if( setting.len() > 1 )
						{	
							string data0 = setting[0]
							string data1 = trim( setting[1] )		
							
							bool val = ( data1 == "true" || data1 == "1" ) ? true : false;
							file.Global_R5RDEV_BoolSettings[data0] <- val;
						}
						break
					
					case "[string]":
						
						if( setting.len() > 1 )
						{
							file.Global_R5RDEV_StringSettings[ trim( setting[0] ) ] <- trim( setting[1] )
						}
						break
					
					case "[int]":
					
						if( setting.len() > 1 )
						{	
							if( !IsNumeric( trim(setting[1]) ) )
							{
								break
							}
							
							try
							{
								file.Global_R5RDEV_IntSettings[ trim( setting[0] ) ] <- int( trim( setting[1] ) )
							}
							catch(errint)
							{
								#if DEVELOPER 
									sqerror("Error: " + errint)
								#endif
							}
						}
						break
					
					case "[float]":
					
						if( setting.len() > 1 )
						{
							if( !IsNumeric( trim( setting[1] ) ) )
							{
								break
							}
							
							try 
							{
								file.Global_R5RDEV_FloatSettings[ trim( setting[0] ) ] <- float( trim( setting[1] ) )
							}
							catch(errfloat)
							{
								#if DEVELOPER 
									sqerror("Error: " + errfloat)
								#endif
							}
						}
						break
						
					default:
					
						#if DEVELOPER 
							sqprint( "Unknown data type: " + data_type + " for setting: " + settings )
						#endif 
						break 
						
				}//switch for setting data type	
				
				if( setting.len() > 1 )
					__QueryString_Callbacks( setting[0], setting[1] )	
				
			}//for loop length of settings in category
		}//value len check
	}//foreach category
	
	file.bSyncedGlobal = true
	
}//init global settings

////////////////////////////////////////////
////////	Custom Query Callbacks	////////

void function SendMotdToPlayer( entity player, string motd )
{
	MessageLong( player, "", "", eMsgUI.VAR_MOTD, 10, motd, "", "", true )
}

void function DummyFunction_ProofOfConcept( string retData )
{
	#if DEVELOPER
		printt("\n\n\n\n\n\n\n restricted_rank LOADED with data: ", retData, "\n\n\n\n\n\n\n\n" )
	#endif
}

void function ShowPlayerOnlineMOTD( string retData )
{
	file.onlineMOTD = retData	
	AddCallback_OnClientConnected( ShowOnlineMOTD )
	
	foreach( player in GetPlayerArray() )
	{
		ShowOnlineMOTD( player )
	}
}

void function ShowOnlineMOTD( entity player )
{
	thread
	( 
		void function() : ( player )
		{
			if( !player.p.isConnected )
				waitthread WaitSignalOrTimeout( player, 20, "OnConnected", "OnDestroy", "OnDisconnected" )
			
				if( IsValid( player ) )
				{	
					//run ui script for motd
					SendMotdToPlayer( player, file.onlineMOTD )
						wait 5
						
					if( IsValid( player ) )
						LocalMsg( player, "#FS_WELCOME", "", eMsgUI.QUICK, 10, player.p.name )//Extra welcome message
				}
		}
	)()
}

void function ShowPlayerLocalMOTD( entity player )
{	
	thread
	(
		void function() : ( player )
		{
			if( !player.p.isConnected )
				waitthread WaitSignalOrTimeout( player, 20, "OnConnected", "OnDestroy", "OnDisconnected" )
			
			if( IsValid( player ) )
			{
				//run ui script for motd
				SendMotdToPlayer( player, file.localFlowstate_MOTD ) //LineBreak( file.localFlowstate_MOTD, 80 )
					wait 5
					
				LocalMsg( player, "#FS_WELCOME", "", eMsgUI.QUICK, 10, player.p.name )//Extra welcome message
			}
		}
	)()
}


void function FireRemoteMotd( entity player )
{	
	thread
	(
		void function() : ( player )
		{
			if( !player.p.isConnected )
				waitthread WaitSignalOrTimeout( player, 20, "OnConnected", "OnDestroy", "OnDisconnected" )
			
			if( IsValid( player ) && player.p.isConnected )
			{
				//run ui script for motd
				Remote_CallFunction_UI( player, "UI_Callback_MOTD" )
					wait 5
					
				if( IsValid( player ) && player.p.isConnected )
					LocalMsg( player, "#FS_WELCOME", "", eMsgUI.QUICK, 10, player.p.name )//Extra welcome message
			}
		}
	)()
}



void function Tracker_QueryInit()
{
	AddCallback_QueryString( "verified:SERVER" )
	AddCallback_QueryString( "season:CURRENT" )

	if( file.restricted_server )
	{
		string queryString = "restricted_rank:" + GetCurrentPlaylistVarInt( "restricted_rank", 0 ).tostring()
		AddCallback_QueryString( queryString, DummyFunction_ProofOfConcept )
	}
	
	if( file.bMotdEnabled )
	{
		if ( file.bUseOnlineMOTD )
		{
			AddCallback_QueryString( "MOTD:SERVER", ShowPlayerOnlineMOTD )
		}
		else if( !empty( file.localFlowstate_MOTD ) )
		{
			AddCallback_OnClientConnected( ShowPlayerLocalMOTD )
		}
		else 
		{
			AddCallback_OnClientConnected( FireRemoteMotd )
		}
	}
}

////////////////////////////////////////////
////////	Bulk stats fetch		////////


void function INIT_BATCH_FETCH()
{	
	SetServerVar( "batch_fetch_complete", false )
	
	array<string> oids    //Todo: send up array
	string oid_list = ""; //Todo: send up array
	
	wait 5 //hardset 5 second wait for players to connect. 
	
	int timerCount = 0
	while( GetPendingClientsCount() > 0 )
	{
		wait 1
		timerCount++;
		
		if( timerCount >= MAX_SECONDS_WAIT_FOR_BATCH_LOAD )
			break
	}
	
	foreach ( player in GetPlayerArray() )
	{
		bool next_player = false

        while ( IsDisconnected( player ) ) 
		{
			wait 0.01
			//sqprint("waiting for connection")
			
            if ( !IsValid( player ) ) 
			{
                next_player = true
                break
            }
        }

        if ( next_player )
            continue
	
		oids.append( player.GetPlatformUID() )	
		
	}
	
	int list_length = oids.len()
	
	if( list_length > 0 ) 
	{	
		int noComma = list_length - 1
		
		foreach ( index, oid in oids ) 
		{
            oid_list += oid;
			
            if ( index < noComma ) 
                oid_list += ",";
        }
	
        LoadBatchSyncData__internal( oid_list, file.requestedStatsList, file.requestedSettingsList )	
    }
	else 
	{
		CodeCallback_BatchStatsLoaded() // Need to call manually since native wont. Todo: Send empty list, let native handle.
	}
	
	SetServerVar( "batch_fetch_complete", true )
}

// if no callback is desired, use null or omit the callback func respectively
void function Tracker_RegisterStat( string statname, void functionref( entity ) ornull inboundCallbackFuncOrNull = null, var functionref( string ) ornull outboundCallbackFuncOrNull = null, bool bLocalAllowed = false )
{
	if( empty( statname ) )
	{
		sqerror( "Tried to addcallback with " + FUNC_NAME() + " but statname was empty" )
		return
	}
	
	if( !( statname in file.registeredStatCallbackFuncs ) )
	{
		file.registeredStatCallbackFuncs[ statname ] <- []
	}
	
	if( inboundCallbackFuncOrNull != null )
	{
		void functionref( entity ) inboundCallbackFunc = expect void functionref( entity ) ( inboundCallbackFuncOrNull )
		
		if( file.registeredStatCallbackFuncs[ statname ].contains( inboundCallbackFunc ) )
		{
			sqerror("Tried to addcallback with " + FUNC_NAME() + " but callbackFunc " + string( inboundCallbackFunc ) + " already exists")
		}
		else
		{	
			file.registeredStatCallbackFuncs[ statname ].append( inboundCallbackFunc )
		}
	}

	if( outboundCallbackFuncOrNull == null )
		return 
	else 
	{
		var functionref( string ) outboundCallbackFunc = expect var functionref( string ) ( outboundCallbackFuncOrNull )
		Stats__RegisterStatOutboundData( statname, outboundCallbackFunc )
	}
	
	if( bLocalAllowed )
		file.statsLocalAllowed.append( statname )
}

string function BuildRequestedStatsString()
{
	string statsQuery
	array<string> statKeysArray
	
	int last = file.registeredStatCallbackFuncs.len() - 1
	int iter = 0
	
	foreach( statsKey, value in file.registeredStatCallbackFuncs )
	{
		string allButLast = iter != last ? "," : "";
		
		statsQuery += statsKey + allButLast
		statKeysArray.append( statsKey )
		
		iter++;
	}
	
	Stats__SetStatKeys( statKeysArray )
	return statsQuery 
}

string function BuildRequestedSettingsString()
{
	if( file._registerAllSettings )
	{
		return "REGISTER_ALL";
	}
	
	string settingsQuery = ""
	int last = file.PlayerSettingsMap.len() - 1
	int iter = 0
	
	foreach( settingsKey, value in file.PlayerSettingsMap )
	{
		string allButLast = iter != last ? "," : ""
		
		settingsQuery += settingsKey + allButLast
	
		tracker.appendSetting( settingsKey )
		
		iter++;
	}
	
	#if DEVELOPER
		printt( "\n\n ---- Player Persistence Settings Query ---- \n", settingsQuery, "\n\n" )
	#endif 
	
	return settingsQuery 
}

bool function Tracker_StatLocalAllowed( string statKey )
{
	return file.statsLocalAllowed.contains( statKey )
}

var function Tracker_ReturnSuperglides( string uid )
{
	return PlayerMetricsArray[ GetPlayerMetricsIndexByUID( uid ) ].SuperglideTimestamps.len()
}

var function Tracker_ReturnKills( string uid )
{
	return PlayerMetricsArray[ GetPlayerMetricsIndexByUID( uid ) ].kills
}

var function Tracker_ReturnDeaths( string uid )
{
	return PlayerMetricsArray[ GetPlayerMetricsIndexByUID( uid ) ].deaths
}

var function Tracker_ReturnShots( string uid )
{
	return PlayerMetricsArray[ GetPlayerMetricsIndexByUID( uid ) ].shots
}

var function Tracker_ReturnHits( string uid )
{
	return PlayerMetricsArray[ GetPlayerMetricsIndexByUID( uid ) ].hits
}


var function Tracker_ReturnDamage( string uid )
{	//backend is registered as an int.
	return int( PlayerMetricsArray[ GetPlayerMetricsIndexByUID( uid ) ].damage )
}

var function Tracker_ReturnChampion( string uid )
{
	return PlayerMetricsArray[ GetPlayerMetricsIndexByUID( uid ) ].previous_champion
}

void function Tracker_SetPlayerAsChampion( entity player )
{
	string championUID = player.GetPlatformUID()
	
	SetPlayerStatBool( championUID, "previous_champion", true )
	Tracker_StatsMetricsByUID( championUID ).previous_champion = true
}

void function __LoadPlayerSyncData( entity player )
{
	LoadSyncData__internal( player.GetPlatformUID(), file.requestedStatsList, file.requestedSettingsList )
}

void function __SetPlayerSyncData( entity player )
{	
	if( !GetServerVar( "batch_fetch_complete" ) )
	{
		#if DEVELOPER
			printt( player, " = Waiting for batch fetch to complete" )
		#endif
		
		waitthread WaitSignalOrTimeout( svGlobal.levelEnt, 15, "BatchFetchComplete" )
	}
	else
	{
		waitthread WaitSignalOrTimeout( player, 15, "PlayerStatsReady", "OnDestroy", "OnDisconnected" )
	}
	
	if( !IsValid( player ) ) 
		return
			
	string OID = player.GetPlatformUID()	

	array<string> statKeys = Stats__AddPlayerStatsTable( OID )
	array<string> PersistenceData = split( GetPlayerStatString( OID, "settings" ), "," ) //Todo, remove string dump, set to untyped table. dump to PlayerData
	
	OnThreadEnd
	( 
		void function() : ( OID ) 
		{
			thread 
			(
				void function() : ( OID )
				{
					wait 1
					SQ_ResetStats__internal( OID )
				}
			)()
		}
	)
	
	if( !IsValid( player ) )
		return 
		
	if( statKeys.len() > 0 || PersistenceData.len() > 0 )
	{		
		#if DEVELOPER 
			printt( "\n\nIncoming StatsKeys:" )
			print_string_array( statKeys )
			printt( "\n\nIncoming Persistence Settings:" )
			print_string_array( PersistenceData )
		#endif 
	
		int SYNC_Data_length = statKeys.len()
		
		if( SYNC_Data_length < REQUIRED_SYNC_DATA_FIELDS ) 
		{
			#if DEVELOPER 
				sqerror( "Stats Failed for: " + OID + " ; returned " + SYNC_Data_length.tostring() + " fields;  required fields = " + REQUIRED_SYNC_DATA_FIELDS.tostring() )
			#endif 
			
			__Tracker_SignalPlayerStatsReady( player )
				return
		}
		
		foreach( key in statKeys )
		{
			if( key in file.registeredStatCallbackFuncs )
			{
				foreach( callbackFunc in file.registeredStatCallbackFuncs[ key ] )
				{
					callbackFunc( player )
				}
			}
		}		
		
		// The reason for this is because for a player who just rejoined, 
		// we don't want to overwrite their server persistence settings 
		// with the ones we just shipped in, as they will be older 
		// than the data we have in the servers local memory.
		UpdatePlayerData( player, PersistenceData, GetIgnoreSyncFlag( player ) )		
	}
	
	__Tracker_SignalPlayerStatsReady( player )
	
	foreach( callbackFunc in file.syncDataFullyLoadedCallbacks )
		callbackFunc( player )
}

void function __Tracker_SignalPlayerStatsReady( entity player )
{
	player.Signal( "SyncDataFullyLoaded" )
	SetStatsReadyFlag( player, true )
}

void function AddCallback_PlayerDataFullyLoaded( void functionref( entity player ) callbackFunc )
{
	#if DEVELOPER 
		mAssert( !file.syncDataFullyLoadedCallbacks.contains( callbackFunc ), "Tried to add callbackfunc " + string( callbackFunc ) + "() but func already exists in syncDataFullyLoadedCallbacks" )
	#endif
	
	if( !file.syncDataFullyLoadedCallbacks.contains( callbackFunc ) )
		file.syncDataFullyLoadedCallbacks.append( callbackFunc ) 
}

void function AddCallback_PlayerData( string setting, void functionref( entity player, string data ) ornull setCallbackFunc = null )
{
	void functionref( entity player, string data ) callbackFunc = NULL_PDATA
	
	if( setCallbackFunc != null )
		callbackFunc = expect void functionref( entity player, string data ) ( setCallbackFunc )
		
	if( setting in file.PlayerSettingsMap )
	{
		if( file.PlayerSettingsMap[ setting ].contains( callbackFunc ) )
			mAssert( false, format( "Already added function %s() for setting: %s ", string( callbackFunc ), setting ) )
		else
			file.PlayerSettingsMap[ setting ].append( callbackFunc )
	}
	else 
	{
		file.PlayerSettingsMap[ setting ] <- [ callbackFunc ]
	}
}

void function UpdatePlayerData( entity player, array<string> Sync_Data, bool ignoreSync = false )
{
	int i = 0
	
	#if DEVELOPER
		//printarray( Sync_Data )
	#endif
	
	string uid = player.p.UID
	foreach( setting in Sync_Data )
	{
		string key = ReturnKey( setting )
		
		if( key in file.PlayerSettingsMap )
		{
			string value = ignoreSync ? Tracker_FetchPlayerData( uid, key ) : ReturnValue( Sync_Data[ i ] )
			
			if( !ignoreSync )
				Tracker_SavePlayerData( uid, key, value )
			
			foreach( callBackFunc in file.PlayerSettingsMap[ key ] )
				callBackFunc( player, value )
		}
		else
		{
			#if DEVELOPER
				sqerror( format("Setting %s does not exist in PlayerSettingsMap", key ) )
			#endif
		}
		
		i++;
	}
}

PlayerMetrics function Tracker_StatsMetricsByUID( string uid )
{
	return Tracker_GetPlayerMetricsArray()[ GetPlayerMetricsIndexByUID( uid ) ]
}

void function __DestroyStats()
{
	file.bCheckShip = true
	file.bShouldShip = false
	file.bStatsShipped = false
	
	allDamageEvents = []
	PlayerMetricsArray = []
	playerVerifyCounts = []
	PlayerIdMap = {}
	Stats__ClearOutboundCache()
	
	foreach( string uid, StatsTable statsTbl in Stats__GetRoundStatsTables() )
		Stats__ResetTableByValueType( statsTbl )
		
	foreach( player in GetPlayerArray() )
	{
		int mID = InitializePlayerMetricsStructForPlayer( player )
		__GetPlayerMetrics( mID ).ent = player
	}
}

void function __CONTROLLED_LogInit()
{
	if( file.scriptLogthreadRunning )
	{
		sqerror( "Thread is already running" )
		return
	}
	
	file.scriptLogthreadRunning = true
	EndSignal( svGlobal.levelEnt, "TrackerNoLog" )
	
	OnThreadEnd
	( 
		void function() : ()
		{
			file.scriptLogthreadRunning = false
		}
	)
	
	for( ; ; )
	{
		FlagWait( "START_LOG" )	
		__START_LOGGING()	
		FlagClear( "START_LOG" )	
	}
}

void function PIN_Init()
{
	file.launchStartUnixTime = GetUnixTimestamp()
	
	#if !SERVER
		return
	#endif 
	
	if( IsLobby() )
		return
	
	bool bRunTracker = Flowstate_IsTrackerSupportedMode()

	RegisterSignal( "BatchFetchComplete" )
	RegisterSignal( "SyncDataFullyLoaded" )
	RegisterSignal( "PlayerStatsReady" )
	RegisterSignal( "TrackerNoLog" )
	
	__internals()
	Tracker_SettingsInit()
	Tracker_Init()
	PlayerDataCallbacks_Init()

	AddCallback_EntitiesDidLoad( WeaponSettings_Init )
	AddClientCommandCallbackNew( "requestStat", ClientCommand_RequestStat )
	
	if( !bRunTracker )
		file.LogOn = false
	
	if( file.bChatbotEnabled && file.bBotAllowed )
	{
		INIT_IntervalMessages()
		AddCallback_EntitiesDidLoad( PIN_OnEntitiesLoaded_Chatbot )
		AddCallback_GameStateEnter( eGameState.Playing, __executeEventStart_messages )
	}
	
	#if TRACKER 
		FlagInit( "DeterminePreviousChampion", false )
		FlagInit( "PreviousChampionDetermined", false )
	#endif
	
	if( file.LogOn )
	{
		SetServerVar( "tracker_enabled", true )
		AddCallback_OnTdmStateEnter_InProgress( Tracker_SetStartLog )
		AddCallback_OnClientDisconnected( ShipFunction_OnDisconnected )
		
		FlagInit( "START_LOG", true )
		thread __CONTROLLED_LogInit()
	}
	
	if( GetCurrentPlaylistVarBool( "disable_lag_comp", false ) )
		SetConVarInt( "sv_unlag", 0 )
	
	AddCallback_OnClientConnected( PlayerConnectedCallback )
	AddClientCommandCallback( "show", ClientCommand_mkos_return_data )
	
	if ( IsClientCommandAdminEnabled() )
		AddClientCommandCallback( "cc", ClientCommand_mkos_admin ) 
	
	if ( file.LogOn )
	{
		string message = format( "R5R.DEV metrics initialized at:  %d ", GetUnixTimestamp() )
		printt( message )
		
		AddCallback_OnClientDisconnected( PlayerDisconnectedCallback )		
		AddCallback_OnWeaponAttack( WeaponAttack )
		
		RegisterSignal( "SuperglideDetectionResetStats" ) 
		file.superglideDetect = true	
		
		file.FS_MaxHealth = ( GetCurrentPlaylistVarFloat( "default_shield_hp", 0 ) ) + 100 //TODO: Use health/shield getters
	}
	
	if ( Ea_Verify_Server() ) //You should not attempt to enable this, the backend will verify..
		AddClientCommandCallback( "ea_verify", ClientCommand_mkos_ea_verify )
	
	//moved to r5rdev_config.json for security reasons
	file.DISCORD_PLAYERS_WEBHOOK = ( GetCurrentPlaylistVarString( "DISCORD_PLAYERS_WEBHOOK", "" ) )
	file.DISCORD_MATCHES_WEBHOOK = ( GetCurrentPlaylistVarString( "DISCORD_MATCHES_WEBHOOK", "" ) )
	
	//initialize array/table maps
	INIT_CC_GameTypes()
	INIT_CC_MapNames()
	
	if( IsClientCommandAdminEnabled() )
		INIT_CC_playeradmins()
	
	if ( file.restricted_server ) 
		PlayerWhitelistInit()
	
	//init superglide strings // TODO: move to localization playlist tokens
	file.sg_counter_msg = GetCurrentPlaylistVarBool( "superglide_counter_msg", false )
	file.superglide_msg = GetCurrentPlaylistVarString( "custom_superglide_msg", "" )
	file.superglidetitle = file.global_stats ? "Season Glides" : "Glides";
	
	bool skipChampionFetch
	//fetch global STATS
	if ( file.global_stats )
	{
		thread INIT_Global_R5RDEV_VarTable()
		
		if( bRunTracker )
		{	
			file.bBatchFetchInit = true
			
			Script_RegisterAllStats()
			Script_RegisterAllShipFunctions()
			
			file.requestedStatsList = BuildRequestedStatsString()
			file.requestedSettingsList = BuildRequestedSettingsString()
			
			thread INIT_BATCH_FETCH()
		}
		else 
		{
			skipChampionFetch = true
		}
	}
	else 
	{
		skipChampionFetch = true
	}
	
	if( !skipChampionFetch )
		AddCallback_OnBatchStatsLoaded( Tracker_SetChampionOnPersistenceLoad )
	else
	{
		FlagSet( "PreviousChampionDetermined" )
		SetServerVar( "batch_fetch_complete", true )
	}
	
	if ( GetCurrentPlaylistVarBool( "enable_voice", false ) )
		EnableVoice()
}

bool function Tracker_IsBatchFetchQueued()
{
	return file.bBatchFetchInit
}

void function Tracker_SetStartLog()
{	
	FlagSet( "START_LOG" )
}

void function Tracker_SettingsInit()
{
	//todo: cleanup mode related stuff
	file.LogOn 										= GetCurrentPlaylistVarBool( "logging_enabled", false)
	file.LogE 										= GetCurrentPlaylistVarBool( "logging_encryption", false)
	file.bChatbotEnabled							= ( !IsLobby() && SQ_GetSetting__internal( "settings.ENABLE_CHATBOT" ) == "true" ? true : false )
	file.bClientCommandAdminEnabled					= ( GetConVarInt( "sv_onlineAuthEnable" ) == 1 && GetCurrentPlaylistVarBool( "cc_administration", false ) )
	file.flowstateRoundtime 						= GetCurrentPlaylistVarInt( "flowstateRoundtime", 1800 )
	file.afk_to_rest_enabled 						= GetCurrentPlaylistVarBool( "afk_to_rest_bool", false )
	file.update_discord_player_counts 				= GetCurrentPlaylistVarBool( "stats_discord_webhook_player_count", false )
	file.ibmm_wait_limit 							= GetCurrentPlaylistVarInt( "ibmm_wait_limit", 999 )
	file.bBotAllowed 								= file.BotAllowedModes.contains( GetCurrentPlaylistName() ) //TODO: rework 
	file.gamemode_type_1v1 							= g_is1v1GameType() //returns true if mode is confifugred as 1v1 type
	file.stats_discord_webhook_matches_enabled		= GetCurrentPlaylistVarBool( "stats_discord_webhook_matches_enabled", false )
	
	if( file.bChatbotEnabled )
		file.sBotName = SQ_GetSetting__internal( "settings.CHATBOT_PREFIX" )
	
	//init stat bools (must be before string inits) todo: cleanup
	file.global_stats 						= GetCurrentPlaylistVarBool( "use_global_stats", false )
	file.restricted_server 					= GetCurrentPlaylistVarBool( "restricted_server", false )
	file.DefaultLock1v1Setting 				= GetCurrentPlaylistVarBool( "default_lock1v1_setting", true )
	file.DefaultEnableInputBannerSetting 	= GetCurrentPlaylistVarBool( "default_enable_input_banner_setting", true )
	file.DefaultStartInRestSetting 			= GetCurrentPlaylistVarBool( "default_start_in_rest_setting", false )

	//restricted init 
	file.restricted_gamesplayed 			= GetCurrentPlaylistVarInt( "restricted_gamesplayed", 0 )
	file.restricted_kills 					= GetCurrentPlaylistVarInt( "restricted_kills", 0 )
	file.restricted_playtime 				= GetCurrentPlaylistVarInt( "restricted_playtime", 0 )
	file.restricted_rank 					= GetCurrentPlaylistVarInt( "restricted_rank", 0 )
	file.restricted_kd 						= GetCurrentPlaylistVarFloat( "restricted_kd", 0.0 )
	file.restricted_join_message 			= GetCurrentPlaylistVarString( "restricted_join_message", "You are able to play on this restricted server." )
	file.restricted_whitelist_message 		= GetCurrentPlaylistVarString( "restricted_whitelist_message", "You are whitelisted to play on this restricted server." )
	file.restricted_admin_message 			= GetCurrentPlaylistVarString( "restricted_admin_message", "You are an admin." )

	//motd
	file.bUseOnlineMOTD 					= GetCurrentPlaylistVarBool( "use_online_motd", false )
	file.bMotdEnabled						= GetCurrentPlaylistVarBool( "enable_motd", false )
	file.localFlowstate_MOTD				= GetCurrentPlaylistVarString( "custom_MOTD", "" )

	//wait for players to connect before querying batch player stats
	file.maxWaitForBatchLoad				= GetCurrentPlaylistVarFloat( "tracker_max_wait", 7.0 )
}

//initplayer
void function PlayerConnectedCallback( entity player ) 
{	
	if ( IsLobby() )
		return
	
	if ( !IsValid( player ) )
		return
	
	//init player vars
	int playerHandle = player.GetEncodedEHandle()
	string playerUID = player.GetPlatformUID()
	string playerName = player.GetPlayerName()
	
	player.p.name = playerName
	player.p.UID = playerUID
	player.p.handle = playerHandle
	//sqprint(format("Added handle as: %d,  saved state: %d", playerHandle, player.p.handle ))
	
	string uid = player.GetPlatformUID()
	int mID = InitializePlayerMetricsStructForPlayer( player )
	__GetPlayerMetrics( mID ).ent = player
	
	/////////////////////////////////////////////////////////////////////////////////////////
	if( !file.LogOn )
		return
	/////////////////////////////////////////////////////////////////////////////////////////
	
	//init player map
	PlayerData pdata
	
	pdata.playerName = playerName
	pdata.playerUID = playerUID
	
	file.HandleToPlayerData[ playerHandle ] <- pdata
	
    thread PIN_AddPlayer( player )
	
	string checkName = pdata.playerName.slice( 0, 1 )
	if( checkName.find( "[" ) != -1 ) //hack, make sure player is not message bot entity (TODO: REMOVE)
		return
	
	if( file.superglideDetect )
	{
		AddPlayerMovementEventCallback( player , ePlayerMovementEvents.JUMP, OnJumped )
		AddPlayerMovementEventCallback( player, ePlayerMovementEvents.MANTLE, Flowstate_TrackingVision_SuperglideDetection_Stats ) //credit cafe
	}
	
	if ( file.update_discord_player_counts )
	{
		PlayerCounts
		( 
			"Connected", 
			sanitize( pdata.playerName ), 
			pdata.playerUID, 
			GetNumHumanPlayers().tostring()
		)
	}
	
	if ( file.global_stats && GetServerVar( "batch_fetch_complete" ) )
		thread __LoadPlayerSyncData( player )
	
	if ( file.global_stats )
		thread __SetPlayerSyncData( player )
}

void function PIN_OnEntitiesLoaded_Chatbot()
{
	thread __LoadServerBot()
}

void function PlayerCounts( string state, string name, string OID, string count )
{
	//bad check for non fsdm gamemodes
	if ( GetGlobalNetInt( "FSDM_GameState" ) == eTDMState.IN_PROGRESS || GetNumHumanPlayers() == 1 )
		_STATSHOOK_UpdatePlayerCount__internal( state, name, OID, count, file.DISCORD_PLAYERS_WEBHOOK )
}

void function __EndOfMatch( string recap, string DISCORD_MATCHES_WEBHOOK )
{
	#if DEVELOPER 
		mAssert( DiscordHook_MatchesRecapEnabled(), "Spawned a thread for no reason, discordhook matches was disabled." )
	#endif 
	
	if( DiscordHook_MatchesRecapEnabled() ) //In case forgets to check before calling.
		_STATSHOOK_EndOfMatch__internal( recap, DISCORD_MATCHES_WEBHOOK )
}

bool function DiscordHook_MatchesRecapEnabled()
{
	return file.stats_discord_webhook_matches_enabled
}

void function __START_LOGGING()
{
	if ( file.PIN_GameState_Start ) 
	{
		#if DEVELOPER 
			sqprint( "file.PIN_GameState_Start was true, returning" )
		#endif
		return 
	}
	
	#if DEVELOPER 
		sqprint( "Dispatching Init_NewGame() thread" )
	#endif
	
	thread Init_NewGame()
}

void function Init_NewGame()
{	
	if( MapName() == eMaps.mp_lobby )
		return
	
	if ( !file.LogOn )
	{
		sqprint( "::: Logging disabled -- to enable set in playlists file --" )
		file.PIN_GameState_Start = true
		return
	}
	
	__DestroyStats() //make sure metrics incrued during intermediate time are not included

	//////////////////////////////////
	//	THIS IS HANDLED INTERNALLY	//
	//	However, this adds a layer 	//
	//	of assurance for syncing	//
	//	game events with log thread //
	///////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////
	int waitlimit = 0;
	while( SQ_GetLogState__internal( eLogState.BUSY ) )
	{
		wait 0.5;
		waitlimit++;
		
		if ( waitlimit >= MAX_WAIT_FOR_LOGGING_THREAD )
		{
			sqerror(format("Log thread failed to finish within [%d] seconds during busy check.", floor(MAX_WAIT_FOR_LOGGING_THREAD/2) ))
			file.bSafeLog = false;
			return
		}
		#if DEVELOPER
			else 
			{
				sqprint("Log thread checking busy...")
			}
		#endif
	}
	
	
	InitializeLogThread__internal( file.LogE )
	
	waitlimit = 0;
	while( !SQ_GetLogState__internal( eLogState.READY ) )
	{
		wait 0.5;
		waitlimit++;
		
		if ( waitlimit >= MAX_WAIT_FOR_LOGGING_THREAD )
		{
			sqerror( format( "Log thread failed to finish within [%d] seconds during ready check.", floor( MAX_WAIT_FOR_LOGGING_THREAD / 2 ) ) )
			file.bSafeLog = false
			return
		}
	}	
	
		#if DEVELOPER	
			if( SQ_GetLogState__internal( eLogState.READY ) )
			{
				sqprint( "Log thread state: ready." )
			}		
		#endif
	
	waitlimit = 0;
	while( !SQ_GetLogState__internal( eLogState.SAFE ) )
	{
		wait 0.5;
		waitlimit++;
		
		if ( waitlimit >= MAX_WAIT_FOR_LOGGING_THREAD )
		{
			sqerror( format( "Log thread failed to init [%d] seconds during safe check.", floor( MAX_WAIT_FOR_LOGGING_THREAD /2 ) ) )
			file.bSafeLog = false
			return
		}
	}
	
		#if DEVELOPER	
			if( file.bSafeLog )
				sqprint( "Log thread state: safe." )
			else 
				sqprint( "Log thread state: NOT safe. (aborted)" )	
		#endif
	
	///////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////
	
	// Round started -- [you should not edit this]
	LogEvent__internal
	(
		format
		( 
			"|#Tracker version:%.1f\n|| New match; round %d;  started at: %d\n|#AA_VALUE %.1f",
			TRACKER_VERSION,
			GetCurrentRound(), 
			GetUnixTimestamp(),
			GetCurrentPlaylistVarFloat( "aimassist_magnet_pc", -1.0 )
		),
		
		file.LogE
	)
	
	foreach( player in GetPlayerArray() )
		CheckPlayerStartInRest( player )
	
	PrintMatchIDtoAll()
	
	file.PIN_GameState_Start = true
}


	bool function Tracker_IsRestrictedServer()
	{
		return file.restricted_server
	}

	void function Tracker_SetRestrictedServer( bool setting )
	{
		file.restricted_server = setting
	}

	
	void function PlayerWhitelistInit()
	{
		string string_whitelist = SQ_GetSetting__internal( "settings.PLAYER_WHITELIST" )
		
		if ( !empty( string_whitelist ) )
		{	
			try
			{
				file.whitelist = StringToArray( string_whitelist, 2000 )	
			}
			catch(err)
			{
				sqerror( "Error: " + err )
			}
		}
	}
	
	int function CheckIfPlayerHasAccess( entity player )
	{	
		string player_UID = player.GetPlatformUID()
		
		if ( file.whitelist.contains( player_UID ) )
			return 8
		
		if ( GetAdminList().contains( player_UID ) )
			return 7
		
		if ( player.p.season_score < Tracker_GetQueryInt( "restricted_rank" ) )
			return 6
		
		if ( player.p.season_gamesplayed < file.restricted_gamesplayed )
			return 4
		
		if ( player.p.season_kills < file.restricted_kills )
			return 3
		
		if ( getkd( player.p.season_kills, player.p.season_deaths ) < GetCurrentPlaylistVarFloat( "restricted_kd", 0 ) )
			return 2
		
		if ( player.p.season_playtime < file.restricted_playtime )
			return 1
		
		return 9
	}
	
	string function Player_Access_Message( entity player, int result )
	{
		switch( result )
		{
			case 9:
				return LineBreak( file.restricted_join_message )
			
			case 8:
				return LineBreak( file.restricted_whitelist_message )
				
			case 7:
				return LineBreak( file.restricted_admin_message )
				
			case 6: 
				return "Your Rank is too low to play on this server. \n\n Your Score: " + player.p.season_score.tostring() + ". \nLowest rank allowed: " + file.restricted_rank.tostring() + " (Score: " + Tracker_GetQueryInt("restricted_rank").tostring() + ")"; //this Tracker_GetQueryInt() setting should be named restricted_score for clarity
			
			case 4:
				return "You do not have enough games played to play on this server. \n Your total games played: " + player.p.season_gamesplayed.tostring() + " \n Server required minimum: " + file.restricted_gamesplayed.tostring() + "\n You need to play " + ( file.restricted_gamesplayed - player.p.season_gamesplayed ).tostring() + " more games to play on this server.";
			
			case 3:
				return "You do not have enough kills to play on this server. \n Your kills: " + player.p.season_kills.tostring() + " \n Server required minimum: " + file.restricted_kills.tostring() + "\n You need " + ( file.restricted_kills - player.p.season_kills ).tostring() + " more kills to play on this server.";
			
			case 2:
				return "Your K/D ratio is too low to play on this server. \n Your K/D: " + getkd( player.p.season_kills, player.p.season_deaths ) + " \n Server required minimum: " + file.restricted_kd.tostring() + "\n You need to increase your K/D ratio by:  " + ( file.restricted_kd - getkd( player.p.season_kills, player.p.season_deaths )).tostring() + " to play on this server.";
				
			case 1:
				return "Your play time does not meet this server's required minimum play time of: " + PlayTime( file.restricted_playtime ) + "\n Your playtime: " + PlayTime( player.p.season_playtime ) + "\n\n You need to play for at least: " + PlayTime(( file.restricted_playtime - player.p.season_playtime)) + " more time.";
			
			default:
				return "Error 404";
		}
		
		unreachable
	}
	
	void function force_rest( entity player )
	{
		EndSignal( player, "OnDisconnected", "OnDestroy" )
		
		while( IsValid( player ) )
		{	
			player.FreezeControlsOnServer()
			player.ForceStand()
			mkos_Force_Rest( player )
			wait 0.5
		}	
	}
	
	void function Alert_Player_Access( entity player )
	{	
		EndSignal( player, "OnDisconnected", "OnDestroy" )
		CommandsEnabled( player, false )
		
		mkos_Force_Rest( player )
		
		if( IsValid( player ) && !GetServerVar( "batch_fetch_complete" ) )
			WaitSignal( svGlobal.levelEnt, "BatchFetchComplete" )
		
		if( IsValid( player ) && !Tracker_IsStatsReadyFor( player ) )
			WaitSignal( player, "SyncDataFullyLoaded" )
		
		if( !IsValid( player) )
			return

		//this int must be set after stats have loaded
		int access_status = CheckIfPlayerHasAccess( player )
		
		wait 2
		
		if ( IsValid( player ) && access_status >= RESTRICTED_ACCESS_STATUS_REQUIRED )//Todo: Revisit for more modularity from a single defined source and remove CONST adjustments
		{	
			mkos_Force_Rest( player )
			Message( player, "Welcome " + player.GetPlayerName(),  Player_Access_Message( player, access_status ), 30 )
			CommandsEnabled( player, true )
		}
		else 
		{	
			if( IsValid( player ) )
			{
				thread force_rest( player )
				
				Message( player, "Sorry " + player.GetPlayerName(),  Player_Access_Message( player, access_status ), 30 )
				wait 7	
				
				if( IsValid( player ) )
				{
					KickPlayerById( player.GetPlatformUID(), Player_Access_Message( player, access_status ) )
					UpdatePlayerCounts()
					
					if( GetCurrentPlaylistVarBool( "restricted_kick_log", false ) )
					{
						sqprint( format( "\n\n Player: %s, Kick msg: %s", player.GetPlayerName(), Player_Access_Message( player, access_status ) ) )
					}
				}
			}
		}
		
	}
	

//returns true if message was sent without truncation, false if truncated. 
bool function SendServerMessage( string _msg )
{	
	if( !file.bChatbotEnabled )
		return false
		
	bool status = true
	int msg_length = _msg.len()
	
	if( msg_length > MAX_SAY_MSG )
	{
		_msg = truncate( _msg, MAX_SAY_MSG )
		sqerror( "Message contained " + msg_length.tostring() + " characters ( " + (msg_length - MAX_SAY_MSG).tostring() + " too many ) and was truncated. Maxlength: " + MAX_SAY_MSG.tostring() )
		status = false;
	}
	
	SQ_ServerMsg__internal( sanitize( _msg ), file.iBotID )
	
	//if cafe's save chat log enabled
	//ReturnChatArray().append(_msg)
	return status
}

void function INIT_IntervalMessages()
{
	string msg_ArrayString = trim( SQ_GetSetting__internal("settings.INTERVAL_MESSAGES") )
	bool gotoLoopMessage = false 
	
	if( msg_ArrayString.len() == 0 )
	{
		gotoLoopMessage = true
	}
	
	if( !gotoLoopMessage )
	{
		array<string> interval_settings = split( msg_ArrayString , "|")
		
		int iMessageNum = 0
		
		foreach( msg_string in interval_settings )
		{
			iMessageNum++;
			
			array<string> _msg = split( trim(msg_string), "=" )
			if( _msg.len() > 1 )
			{
				string sM0 = trim(_msg[0])
				string sM1 = trim(_msg[1])
				
				#if DEVELOPER
					sqprint(format("interval found: %s  ;message: %s", sM0, sM1))
				#endif
				
				string sm0Match = sM0.tolower()
				
				if( IsNumeric( sM0, 0, file.flowstateRoundtime ) && sM1.len() > 0 && sM1.len() < 1000 )
				{
					try
					{
						string sMsg = sanitize( sM1 )
						
						int convert = sM0.tointeger()
						float iRound10 = ceil(float(convert) / 10.0) * 10
						int interval = (iRound10 / 10).tointeger()
						
						if ( !( interval in file.MessageEvents ) )
						{
							array<string> messages;
							
							messages.append( sMsg )
							
							file.MessageEvents[interval] <- messages
						}
						else 
						{
							file.MessageEvents[interval].append( sMsg )
						}
					}
					catch(c_err)
					{
						sqerror(format("Cannot add msg #[ %d ] to MessageEvents, improper format", iMessageNum ))
					}
				}
				else if( SERVER_MSG_EVENT_TYPES.contains( sm0Match ) && sM1.len() > 0 && sM1.len() < 1000 )
				{
					switch( sm0Match )
					{
						case "start":
							file.Messages_EventStart.append(sM1)
							break
						case "end":
							file.Messages_EventEnd.append(sM1)
							break
					}
				}
				else
				{
					sqerror( format( "InitIntervalMessages parsing error with: %s, %s", sM0, sM1 ) )
				}
			}
		}
	}// if !goto
	
	//loop messages (every x seconds)
	
	string loopTime = SQ_GetSetting__internal( "settings.LOOP_MESSAGES_INTERVAL" )
	
	if( !empty( loopTime ) && IsNumeric( loopTime ) )
	{
		int convert = loopTime.tointeger()
		float iRound10 = ceil( float( convert ) / 10.0 ) * 10
		int interval = ( iRound10 / 10 ).tointeger()
		file.iLoopMessagesTime = interval //seconds rounded to thread cycle as multiple of 10
	}
	else 
	{
		if( !empty( loopTime ) )
			sqerror( "[TRACKER] Invalid LOOP_MESSAGES_INTERVAL ; setting to 60" )
		
		file.iLoopMessagesTime = 6 //60 seconds default
	}
	
	#if DEVELOPER
		sqprint( format( "file.iLoopMessagesTime is: %d ", file.iLoopMessagesTime ) )
	#endif
		
	string getLoopMessages = SQ_GetSetting__internal( "settings.LOOP_MESSAGES" )

	if( !empty( getLoopMessages ) && getLoopMessages.find("|") )
	{
		array<string> aLoopMessages = split( getLoopMessages, "|" )
		
		foreach( message in aLoopMessages )
		{
			file.arrayLoopMessages.append( trim( message ) )
			#if DEVELOPER
				sqprint( format("Initialized loop message: %s", message ) )
			#endif
		}
	}
}


void function __executeEventStart_messages()
{	
	if( file.Messages_EventStart.len() == 0 )
		return 
	
	foreach ( message in file.Messages_EventStart )
		SendServerMessage( message )
}

void function __executeEventEnd_messages()
{
	if( file.Messages_EventEnd.len() == 0 )
		return
	
	foreach ( message in file.Messages_EventEnd )
		SendServerMessage( message )
}

void function InitPlayerWelcomeMessage()
{
	//requires filter recipient
}

void function DEV_StartIntervalThread()
{
	thread MessageIntervalThread()
}

void function MessageIntervalThread()
{
	if( file.bIntervalThreadRunning )
	{
		sqerror( "Interval thread is already running." )
		return
	}
	
	int threadCycleCount = 0;
	int loopMsgCount = 1; //gets reset when last message in loop messages is reached
	
	file.bIntervalThreadRunning = true
	
	RegisterSignal( "KillIntervalThread" )
	Signal( svGlobal.levelEnt, "KillIntervalThread" )
	EndSignal( svGlobal.levelEnt, "KillIntervalThread" )
	
	bool bLoopServerMessages = true 
	
	if( file.arrayLoopMessages.len() <= 0 )
		bLoopServerMessages = false
	
	OnThreadEnd
	( 
		void function() : () 
		{
			file.bIntervalThreadRunning = false
		}
	)
	
	while( true )
	{		
		wait 10	
		
		threadCycleCount += 1;
		
		//events
		foreach( interval, msgs in file.MessageEvents ) 
		{
			if ( ( threadCycleCount % interval) == 0 ) 
			{
				foreach( index, _msg in msgs ) 
				{
					SendServerMessage( _msg );
				}
			}
		}	
		
		//train (loopmessages)
		if( bLoopServerMessages )
			loopMsgCount = SendLoopMessage( threadCycleCount, loopMsgCount )
	}
	
	file.bIntervalThreadRunning = false
}

bool function isIntervalThreadRunning()
{
	return file.bIntervalThreadRunning
}

int function SendLoopMessage( int threadCycleCount, int loopMsgCount  )
{
	if( loopMsgCount > file.arrayLoopMessages.len() )
	{
		loopMsgCount = 1
	}
	
	if( loopMsgCount > 0 && threadCycleCount > 0 && threadCycleCount % file.iLoopMessagesTime == 0  )
	{
		SendServerMessage( file.arrayLoopMessages[( loopMsgCount - 1 )] )
		loopMsgCount++;
	}
	
	return loopMsgCount
}

void function EventMessageSystem()
{
	//TODO
}

void function __LoadServerBot()
{
	wait 3 //todo: time this event based
	
	#if DEVELOPER
		//printt(":(pin):: loaded server bot")
	#endif
	
	array<int> result = SQ_CreateServerBot__internal( file.sBotName )
	
	if( result.len() < 1 )
	{
		file.bChatbotEnabled = false
		return
	}
	
	file.iBotID = result[0]
	
	if( file.iBotID == -1 )
	{
		file.bChatbotEnabled = false
		return
	}
	
	//file.iBotHandle = result[1]
	//sqprint(format( "Bot id is: %d", file.iBotID ))
}

bool function IsBotEnt( entity player )
{
	if( player == file.entityBotEnt )
		return true
		
	return false
}

entity function GetMessageBotEnt() //global
{
	return file.entityBotEnt
}

bool function bBotEnabled()
{
	return file.bChatbotEnabled
}

array<entity> function ArrayRemoveBot( array<entity> players )
{
	players.fastremovebyvalue( file.entityBotEnt )
	return players
}

float function Tracker_GetMaxWaitForBatchLoad()
{
	return file.maxWaitForBatchLoad
}

bool function IsClientCommandAdminEnabled()
{
	return file.bClientCommandAdminEnabled
}

/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////


//START KILL RECAP
/*****************************************************************************************************************************/

int function GetUniqueFightId() 
{
    return file.fightIdCounter++;
}

//endfight function to count from global metrics struct
int function CountEventsWithinTimeframe( array< float > timestamps, float startTime, float endTime ) 
{
    int count = 0;
    foreach ( timestamp in timestamps ) 
	{
        if ( timestamp >= startTime && timestamp <= endTime ) 
		{
            count++;
        }
    }
    return count;
}


//test function for _LG_Duels
void function RecapStats(entity player, float damage, float hits, float shots, string victim, float victimdamage, float victimhits, float victimshots) 
{
    float accuracy = 0.0;
    float victim_accuracy = 0.0;
	
    if ( shots > 0.0 ) 
	{
        accuracy = (hits / shots) * 100.0;
        
		if ( accuracy >= 100.0 ) 
		{
            accuracy = 100.0;
        }
    }
	
    if ( victimshots > 0.0 ) 
	{
        victim_accuracy = ( victimhits / victimshots ) * 100.0;
        
		if ( victim_accuracy >= 100.0 ) 
		{
            victim_accuracy = 100.0;
        }
    }

    string print_totals = format("Your Dmg: %d, Your Accuracy: %d%% \n %s's Dmg: %d, %s's Accuracy: %d%%", damage, accuracy, victim, victimdamage, victim, victim_accuracy);
    Message(player, "Recap vs: " + victim, print_totals, 3.5);
}





DamageEvent function Tracker_CreateDamageEvent( int weaponSource, float damage, float actionTimestamp, float shotIdentifier, int attackerHandle, int victimHandle ) 
{
    DamageEvent event;
	event.isNew = true; //bool
	event.attackerHandle = attackerHandle; //players ehandle (for comparison logic) - int
	event.victimHandle = victimHandle; //int
    event.weaponSource = weaponSource; // int
    event.damage = damage; //float
    event.hitCount = 0; //int
    event.bulletsHit = 0.0; //float
	event.headshots = 0; //int
	event.actionTimestamp = (actionTimestamp - .0900); //float
	event.lastWeaponSource = weaponSource; //int
	event.lastHitTimestamp = 0; //float
	event.shotIdentifier = shotIdentifier; //int
	event.isValid = true
	
	allDamageEventsMap[ eventID( attackerHandle, victimHandle ) ] <- event
	
    return event;
}

void function Tracker_AddDamageEventsToDeleteQueue( int attacker_handle, int victim_handle )
{
	DeleteEvents Event;
	Event.attacker_handle = attacker_handle 
	Event.victim_handle = victim_handle
	Event.fightEndTime = Time()
	Tracker_AddEventTask( Event )
}

	void function __EndFight( entity victim, entity attacker, var damageInfo, float deathtime )
	{
		if( Flowstate_IsFastInstaGib() )
			WaitEndFrame() //all data this function needs may not be wrote by it's coroutine yet.
		
		if( !damageInfo )
			return
		
		if ( !IsValid( victim ) || ( !victim.IsPlayer() && !victim.IsNPC() ) || !IsValid( attacker ) )
		{
			#if DEVELOPER
				sqerror( "returning from endfight, invalid player/attacker" )
			#endif
			
			return
		}
		
		bool victimIsPlayer = victim.IsPlayer()
		
		//Increment fightid
		int id = GetUniqueFightId()
		
		//set player vars
		string ornull victimName = victimIsPlayer ? victim.p.name : victim.GetNetworkedClassName()
		
		if( victimName == null )
		{
			victimName = "worldspawn"
			string msg = "Victimname was null during endfight id " + id.tostring()
			
			#if DEVELOPER
				sqerror( msg )
			#endif 
			
			LogError( msg )
		}
		
		string victimUID = victimIsPlayer ? victim.p.UID : string( victim.GetEncodedEHandle() )
		victimUID = statPrintUID( victimUID )
		
		string attackerUID
		string attackerName
		
		int victim_handle = victimIsPlayer ? victim.p.handle : victim.GetEncodedEHandle()
		int attacker_handle = attacker.IsPlayer() ? attacker.p.handle : DamageInfo_GetDamageSourceIdentifier( damageInfo )
		
		if( attacker_handle == eDamageSourceId.bleedout )
		{
			#if DEVELOPER
				Warning( "fetching last attacker for " + string( victim ) )
			#endif
			
			entity potentialAttacker = Bleedout_GetCreditedKiller( victim )
			
			#if DEVELOPER
				Warning( "last attacker = " + string( potentialAttacker ) )
			#endif
			
			if( IsValid( potentialAttacker ) )
			{
				attacker = potentialAttacker
				attacker_handle = attacker.GetEncodedEHandle()
			}
		}
		
		if( attacker.IsNPC() )
			attacker_handle = attacker.GetEncodedEHandle()
		
		//statement header
		string logString = "|#Fight Recap:{" + GetUnixTimestamp() + "}| Fight ID:{" + id + "}| Victim: {" + victimUID + "};";
		
		// initialize vars..
		float totalDamageToVictim = 0.0;
		float timeWindow = deathtime;
		bool bReportStats = true;
		float fightStartTime = FLT_MAX;
		float fightEndTime = 0.0; 
		
		//hardcoded jump & sueprglide grace for pre-shot start of fight actions
		float jumpgrace = 1.2
		float glidegrace = 2.2

		// temp array to analyze data
		array<DamageEvent> relevantDamageEvents;

		// initialize temporary attacker array totals. these indexes will all be aligned.
		array<int> player_handles;
		array<string> playerDISPLAYNAME;
		array<float> playerTotalDamages;
		array<int> playerTotalHits;
		array<int> playerTotalHeadshots;
		array<int> playerTotalJumps;
		array<int> playerTotalShots;
		array<int> playerSuperglides;

		// initialize victim total vars
		float victimTotalDamage = 0.0;
		int victimTotalHits = 0;
		int victimTotalHeadshots = 0;
		int victimTotalJumps = 0;
		int victimTotalShots = 0;
		int victimSuperglides = 0;
		
		//initialize attacker shared int vars (depending on current attacker these change during loops)
		int attackerJumps = 0;
		int attackerShots = 0;
		int attackerSuperglides = 0;
		
		
		// collect all DamageEvents on victim and calculate total damage
		foreach ( DamageEvent event in allDamageEvents ) 
		{
			if ( event.victimHandle == victim_handle ) 
			{	
				totalDamageToVictim += event.damage;
				relevantDamageEvents.append( event );
				
				#if DEVELOPER && DEBUGDMG
					sqprint(format("Event timestamp: %d",event.actionTimestamp))
					sqprint(format("Event lasthit: %d",event.lastHitTimestamp))
				#endif
				
				if ( event.actionTimestamp <= fightStartTime ) 
					fightStartTime = event.actionTimestamp
				
				if ( event.lastHitTimestamp >= fightEndTime ) 
					fightEndTime = (event.lastHitTimestamp + 0.0500)		
			}
			#if DEVELOPER && DEBUGDMG
				else 
				{
					sqprint(format("event.victimHandle does not equal event victim of: victim.p.handle. values: %d, %d", event.victimHandle, victim_handle ))
				}
			#endif
		}
		
		// set should ship to true
		if ( file.bCheckShip && totalDamageToVictim >= 50 ) //todo: setting maxhealth / 2  (need uniform health setting set/get)
		{
			#if DEVELOPER
				Warning( "Flag(bool) shouldship set" )
			#endif
			
			file.bShouldShip = true
			file.bCheckShip = false
		}
		
		if ( totalDamageToVictim <= 0 )
		{
			Tracker_AddDamageEventsToDeleteQueue( attacker_handle, victim_handle )
			return
		}
		
		#if DEVELOPER && DEBUGDMG
			sqprint( format( "\n Fight start time: %d, end time: %d", fightStartTime, fightEndTime ) )
		#endif

		//check bool first
		if ( !file.gamemode_type_1v1 && totalDamageToVictim < file.FS_MaxHealth ) 
			timeWindow = DAMAGE_LOOKBACK_TIME_WINDOW

		// Reset totalDamageToVictim for the second pass
		totalDamageToVictim = 0.0
		
		/////////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////// 		attackers of victim		/////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////
		// log DamageEvents that fall within the time window if damages are less than full health
		
		foreach ( int eventIndex, DamageEvent event in relevantDamageEvents ) 
		{	
			if ( file.gamemode_type_1v1 || ( deathtime - event.actionTimestamp <= timeWindow ) ) 
			{			
				attackerUID = statPrintUID( GetPlayerUIDFromHandle( event.attackerHandle ) )
				attackerName = GetPlayerNameFromHandle( event.attackerHandle )
				
				totalDamageToVictim += event.damage;
				
				string mul = event.hitCount > 1 ? "s" : ""; //this needs to go
				
				//statement header
				logString += "{" + attackerUID + "}{" + attackerName + "} dealt:";

				if (IsSpecialWeapon(event.weaponSource)) 
				{
					int bulletsPerShot = GetBulletsPerShot(event.weaponSource);
					int totalBulletsFired = event.hitCount * bulletsPerShot;
					logString += format("Entry: {%.2f} damage ON {%s}{%s} at time {%.2f} in {%d} hit%s {%d/%d} bullets with weapon {%s} headshots: {%d};",
										event.damage, victimUID, victimName, event.actionTimestamp, event.hitCount, mul, event.bulletsHit, totalBulletsFired, DamageSourceIDToString(event.weaponSource), event.headshots);
				} 
				else 
				{
					logString += format("Entry: {%.2f} damage ON {%s}{%s} at time {%.2f} in {%d} hit%s with weapon {%s} headshots: {%d};",
										event.damage, victimUID, victimName, event.actionTimestamp, event.hitCount, mul, DamageSourceIDToString(event.weaponSource), event.headshots);
				}
				

				// attackers totals
				int playerIndex = player_handles.find( event.attackerHandle )
				
				if ( playerIndex == -1 ) 
				{
					// new attacker
					player_handles.append( event.attackerHandle )
					playerDISPLAYNAME.append(attackerName)
					playerTotalDamages.append(0.0)
					playerTotalHits.append(0)
					playerTotalHeadshots.append(0)
					playerTotalJumps.append(0)
					playerTotalShots.append(0)
					playerSuperglides.append(0)
					playerIndex = player_handles.len() - 1;
				}
				
					playerTotalDamages[playerIndex] += event.damage;
					playerTotalHits[playerIndex] += event.hitCount;
					playerTotalHeadshots[playerIndex] += event.headshots;
			}
		}
		/////////////////////////////////////////////////////////////////////////////////////////
		//////////////////	 	extended time based damage events		/////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////
		// if total damage to victim is less than max health, extend time frame
		
		if ( !file.gamemode_type_1v1 && totalDamageToVictim < file.FS_MaxHealth ) 
		{
			foreach ( int eventIndex, DamageEvent event in allDamageEvents ) 
			{			
				attackerName = GetPlayerNameFromHandle(event.attackerHandle)
				
				if ( event.victimHandle == victim_handle && ( deathtime - event.actionTimestamp <= timeWindow ) ) 
				{
					if ( totalDamageToVictim + event.damage <= file.FS_MaxHealth ) 
					{
						totalDamageToVictim += event.damage;

						string mul = event.hitCount > 1 ? "s" : ""; //go away

						logString += "{" + GetPlayerUIDFromHandle(event.attackerHandle) + "}{" + attackerName + "} dealt:";

						if ( IsSpecialWeapon( event.weaponSource ) ) 
						{
							int bulletsPerShot = GetBulletsPerShot(event.weaponSource)
							int totalBulletsFired = event.hitCount * bulletsPerShot;
							logString += format("Entry: {%.2f} damage ON {%s}{%s} at time {%.2f} in {%d} hit%s {%d/%d} bullets with weapon {%s} headshots: {%d};",
												event.damage, victimUID, victimName, event.actionTimestamp, event.hitCount, mul, event.bulletsHit, totalBulletsFired, DamageSourceIDToString(event.weaponSource), event.headshots)
						} 
						else 
						{
							logString += format("Entry: {%.2f} damage ON {%s}{%s} at time {%.2f} in {%d} hit%s with weapon {%s} headshots: {%d};",
												event.damage, victimUID, victimName, event.actionTimestamp, event.hitCount, mul, DamageSourceIDToString(event.weaponSource), event.headshots)
						}
						
						
						//attackers jumps & total shots for fight
						int playerIndex = player_handles.find( event.attackerHandle )
						if (playerIndex == -1) 
						{
							// new attacker
							player_handles.append( event.attackerHandle )
							playerDISPLAYNAME.append(attackerName)
							playerTotalDamages.append(0.0)
							playerTotalHits.append(0)
							playerTotalHeadshots.append(0)
							playerTotalJumps.append(0)
							playerTotalShots.append(0)
							playerSuperglides.append(0)
							playerIndex = player_handles.len() - 1;
						}
						
							playerTotalDamages[playerIndex] += event.damage;
							playerTotalHits[playerIndex] += event.hitCount;
							playerTotalHeadshots[playerIndex] += event.headshots;
							
					}
				}
			}
		}


		/////////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////// 		victim			/////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////
		
		foreach ( int eventIndex, DamageEvent event in allDamageEvents ) 
		{
			if ( event.attackerHandle == victim_handle && ( file.gamemode_type_1v1 || deathtime - event.actionTimestamp <= timeWindow ) ) 
			{					
				victimTotalDamage += event.damage;
				victimTotalHits += event.hitCount;
				victimTotalHeadshots += event.headshots;	
				
				
				string mul = event.hitCount > 1 ? "s" : ""; //needs to go
				
				logString += "{" + victimUID + "}{" + string( victimName ) + "} dealt:"; //Note: don't confuse entity struct with damage event struct, victim entity is current attacker

				if ( IsSpecialWeapon( event.weaponSource ) ) 
				{
					int bulletsPerShot = GetBulletsPerShot( event.weaponSource )
					int totalBulletsFired = event.hitCount * bulletsPerShot;
					logString += format("Entry: {%.2f} damage ON {%s}{%s} at time {%.2f} in {%d} hit%s {%d/%d} bullets with weapon {%s} headshots: {%d};",
										event.damage, GetPlayerUIDFromHandle(event.victimHandle), GetPlayerNameFromHandle(event.victimHandle), event.actionTimestamp, event.hitCount, mul, event.bulletsHit, totalBulletsFired, DamageSourceIDToString(event.weaponSource), event.headshots);
				} 
				else 
				{
					logString += format("Entry: {%.2f} damage ON {%s}{%s} at time {%.2f} in {%d} hit%s with weapon {%s} headshots: {%d};",
										event.damage, GetPlayerUIDFromHandle(event.victimHandle), GetPlayerNameFromHandle(event.victimHandle), event.actionTimestamp, event.hitCount, mul, DamageSourceIDToString(event.weaponSource), event.headshots);
				}
			}
		}
		
		
		/////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////// 			REMOVE Events			/////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////
		
		//queue events for deletion immediately so they are not reused in the next fight
		Tracker_AddDamageEventsToDeleteQueue( attacker_handle, victim_handle )

		/////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////// 		attackers summary			/////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////
		// attackers summary - may change weapon(s) in the future to use cafe's logic for weps
		
		
		//This for loop is fine, it should never really exceed 2-5 attackers on the same victim.
		for ( int i = 0; i < player_handles.len(); ++i ) 
		{		
			attackerShots = 0
			attackerSuperglides = 0
			attackerJumps = 0
			//attackers jumps & total shots for fight
			int attackerIndex = GetPlayerMetricsIndexByUID( GetPlayerUIDFromHandle(player_handles[i]) ); 
			
			if ( attackerIndex != -1 ) 
			{
				attackerJumps = CountEventsWithinTimeframe(PlayerMetricsArray[attackerIndex].JumpTimestamps, fightStartTime - jumpgrace, fightEndTime)
				attackerSuperglides = CountEventsWithinTimeframe(PlayerMetricsArray[attackerIndex].SuperglideTimestamps, fightStartTime - glidegrace, fightEndTime)
				
				foreach ( weapon, timestamps in PlayerMetricsArray[ attackerIndex ].WeaponShotsTimestamps ) 
				{	
					int event_hitcount = CountEventsWithinTimeframe( timestamps, fightStartTime, fightEndTime )
					
					if( IsSpecialWeapon( weapon ) )
					{
						int event_bullets_per_shot = GetBulletsPerShot( weapon )
						int total_event_shots = event_hitcount * event_bullets_per_shot
						attackerShots += total_event_shots
					}
					else
					{
						attackerShots += event_hitcount
					}	
				}
				
				playerTotalShots[i] += attackerShots
			}
		
			logString += format("{%s}{%s} dealt:Recap: {%.2f} total damage in {%d} hits with weapon(s), headshots: {%d}, Total Jumps: {%d}, Total Shots: {%d}, Superglides: {%d};",
								statPrintUID( GetPlayerUIDFromHandle( player_handles[i] ) ), playerDISPLAYNAME[i], playerTotalDamages[i], playerTotalHits[i], playerTotalHeadshots[i], attackerJumps, attackerShots, attackerSuperglides);
								
			//DEBUG
			//sqprint(format("Total shots for fight: %d", attackerShots));
			
			AddToPlayerDamage( GetPlayerUIDFromHandle( player_handles[ i ] ), playerTotalDamages[ i ] )
			AddToPlayerShots( GetPlayerUIDFromHandle( player_handles[ i ] ), playerTotalShots[ i ] )
			AddToPlayerHits( GetPlayerUIDFromHandle( player_handles[ i ] ), playerTotalHits[ i ] )
			
			entity currentAttacker = GetEntityFromEncodedEHandle( player_handles[i] )
			
			//*move to gametype specific in future
			// if ( Flowstate_IsLGDuels() )
			// {			
				// if ( IsValid( currentAttacker ) && IsValid( victim ) )
				// {
					// RecapStats( currentAttacker, playerTotalDamages[i], float( playerTotalHits[i] ), float( playerTotalShots[i] ), string( victimName ), victimTotalDamage, float( victimTotalHits ), float( victimTotalShots )  )
				// }
			// }
			
			if( file.gamemode_type_1v1 )
			{
				//entity currentAttacker = GetEntityFromEncodedEHandle( player_handles[i] )
				
				if( IsValid( currentAttacker ) )
				{
					soloGroupStruct group = returnSoloGroupOfPlayer( currentAttacker )
				
					if ( IsValid( group ) )
					{
						if( group.IsKeep )
						{
							addStatsToGroup( currentAttacker, group, playerTotalDamages[i], playerTotalHits[i], playerTotalShots[i], true )
						}
					}
				}
			}						
		}
		
		
		/////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////// 			victims summary			/////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////
		//vttackers jumps & total shots for fight
		
		int victimIndex = victimIsPlayer ? GetPlayerMetricsIndex( victim ) : -1
		
		if ( victimIndex != -1 ) 
		{
			victimTotalJumps = CountEventsWithinTimeframe( PlayerMetricsArray[victimIndex].JumpTimestamps, fightStartTime - jumpgrace, fightEndTime )
			victimSuperglides = CountEventsWithinTimeframe( PlayerMetricsArray[victimIndex].SuperglideTimestamps, fightStartTime - glidegrace, fightEndTime )
			
			foreach ( weapon, timestamps in PlayerMetricsArray[victimIndex].WeaponShotsTimestamps ) 
			{	
				int event_hitcount = CountEventsWithinTimeframe( timestamps, fightStartTime, fightEndTime )
				
				if( IsSpecialWeapon( weapon ) )
				{
					int event_bullets_per_shot = GetBulletsPerShot(weapon)
					int total_event_shots = event_hitcount * event_bullets_per_shot;
					victimTotalShots += total_event_shots;
				}
				else
				{
					victimTotalShots += event_hitcount;
				}	
			}
		}
		
		logString += format("{%s}{%s} dealt:Recap: {%.2f} total damage in {%d} hits with weapon(s), headshots: {%d}, Total Jumps: {%d}, Total Shots: {%d}, Superglides: {%d};",
                    victimUID, victimName, victimTotalDamage, victimTotalHits, victimTotalHeadshots, victimTotalJumps, victimTotalShots, victimSuperglides);
			
					AddToPlayerDamage( victimUID, victimTotalDamage )
			
		//*move to gametype specific in future or set playlist bool
		// if ( Flowstate_IsLGDuels() )
		// {
			// if ( IsValid( victim ) )
			// {	
				// for ( int i = 0; i < player_handles.len(); ++i ) 
				// {
					// RecapStats( victim, victimTotalDamage, victimTotalHits.tofloat(), victimTotalShots.tofloat(), playerDISPLAYNAME[i], playerTotalDamages[i], playerTotalHits[i].tofloat(), playerTotalShots[i].tofloat()  )
				// }
			// }
		// }
		
		bool bIsChal = false
		if( file.gamemode_type_1v1 )
		{
			soloGroupStruct group = returnSoloGroupOfPlayer( victim )
			
			if( IsValid( group ) && group.IsKeep )
			{
				bIsChal = true
				addStatsToGroup( victim, group, victimTotalDamage, victimTotalHits, victimTotalShots, false )
			}
		}
			
		
		
		/////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////// 			LOG THE data			/////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////


            float timeRemaining = Tracker_DecideTimeRemaining()
            int aliveTeams = GetNumTeamsRemaining() //ty ida

			string attName = ""
			string aController = ""
			string attTeam = "-1"
			
			if ( !attacker.IsPlayer() )
			{
				attTeam = "-1";
				aController = "worldspawn";	
			} 
			else 
			{
				attTeam = attacker.GetTeam().tostring()
				aController = attacker.p.input.tostring()
			}


            string team_of_killer = attTeam
            string team_of_killed = victim.GetTeam().tostring()
			float pingVictim = victimIsPlayer ? ( victim.GetLatency() * 1000 - 40 ) : -1.0
			float pingAttacker = 0
			string a_OID = ""
			string v_OID = victimUID

			int iAttackerScore = 0
			if ( attacker.IsPlayer() )
			{
				attName = attacker.p.name;
				pingAttacker = attacker.GetLatency() * 1000 - 40
				a_OID = attacker.p.UID
				iAttackerScore = attacker.p.season_score
				
				if ( bReportStats && attacker != victim )
					AddToPlayerKills( a_OID )
			}
			else if( attacker.IsNPC() )
			{
				string ornull potentialName = attacker.GetNetworkedClassName() 
				
				if( potentialName != null )
					attName = expect string( potentialName )
				else 
					attName = "NULL_DEBUGIT";
				
				a_OID = attName
			}
			else 
			{
				int attackerID = DamageInfo_GetDamageSourceIdentifier( damageInfo )
				
				a_OID = GetWorldSpawnRef( attackerID )
				
				if( !exclude( attackerID ) )
					attName = DamageSourceIDToString( attackerID )			
			}
			
			if ( bReportStats )
			{
				AddToPlayerDeaths( victim )
				AddToPlayerShots( v_OID, victimTotalShots )
				AddToPlayerHits ( v_OID, victimTotalHits )
			}
			
			string victimcontroller = victimIsPlayer ? victim.p.input.tostring() : "1"
			int iVictimScore = victimIsPlayer ? victim.p.season_score : 0
			
			int isChal = bIsChal ? 1 : 0
			int pA = pingAttacker.tointeger()
			int pV = pingVictim.tointeger()
			int currentTimeStamp = GetUnixTimestamp()
            logString += format("\n^^,%s,1,%d,%d,%s,%s,%s,%i,%d,%s,%d,%d,%s,%s,%i,%i,%i\n&&,%s,%d,%s,%d,%s,%s,%i,%d,%s,%d,%d,%s,%s,%s,%i,%i,%i\n",
                a_OID, 					//0
                GetNumTeamsRemaining(), //2
                currentTimeStamp, 	//3
                v_OID, 					//4
                team_of_killer, 		//5
                team_of_killed, 		//6
                timeRemaining, 			//7
                id, 					//8
				aController, 			//9
				pA, 					//10
				pV, 					//11
				attName, 				//12	
				victimName, 			//13
				iAttackerScore,			//14
				iVictimScore,			//15
				isChal,					//16
                v_OID, 				//0
                aliveTeams, 		//1
                a_OID, 				//2
                currentTimeStamp, 	//3
                team_of_killer, 	//4
                team_of_killed, 	//5
                timeRemaining, 		//6
                id, 				//7
				aController, 		//8
				pV, 				//9
				pA, 				//10
				victimcontroller, 	//11
				attName, 			//12
				victimName, 		//13
				iAttackerScore,		//14
				iVictimScore,		//15
				isChal 				//16
            );

			if ( bReportStats && file.bSafeLog )
			{
				LogEvent__internal( logString, file.LogE )
				
				#if DEVELOPER && DEBUGDMG
					sqprint( logString )
				#endif
			}
    }//EndFight()

	//TODO redesign delete thread (maybe again)
	void function EventManager() 
	{		
		if ( DeleteEventTaskList.len() > 0 )
		{				
			RemoveEvents
			( 
				DeleteEventTaskList[0].victim_handle, 
				DeleteEventTaskList[0].attacker_handle, 
				DeleteEventTaskList[0].fightEndTime
			)	
			DeleteEventTaskList.remove(0)		
		}
	}
	
	void function Tracker_AddEventTask( DeleteEvents Event ) 
	{
		DeleteEventTaskList.append( Event )
		EventManager()
	}


	void function RemoveEvents( int dead_victim_handle, int killer_attacker_handle, float fightEndTime ) 
	{
		#if DEVELOPER 
			int removed = 0		
		#endif
			
		DamageEvent nullevent;		
		allDamageEventsMap[ eventID( killer_attacker_handle, dead_victim_handle ) ] <- nullevent
		allDamageEventsMap[ eventID( dead_victim_handle, killer_attacker_handle ) ] <- nullevent
  
		for ( int i = allDamageEvents.len() - 1; i >= 0; --i ) 
		{
			if ( file.gamemode_type_1v1 ) 
			{
				if ( allDamageEvents[i].attackerHandle == dead_victim_handle || allDamageEvents[i].attackerHandle == killer_attacker_handle ) 
				{
					allDamageEvents.remove(i)
					#if DEVELOPER 
						removed++;
					#endif 
				}
			} 
			else
			{
				if ( Time() - fightEndTime > MAX_FIGHT_HISTORY_TIME || allDamageEvents[i].victimHandle == dead_victim_handle ) 
				{          
					allDamageEvents.remove(i)
					#if DEVELOPER 
						removed++;
					#endif
				}
			}
		}

		#if DEVELOPER
				foreach (event in allDamageEvents) 
				{
					sqprint( format( "Remaining event handle: dealer: %d, reciever: %d ", event.attackerHandle, event.victimHandle ) )
				}
			sqprint( format( "Total remaining events: %d, Total removed: %d", allDamageEvents.len(), removed ) )
		#endif
	}
	
int function SetWeaponSettingIntFromFile( string weaponRef, string setting )
{
	var data = GetWeaponInfoFileKeyField_Global( weaponRef, setting ) 

	if( data != null )
		return expect int( data )
	
	#if DEVELOPER
		printw( "Invalid weapons settings for", weaponRef, setting )
	#endif 
	
	return 0
}


// Checks from DamageSourceIDToStringTable as janu framework registered weapons 
// assign to these tables at runtime. 
void function WeaponSettings_Init()
{
	string pps = "projectiles_per_shot"
	string dnv = "damage_near_value"
		
	foreach( int id, string weapon in DamageSourceIDToStringTable() )
	{
		if( !WeaponIsPrecached( weapon ) ) //wont have a set file / wont be used.
			continue
		
		int projectiles_per_shot = SetWeaponSettingIntFromFile( weapon, pps )	
		if( projectiles_per_shot > 1 )
		{
			file.DamagePerBullet[ id ] <- float( SetWeaponSettingIntFromFile( weapon, dnv ) )
			file.SpecialWeaponsBulletsPerShot[ id ] <- projectiles_per_shot
			
			#if DEVELOPER
				printt( "Added multiple projectile eDamageSourceId: '", id, "' for weapon:'", weapon, "'" )
			#endif
		}
	}
}

int function GetBulletsPerShot( int weaponSource ) 
{
	return file.SpecialWeaponsBulletsPerShot[ weaponSource ]
}

float function GetDamagePerBullet( int weaponSource ) 
{
	if( weaponSource in file.DamagePerBullet )
		return file.DamagePerBullet[ weaponSource ]
	
	return 1
}

bool function IsSpecialWeapon( int weaponSource )
{
	if ( weaponSource in file.SpecialWeaponsBulletsPerShot )
		return true
	
	return false 
}

//calculated in backend
const table<int,bool> weaponBypassesHitCount = 
{
	[eDamageSourceId.melee_pilot_emptyhanded] = true,
	[eDamageSourceId.mp_weapon_defensive_bombardment_weapon] = true,
	[eDamageSourceId.mp_weapon_creeping_bombardment_weapon] = true,
	[eDamageSourceId.mp_weapon_dirty_bomb] = true,
	[eDamageSourceId.mp_weapon_tesla_trap] = true,
	[eDamageSourceId.melee_data_knife] = true,
	[eDamageSourceId.mp_ability_heal] = true,
	[eDamageSourceId.mp_ability_holopilot] = true,
	[eDamageSourceId.mp_weapon_grenade_gas] = true,
	[eDamageSourceId.melee_flagpole] = true,
	[eDamageSourceId.mp_weapon_energysword] = true,
	[eDamageSourceId.damagedef_grenade_gas] = true,
	[eDamageSourceId.damagedef_gas_exposure] = true,
	[eDamageSourceId.damagedef_dirty_bomb_explosion] = true,
	[eDamageSourceId.damagedef_DocDrone] = true,
	[eDamageSourceId.damagedef_defensive_bombardment] = true,
	[eDamageSourceId.damagedef_bangalore_smoke_explosion] = true
}

bool function WeaponBypassesHits( int weaponSource )
{
	return ( weaponSource in weaponBypassesHitCount )
}

void function Tracker_HandleDamage( DamageEvent event, entity attacker, int weaponSource, float damageAmount, var damageInfo, entity victim ) 
{
	if ( !IsValid( victim ) || !IsValid( attacker ) )
		return
	
	float currentHealth = float( victim.GetHealth() + victim.GetShieldHealth() )
	
	// negate damage that can't be done (no health to recieve damage)
	if ( currentHealth > 0 && damageAmount > currentHealth ) 
	{
		#if DEVELOPER && DEBUGDMG
			printt("Damageamount:", damageAmount, ";currenthealth:", currentHealth )
		#endif
		
		damageAmount = currentHealth;
	}

	// for calculating total projectiles from constants
	float damagePerBullet = GetDamagePerBullet( weaponSource )
	float bulletsHit = damageAmount / damagePerBullet

	// headshot count
	if ( DamageInfo_GetCustomDamageType( damageInfo ) & DF_HEADSHOT ) 
		event.headshots++

	bool multiple = false
	
	// count damageInfo from special weapons as a single shot
	float currentTime = Time()
	
	//if( !( weaponSource in weaponBypassesHitCount ) )
	//{
		if ( IsSpecialWeapon( weaponSource ) ) 
		{
			if ( event.lastHitTimestamp == 0 || ( currentTime - event.lastHitTimestamp ) * 1000 > 100 ) 
			{
				event.hitCount++;
				multiple = true
			}
		} 
		else
		{
			event.hitCount++;
		}
	//}

	// update DamageEvent
	event.lastHitTimestamp = currentTime
	event.bulletsHit += bulletsHit

	if ( event.isNew ) 
	{
		event.damage = damageAmount

		if ( multiple ) 
			event.isNew = true
		else 
			event.isNew = false
	} 
	else 
	{
		event.damage += damageAmount
		
		if ( multiple ) 
			event.isNew = true
	}

	//sqprint(format("Handling damage for an event with isNew: %s and existing damage: %.2f\n", event.isNew ? "true" : "false", event.damage));
}

const array<int> trackedEventDamageSource = [
	eDamageSourceId.deathField,
	eDamageSourceId.fall
]

int function eventID( int attackerHandle, int victimHandle )
{
	return ( attackerHandle << 16 ) | victimHandle
}

DamageEvent function Tracker_GetRecentDamageEvent( int eventID )
{
	DamageEvent event;
	
	if( eventID in allDamageEventsMap )
		return allDamageEventsMap[ eventID ]
	
	return event
}

#if DEVELOPER && DEBUGDMG
	var function DEV_DamageInfo()
	{
		return file.damageInfo
	}
#endif

void function Tracker_OnPlayerDamaged( entity victim, var damageInfo )
{	
	#if DEVELOPER && DEBUGDMG
		file.damageInfo = damageInfo 
	#endif
	
	//Todo: reverse 
	// if( !DamageInfo_ShouldRecordStatsForWeapon( damageInfo ) )
	// {
		// #if DEVELOPER && DEBUGDMG
			// Warning("Should not record stats, returning")
		// #endif
		
		// return
	// }
	
	float actionTimestamp = Time()
    
	// early exits
    if ( !IsValid( victim ) || Bleedout_IsBleedingOut( victim ) ) 
		return

    entity attacker = DamageInfo_GetAttacker( damageInfo )
    int weaponSource = DamageInfo_GetDamageSourceIdentifier( damageInfo )
    
	// exclude this damage type
    if ( weaponSource == eDamageSourceId.bleedout || weaponSource == eDamageSourceId.human_execution )
		return

    //float damageAmount = scalar > 0 ? DamageInfo_GetDamage(damageInfo) * scalar : DamageInfo_GetDamage(damageInfo) ;
	float damageAmount = DamageInfo_GetDamage( damageInfo )

	#if DEVELOPER && DEBUGDMG
		DebugDamageInfo( victim, damageInfo )
		printt("InflictorOwner", InflictorOwner( DamageInfo_GetAttacker( damageInfo ) ) )
		printt("DamageInfo_GetWeapon: ", DamageInfo_GetWeapon(damageInfo) )	 
		printt("raw getattacker: ",DamageInfo_GetAttacker( damageInfo ))
		printt("raw getinflictor: ", DamageInfo_GetInflictor( damageInfo ))
		printt("damageAmount: ", damageAmount)
		printt("DamageInfo_GetWeapon: ", DamageInfo_GetWeapon(damageInfo) )
		printt("weaponSource: ", weaponSource ) 
	
	#endif

	int victimHandle = Tracker_FetchHandle( victim )
	int attackerHandle = Tracker_FetchHandle( attacker )	

	if( victimHandle == -1 || attackerHandle == -1 )
		return 
	
	if( IsValid( attacker ) && !attacker.IsPlayer() && !attacker.IsNPC() )
	{
		#if DEVELOPER && DEBUGDMG
			printt( "Attacker not player" )
		#endif
		
		attacker = InflictorOwner( DamageInfo_GetInflictor( damageInfo ) )		
		
		if( !attacker.IsPlayer() && attacker.GetClassName() == "trigger_hurt" )
		{
			#if DEVELOPER && DEBUGDMG
				Warning( "Setting to worldspawn" )
			#endif
			
			attacker = GetEnt( "worldspawn" )
		}
		else if( trackedEventDamageSource.contains( weaponSource ) ) 
		{
			attacker = GetEnt( "worldspawn" )
			attackerHandle = weaponSource
		}
		else
		{		
			string msg = format( "STATS:: untracked damage source for: %s -- weaponSource: %d", string( attacker ), weaponSource )
			printt( msg )
			LogError( msg )
					
			return
		}
    }

	float shotIdentifier = 0.0
	
    if ( IsSpecialWeapon( weaponSource ) ) 
        shotIdentifier = float( weaponSource ) + Time() 
	
	int eventID = eventID( attackerHandle, victimHandle ) 
	DamageEvent existingEvent = Tracker_GetRecentDamageEvent( eventID )

	#if DEVELOPER && DEBUGDMG
		sqprint(format("\n\n\n Event exists: %s \n\n\n", existingEvent.isValid ? "true" : "false"))
	#endif
	
    if ( existingEvent.isValid ) //event exists
	{
        // last weapon used from the existing event
        int lastWeaponSource = existingEvent.weaponOrder[existingEvent.weaponOrder.len() - 1]

        // check if weapon changed or new shot from special weapon (new event block)
        if ( lastWeaponSource != weaponSource || ( IsSpecialWeapon( weaponSource ) && existingEvent.shotIdentifier != shotIdentifier ) ) 
		{
            DamageEvent newEvent = Tracker_CreateDamageEvent( weaponSource, damageAmount, actionTimestamp, shotIdentifier, attackerHandle, victimHandle )
            newEvent.weaponOrder.append( weaponSource )
            newEvent.shotIdentifier = shotIdentifier
            Tracker_HandleDamage( newEvent, attacker, weaponSource, damageAmount, damageInfo, victim )
            allDamageEvents.append( newEvent )
        } 
		else 
		{
            // update existing damage event
            existingEvent.isNew = false;
            existingEvent.weaponOrder.append(weaponSource)
            Tracker_HandleDamage( existingEvent, attacker, weaponSource, damageAmount, damageInfo, victim )
        }
    } 
	else //event doesn't exist
	{
        //create new one
        DamageEvent newEvent = Tracker_CreateDamageEvent( weaponSource, damageAmount, actionTimestamp, shotIdentifier, attackerHandle, victimHandle )
        newEvent.weaponOrder.append( weaponSource )
        newEvent.shotIdentifier = shotIdentifier;
        Tracker_HandleDamage( newEvent, attacker, weaponSource, damageAmount, damageInfo, victim )
        allDamageEvents.append( newEvent )
    }

    
	#if DEVELOPER && DEBUGDMG
		sqprint( "Current Damage Events: \n" )
		
		foreach( DamageEvent event in allDamageEvents ) 
			sqprint(format("Attacker: %d, Victim: %d, Damage: %.2f, Time: %.2f, shots: %d\n", event.attackerHandle, event.victimHandle, event.damage, event.actionTimestamp, event.hitCount ))
	#endif
	
}

int function Tracker_FetchHandle( entity ent )
{
	if( !IsValid( ent ) )
		return -1
	
	if( ent.IsPlayer() )
		return ent.p.handle
	
	if( ent.IsNPC() )
		return ent.GetEncodedEHandle()
	
	return 0
}

void function __TrackerStatsHook_Damage( entity victim, var damageInfo )
{
	Tracker_OnPlayerDamaged( victim, damageInfo )
}

DamageEvent function Tracker_GetCurrentEventForAttackerOnVictim( int attackerHandle, int victimHandle )
{
	return Tracker_GetRecentDamageEvent( eventID( attackerHandle, victimHandle ) )
}

DamageEvent function Tracker_GetCurrentEventByPlayerHandle_expensive( int playerHandle, bool attacker = true )
{	
	int dmgEventLen = allDamageEvents.len()
	
	if( dmgEventLen > 0 )
	{
		for ( int i = dmgEventLen - 1; i >= 0; --i )
		{
			if( attacker )
			{
				if ( allDamageEvents[i].attackerHandle == playerHandle )
				{
					return allDamageEvents[i]
				}
			}
			else 
			{
				if ( allDamageEvents[i].victimHandle == playerHandle )
				{
					return allDamageEvents[i]
				}
			}
		}
	}
	
	DamageEvent nullevent;
	nullevent.lastHitTimestamp = 0.0
	return nullevent
}


//END KILL RECAP
/*****************************************************************************************************************************/
/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////


	//this blows
	bool function ClientCommand_mkos_ea_verify( entity player, array<string> args )
	{	
		string ea_acc = player.GetPlayerName()
		string OID = player.GetPlatformUID()
	
		int index = -1;
		for (int i = 0; i < playerVerifyCounts.len(); i++) 
		{
			if (playerVerifyCounts[i].playerID == ea_acc) 
			{
				index = i;
				break;
			}
		}

		if (index == -1) 
		{
			PlayerVerifyCount newEntry
			newEntry.playerID = ea_acc
			newEntry.verifyCount = 0;
			playerVerifyCounts.append( newEntry )
			index = playerVerifyCounts.len() - 1
		}

		if ( playerVerifyCounts[index].verifyCount >= 3 ) 
		{
			Message(player, "Too many attempts. Try again later.")
			return false
		}
	
		thread PlayerEA_Verify( player, args, index, ea_acc, OID )	
		return true
	}
	
	
	void function PlayerEA_Verify( entity player, array<string> args, int index, string ea_acc, string OID ) 
	{
		if ( !IsValid( player ) ) // || !player.p.isConnected)
				return
		
		if ( file.gamemode_type_1v1 ) 
		{
			if( !player.p.isConnected )
				waitthread WaitSignalOrTimeout( player, 5, "OnConnected", "OnDisconnected", "OnDestroy" )
			
			if( !IsValid( player ) || !player.p.isConnected )
				return
				
			Remote_CallFunction_ByRef( player, "ForceScoreboardLoseFocus" )
			mkos_Force_Rest( player )
		}
		
		if( !player.p.isConnected )
			return

		if ( args.len() < 1 )
		{
			Message( player, "Token from R5R.DEV is required." )
			return
		}

		playerVerifyCounts[ index ].verifyCount += 1

		string token = args[ 0 ]
		EA_Verify__internal( token, OID, ea_acc )
		
		return
	}
	
	void function CodeCallback_VerifyEaAccount( string oid, int token )
	{	
		entity player = GetPlayerEntityByUID( oid )
		
		if( !IsValid( player ) )
			return
					
		switch ( token )
		{
			case 10:
				Message( player, "Failed: Expired Token", "Please request a new one" )
				return

			case 2:
				Message( player, "Invalid token", "Usage: ea_verify   yourtoken" )
				return

			case 4:
				Message( player, "Failed", "EA Account already linked." )
				return

			case 1:
				Message( player, "SUCCESS", "Your account was successfully verified on R5R.DEV" )
				return

			case 5:
				Message( player, "Failed: ", "Database error on success" )
				return

			case 3:
				Message( player, "Failed: ", "DB error" )
				return

			case 6:
				Message( player, "Failed: ", "Missing Data" )
				return

			case 8:
				Message( player, "Failed: ", "CURL Error." )
				return

			case 0:
			default:
				Message( player, "Failed", "Could not verify EA Account." )
				return
		}	
	}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////// PLAYER METRICS struct /////////////////////////////////////////

int function InitializePlayerMetricsStructForPlayer( entity player, string playerID = "" )
{	
	bool byID = false 
	
	if( !IsValid( player ) ) 
	{
		if ( empty( playerID ) )
			return -1 
		else 
			byID = true 
	}
	else 
	{
		playerID = player.p.UID
	}
	
	if ( Tracker_IsPlayerMetricsInitialized( playerID ) ) 
	{
		#if DEVELOPER
			sqerror( "Metrics already initialized for player: " 
			+ ( byID ? playerID : player.GetPlayerName() ) + "\n\n" 
			+ FUNC_NAME(2) + "()\n\n" )
			DumpStack()
		#endif
		
		return GetPlayerMetricsIndexByUID( playerID )
	}
	
	string ID = byID ? playerID : player.GetPlatformUID()
	string name = byID ? "" : player.GetPlayerName()
		
	PlayerMetrics NewMetrics;
	
	NewMetrics.playerID = ID
	NewMetrics.playername = name
	NewMetrics.ent = player
    NewMetrics.JumpTimestamps = []
    NewMetrics.WeaponShotsTimestamps = {}
	NewMetrics.SuperglideTimestamps = []
	NewMetrics.kills = 0
	NewMetrics.deaths = 0
	NewMetrics.damage = 0.0
	NewMetrics.playerleft = false
	NewMetrics.ignore_sync_flag = false
	NewMetrics.isValid = true
	
	PlayerMetricsArray.append( NewMetrics )
	return PlayerMap_Insert( ID )	
}

//////////////////////////////////////
//									//
//		  PLAYER METRICS INIT		//
//									//
//////////////////////////////////////


int function GetPlayerMetricsIndex( entity player ) 
{	
	if( !IsValid( player ) )
		return -1
	
    if ( player.p.UID in PlayerIdMap ) 
        return PlayerIdMap[ player.p.UID ]
	
	return InitializePlayerMetricsStructForPlayer( player )
}

bool function Tracker_IsPlayerMetricsInitialized( string uid )
{
	return ( uid in PlayerIdMap )
}

int function GetPlayerMetricsIndexByUID( string uid )
{
	if ( uid in PlayerIdMap ) 
        return PlayerIdMap[ uid ]
	
    return InitializePlayerMetricsStructForPlayerByUID( uid )
}

PlayerMetrics function __GetPlayerMetrics( int id )
{
	if( id > -1 && id < PlayerMetricsArray.len() )
		return PlayerMetricsArray[ id ]
	else 
	{
		#if DEVELOPER
			mAssert( false, "Tried to return an invalid player metrics id: " + id )
		#endif
	}
	
	PlayerMetrics metrics
	return metrics
}

#if DEVELOPER
	int function DEV_GetPlayerMetricsIndexByUID( string uid )
	{
		return GetPlayerMetricsIndexByUID( uid )
	}
#endif 

int function PlayerMap_Insert( string uid ) 
{
    int index = PlayerMetricsArray.len() - 1
    
	PlayerIdMap[ uid ] <- index	
	return index
}


int function InitializePlayerMetricsStructForPlayerByUID( string playerID )
{
	entity p	
	return InitializePlayerMetricsStructForPlayer( p, playerID )
}


void function RecordPlayerJump( entity player ) 
{
	float time = Time()
 
    int index = GetPlayerMetricsIndex( player )	
    PlayerMetricsArray[ index ].JumpTimestamps.append(time)
}


void function RecordPlayerSuperglides( entity player ) 
{
	float time = Time()
 
    int index = GetPlayerMetricsIndex( player )
    PlayerMetricsArray[ index ].SuperglideTimestamps.append( time )
}


void function RecordPlayerShot( entity player, int weaponSource ) 
{
    int index = GetPlayerMetricsIndex( player )
	float time = Time()

	if ( !(weaponSource in PlayerMetricsArray[ index ].WeaponShotsTimestamps) ) 
	{
		PlayerMetricsArray[ index ].WeaponShotsTimestamps[ weaponSource ] <- [ time ]
	} 
	else 
	{
		PlayerMetricsArray[ index ].WeaponShotsTimestamps[ weaponSource ].append( time )
	}
}


void function AddToPlayerKills( string playerID )
{
	int index = GetPlayerMetricsIndexByUID( playerID )	
	PlayerMetricsArray[ index ].kills += 1		
}


void function AddToPlayerDeaths( entity player )
{
	if( !player.IsPlayer() )
		return 
		
	int index = GetPlayerMetricsIndex( player )	
	PlayerMetricsArray[ index ].deaths += 1		
}


void function AddToPlayerDamage( string playerID, float damage )
{	
	int index = GetPlayerMetricsIndexByUID( playerID )
	PlayerMetricsArray[ index ].damage += damage	
}

void function AddToPlayerShots( string playerID, int shots )
{
	int index = GetPlayerMetricsIndexByUID( playerID )
	PlayerMetricsArray[ index ].shots += shots	
}

void function AddToPlayerHits( string playerID, int hits )
{
	int index = GetPlayerMetricsIndexByUID( playerID )
	PlayerMetricsArray[ index ].hits += hits
}


/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////					/////////////////////////////////
/////////////////////////////	 PERSISTENCE 	/////////////////////////////////
/////////////////////////////					/////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////

// add your settings with AddCallback_PlayerData()


//player quit and rejoined, but data is already in table
//therefore to avoid overriding with old data we pull it from local

//todo: needs update system
void function UpdateFromLocalPersistence( entity player )
{		
	SetIgnoreSyncFlag( player )
	
	player.p.IBMM_grace_period 		= GetPlayer_wait_time( player )
	player.p.weapon_loadout 		= GetPlayer_saved_weapons( player )
	player.p.lock1v1_setting		= GetPlayer_lock1v1_setting( player )	
	player.p.start_in_rest_setting 	= GetPlayer_start_in_rest_setting( player )
	player.p.enable_input_banner 	= GetPlayer_enable_input_banner_setting( player )
	
	player.SetPlayerNetInt( "kills", GetPlayerKills( player ) )
	player.SetPlayerNetInt( "deaths", GetPlayerDeaths( player ) )
	player.SetPlayerNetInt( "damage", GetPlayerDamage( player ) )
}

void function PlayerDataCallbacks_Init()
{	
	Script_RegisterAllPlayerDataCallbacks()
}

void function Gamemode1v1_PlayerDataCallbacks()
{
	AddCallback_PlayerData( "wait_time", UpdateIBMMWaitTime )
	if( FlowState_AdminTgive() ){ AddCallback_PlayerData( "saved_weapons", UpdateSavedWeapons ) }
	AddCallback_PlayerData( "lock1v1_setting", UpdateLock1v1Setting )
	AddCallback_PlayerData( "start_in_rest_setting", UpdateStartInRestSetting )
	AddCallback_PlayerData( "enable_input_banner", UpdateInputBannerSetting )
}

// utility funcitons for fetch/save playerdata 


//Todo, type system
void function Tracker_SavePlayerData( string uid, string setting, ... )
{
	if( vargc < 1 )
	{
		#if DEVELOPER 
			Warning( "No argument was passed to " + FUNC_NAME() + "()" )
		#endif 
		return 
	}
	
	ThrowValidSaveType( vargv[0] )

	string value = "";
	string type = typeof( vargv[0] );
	
	if ( type != "string" )
	{
		if( type == "bool" )
		{
			value = vargv[0] == true ? "1" : "0";
		}
		else 
		{	
			#if DEVELOPER 
				//sqprint( format( "Converting SavePlayerData for setting: %s to string from type %s", setting, typeof( vargc ) ) )
			#endif
			value = string( vargv[0] )
		}
	}
	else 
	{
		value = string( vargv[0] )
	}
	
	#if DEVELOPER
		sqprint( format( "saving setting: %s as \"%s\"", setting, value ) )
	#endif
	
	if ( !( uid in file.PlayerData ) )
        file.PlayerData[ uid ] <- {}
	
	if ( !( setting in file.PlayerData[ uid ] ) )
		file.PlayerData[ uid ][ setting ] <- value
	else 
		file.PlayerData[ uid ][ setting ] = value

	if( vargc > 1 )
	{
		if( typeof( vargv[ 1 ] ) == "bool" )
		{
			if( expect bool( vargv[ 1 ] ) == true )
				tracker._updateSettingsPlayers( [ tracker.settingsInstance( uid, { [ setting ] = value } ) ] )
		}
	}
}

void function ThrowValidSaveType( ... )
{	
	string type = typeof( vargv[0] )
	
	switch( type )
	{
		case "string":
		case "bool":
		case "int":
		case "float":
			
			return
			
		default:
			
			throw format( "Invalid variable type of: [%s] passed to %s(); Expects: [string,bool,int,float]", type, FUNC_NAME() );
	}
	
	unreachable
}

string function Tracker_FetchPlayerData( string UID, string setting )
{
	if ( UID in file.PlayerData )
	{
		if ( setting in file.PlayerData[ UID ] )
			return file.PlayerData[ UID ][ setting ]
	}
	
	return ""
}

const table<int,string> hardcodedWorldspawnRefs = //unordered int requires lookup
{
	[ eDamageSourceId.deathField ] 			= "_DEATHFIELD",
	[ eDamageSourceId.bleedout ] 			= "_BLEEDOUT",
	[ eDamageSourceId.damagedef_suicide ] 	= "_SUICIDE",
	[ eDamageSourceId.damagedef_despawn ]	= "_DESPAWN",
	[ eDamageSourceId.fall ]				= "_FALL"
}

string function _GetHardcodedWorldspawnRef( int ref )
{
	return hardcodedWorldspawnRefs[ ref ]
}

bool function UIDisWorldSpawn( int uid )
{
	if( uid in hardcodedWorldspawnRefs )
		return true 
		
	return false
}

string function GetWorldSpawnRef( int uid )
{
	if( UIDisWorldSpawn( uid ) )
		return _GetHardcodedWorldspawnRef( uid )
	
	return "WORLDSPAWN_NOTFOUND"
}

// This function is responsible for sending sync data to r5r.dev.
// If your data is not output with this, your data will not be synced. 

// For settings added via AddCallback_PlayerData(), your settings will be here,
// IF they were saved using Tracker_SavePlayerData()

// For stats added via Tracker_RegisterStat() with also having defined
// Stats__RegisterStatOutboundData() for the stat ( param 3 of Tracker_RegisterStat() ), your stat will output 
// based on the defined functions return data at the time of this function call
SerializedData function Tracker_BuildAllPlayerMetrics( bool trigger = false ) 
{
    string json = "["
    foreach ( index, metrics in PlayerMetricsArray ) 
	{
        if ( index > 0 )
            json += ", "
		
		string UID = metrics.playerID
		bool isWorldspawn = false

		if( UIDisWorldSpawn( int( UID ) ) )
		{
			UID = _GetHardcodedWorldspawnRef( int( UID ) ) //assign UID with hardcoded worldspawn ref for backend
			isWorldspawn = true
		}
		
		//start building
        json += "{";	
        json += format( "\"player\": \"%s\", ", UID ) 

		if( isWorldspawn )
			UID = metrics.playerID //reassign to slot value
		
		json += format( "\"jumps\": %d, ", metrics.JumpTimestamps.len() ) //predefined
		
		// stats are shipped when registered with 
		// Stats__RegisterStatOutboundData()  <- [ this is called with Tracker_RegisterStat() when a third parameter is provided for callbackfunc ]
		json += Stats__GenerateOutBoundJsonData( UID )
		
		//settings 
		json += "\"settings\": {"
	
		if( file.requestedSettingsList.len() == 0 )
		{
			json += "\"NOT_LOADED\": \"NA\""
		}
		else
		{
			bool first = true	
			if( UID in file.PlayerData )
			{
				foreach ( setting, value in file.PlayerData[ UID ] )
				{
					value = PrepareForJson( value )
					
					if ( !first ) 
					{
						json += ", ";
					}
					
					if( first )
						first = false
						
					json += format( "\"%s\": \"%s\"", setting, value )
				}
			}
		}
		
		json += "},";

		//weapons array
        json += "\"weaponShots\": {"
		
        bool wep_first = true
		
		string replace = ""
		
        foreach ( weaponSource, timestamps in metrics.WeaponShotsTimestamps ) 
		{
			if( WeaponBypassesHits( weaponSource ) )
				continue
			
            if ( !wep_first ) 
			{
                json += ", "
            }
			
			if( !exclude( weaponSource ) )
			{
				replace = DamageSourceIDToString( weaponSource )
			}
			else
			{
				#if DEVELOPER
					printt( "setting weaponSource for player:", UID, "as:", GetRefFromDamageSourceID( weaponSource ) )
				#endif
				
				replace = weaponSource.tostring()
			}
			
            json += format( "\"%s\": %d", replace, timestamps.len() )
            wep_first = false;
        }
        json += "}}"
    }
    json += "]"
	
	if ( trigger )
	{	
		return json		
	} 
	else 
	{	
		sqprint( "^|," + json + "\n" )
		return "" 		
	}
	
	unreachable
}

SerializedData function __t_serial( PlayerSettingsUpdate settingsArray ) 
{
    SerializedData json = "["
	int last = settingsArray.len() - 1
	
    foreach( int index, PlayerSettings settingsData in settingsArray ) 
    {			
		json += format( "{\"player\": \"%s\", ", settingsData.uid )
		json += "\"settings\": {"
		
		bool firstSetting = true
		foreach( string setting, string value in settingsData.settings )
		{	
			value = PrepareForJson( value )
			if ( !tracker.check( setting, value ) )
				continue

			if ( !firstSetting )
				json += ", "
			else
				firstSetting = false
				
			json += format( "\"%s\": \"%s\"", setting, value )
		}
		
		json += "}}"
		
		if ( index < last )
            json += ", "
	}

    json += "]"
    return json
}

// This function is responsible for summing up global stats between rounds 
// Kills/deaths/glides get reset per round, therefore globals have to be reset. 
// This is because players that stay for multiple rounds will not resync online stats
// and the server must locally keep track of these accumulations.

//Todo redesign
void function UpdateRoundStats_GlobalsCarryOver()
{
	foreach ( player in GetPlayerArray() )
	{
		if ( IsValid( player ) )
		{	
			int season_kills = player.p.season_kills
			int season_deaths = player.p.season_deaths
			int season_glides = player.p.season_glides
		
			string player_oid = player.GetPlatformUID()
			int current_kills = GetPlayerKills( player ) 
			int current_deaths = GetPlayerDeaths( player )
			int current_glides = GetGlides( player )
			
			player.p.season_kills = current_kills + season_kills
			player.p.season_deaths = current_deaths + season_deaths
			player.p.season_glides = current_glides + season_glides	
		}
	}
}

void function SetIgnoreSyncFlag( entity player )
{
	int index = GetPlayerMetricsIndex( player )

	try
	{
		PlayerMetricsArray[ index ].ignore_sync_flag = true;
	}
	catch(e){}
}

bool function Tracker_IgnoreResync( entity player )
{
	return GetIgnoreSyncFlag( player )
}

bool function GetIgnoreSyncFlag( entity player )
{
	int index = GetPlayerMetricsIndex( player )
	
	if( index != -1 )
		return PlayerMetricsArray[index].ignore_sync_flag;
	
	return false
}


void function SetPlayerLeftFlag( entity player )
{
	//we double set/check this function 
	//to make sure leaving player has flag set
	int index = GetPlayerMetricsIndex( player )

	index = GetPlayerMetricsIndex( player )
	
	if ( index != -1 ) 
		PlayerMetricsArray[ index ].playerleft = true;
}


void function SavePlayerData( entity player, string setting, ... )
{
	if( !IsValid( player ) )
		return 
		
	#if DEVELOPER
		mAssert( vargc > 0, "Empty Data passed to " + FUNC_NAME() )			
		mAssert( player.IsPlayer(), "Cannot save player data for nonplayer." )
	#endif
	
	Tracker_SavePlayerData( player.p.UID, setting, vargv[0] )
}

bool function Tracker_GetPlayerLeftFlag( entity player ) 
{
	int index = GetPlayerMetricsIndex( player )
	
    if ( index != -1 ) 
        return PlayerMetricsArray[ index ].hadleft
	
    return false
}

bool function GetPlayerLeftFlag( entity player ) 
{
    int index = GetPlayerMetricsIndex( player )
	
    if ( index != -1 ) 
	{	
        bool left = PlayerMetricsArray[ index ].playerleft
		
		if( left )
		{
			PlayerMetricsArray[ index ].hadleft = true
			PlayerMetricsArray[ index ].playerleft = false
			return true
		}
    }
	
    return false
}


float function GetPlayer_wait_time( entity player ) 
{
	string setting = Tracker_FetchPlayerData( player.p.UID, "enable_input_banner" ) 
	
	if ( !empty( setting ) )
		return setting.tofloat()
	
    return GetDefaultIBMM()
}


string function GetPlayer_saved_weapons( entity player ) 
{	
	string setting = Tracker_FetchPlayerData( player.p.UID, "saved_weapons" )
	
	if ( !empty( setting ) )
		return setting
	
    return "NA"
}


bool function GetPlayer_lock1v1_setting( entity player ) 
{	
	string setting = Tracker_FetchPlayerData( player.p.UID, "lock1v1_setting" )
	
	if ( !empty( setting ) )
		return ( setting == "1" )
	
    return GetDefaultLock1v1Setting() 
}


bool function GetPlayer_start_in_rest_setting( entity player ) 
{	
	string setting = Tracker_FetchPlayerData( player.p.UID, "start_in_rest_setting" )
	
	if ( !empty( setting ) )
		return ( setting == "1" )
	
    return GetDefaultStartInRestSetting()
}


bool function GetPlayer_enable_input_banner_setting( entity player ) 
{
	string setting = Tracker_FetchPlayerData( player.p.UID, "enable_input_banner" )
	
	if ( !empty( setting ) )
		return ( setting == "1" )
	
    return GetDefaultEnableInputBannerSetting() 
}

bool function GetDefaultLock1v1Setting()
{
	return file.DefaultLock1v1Setting
}

bool function GetDefaultEnableInputBannerSetting()
{
	return file.DefaultEnableInputBannerSetting
}

bool function GetDefaultStartInRestSetting()
{
	return file.DefaultStartInRestSetting
}


void function UpdateIBMMWaitTime( entity player, string data )
{	
	if( empty( data ) )
		data = string( GetDefaultIBMM() )
	
	float wait_time = 0.0
	
	if( IsNumeric( data ) )
		wait_time = data.tofloat()
	
	if ( wait_time <= file.ibmm_wait_limit )
		player.p.IBMM_grace_period = ValidateIBMMWaitTime( wait_time )
	else 
		player.p.IBMM_grace_period = GetDefaultIBMM()
}

void function UpdateSavedWeapons( entity player, string data )
{	
	if ( empty( data ) )
		return
		
	if ( data == "NA" )
		return
		
	if( FlowState_AdminTgive() )
		return
	
	weaponlist[ player.GetPlayerName() ] <- data
	player.p.weapon_loadout = data
}


void function UpdateLock1v1Setting( entity player, string data )
{	
	if ( empty( data ) ) 
	{ 
		player.p.lock1v1_setting = GetDefaultLock1v1Setting()
		return 
	}
	
	if( data == "0" )
		player.p.lock1v1_setting = false
	else if( data == "1" )
		player.p.lock1v1_setting = true
	else 
		player.p.lock1v1_setting = GetDefaultLock1v1Setting()
}

void function UpdateStartInRestSetting( entity player, string data )
{	
	if ( empty( data ) ) 
	{ 
		player.p.start_in_rest_setting = GetDefaultStartInRestSetting()
		return 
	}

	if( data == "0" )
		player.p.start_in_rest_setting = false
	else if( data == "1" )
		player.p.start_in_rest_setting = true
	else 
		player.p.start_in_rest_setting = GetDefaultStartInRestSetting()
}

void function UpdateInputBannerSetting( entity player, string data )
{	
	if ( empty( data ) ) 
	{ 
		player.p.enable_input_banner = GetDefaultEnableInputBannerSetting()
		return
	}
	
	if( data == "0" )
		player.p.enable_input_banner = false
	else if( data == "1" )
		player.p.enable_input_banner = true
	else 
		player.p.enable_input_banner = GetDefaultEnableInputBannerSetting()
}

// END PERSISTENCE //////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////

int function GetPlayerKills( entity player ) 
{
    int index = GetPlayerMetricsIndex( player )
	
    if ( index != -1 ) 
        return PlayerMetricsArray[ index ].kills
	
    return 0
}


float function GetPlayerDamage( entity player ) 
{
    int index = GetPlayerMetricsIndex( player )
	
    if ( index != -1 ) 
        return PlayerMetricsArray[ index ].damage
	
    return 0
}


int function GetPlayerDeaths( entity player ) 
{
    int index = GetPlayerMetricsIndex( player )
	
    if ( index != -1 ) 
        return PlayerMetricsArray[ index ].deaths
	
    return 0
}


/***************************# JUMPS / SHOTS / SuperGlides #******************************************/


void function Flowstate_TrackingVision_SuperglideDetection_Stats(entity player) 
{ 
	if ( !IsValid( player ) ) 
		return
	
	thread Flowstate_TrackingVision_TryToTrackSuperglide_Stats( player )
	AddPlayerMovementEventCallback( player , ePlayerMovementEvents.JUMP, DidJump)
}


void function DidJump( entity player )
{	
	PlayerDidJump[ player.p.UID ] = true
}


void function ResetJump( string playerID )
{
	PlayerDidJump[ playerID ] <- false
}


bool function pDidJump( string playerID )
{
	if ( !( playerID in PlayerDidJump ) ) 
		return false
	
	if ( PlayerDidJump[ playerID ] == true ) 
		return true 
	
	return false
}


int function GetGlides( entity player ) 
{
    int index = GetPlayerMetricsIndex( player )
	
    if ( index != -1 ) 
        return PlayerMetricsArray[ index ].SuperglideTimestamps.len();
	
    return 0
}


//credit: columbiaFPS (cafe), heavily modified by mkos
// todo: move to code function?
void function Flowstate_TrackingVision_TryToTrackSuperglide_Stats( entity player )
{	
	
	if ( !IsValid( player ) ) 
		return
	
	Signal( player, "SuperglideDetectionResetStats" )
	EndSignal( player, "SuperglideDetectionResetStats" )
	//sqprint("Superglide reset signal");
	
		
	bool AttemptingSuperGlide = true
	string playerID = player.GetPlatformUID() 
	ResetJump(playerID);
			
	float playerVel
	vector playerVelV
	float airtime = 0;
	bool hadair = false;
	bool didmantle = false;
	bool didslide = false;
	vector start = player.GetOrigin()
	
	while( IsValid( player ) && !player.IsObserver() && AttemptingSuperGlide == true)
	{
		//sqprint(format("Time: %d, on ground? %s , mantling? %s, Did jump? %s", Time(), player.IsOnGround().tostring(), player.IsMantling().tostring(), pDidJump(playerID).tostring()))
		
		playerVelV = player.GetVelocity()
		playerVel = playerVelV.Length()
		vector current = player.GetOrigin();
		vector difference = current - start;
		float distance = sqrt(difference.x * difference.x + difference.y * difference.y + difference.z * difference.z);
			
		if( player.IsOnGround() || player.IsMantling())
		{	
			airtime = 0.0
			//sqprint(format("Air time reset: %d", airtime ))
			if (player.IsMantling()){ didmantle = true; }
			
		} 
		else if( !player.IsOnGround() && !player.ContextAction_IsZipline() && !player.IsMantling() )
		{
			airtime += 0.025
			hadair = true;
			if ( player.IsSliding() ){ didslide = true }
			//sqprint(format("Air time increasing: %d", airtime ))
		}
		
		if ( player.IsSliding() ){ didslide = true }
		
		if( pDidJump(playerID) == true && didmantle == true && didslide == true && playerVel > 445 && airtime <= 0.6 )
		{	
			//sqprint(format("hitsuperglide airtime: %d, velocity: %d", airtime, playerVel));
			AttemptingSuperGlide = false;
			RecordPlayerSuperglides( player )
			
			if ( file.sg_counter_msg )
			{	//TODO: DEPRECATE
				Message( player, format("%s: %d", file.superglidetitle, ( GetGlides(player) + player.p.season_glides ) ), file.superglide_msg )
			}
			
			break;	
		} 			
		if (distance > 115 && player.IsOnGround())
		{
			//sqprint(format("breaking due to moving from mantle. Distance: %d", distance))
			AttemptingSuperGlide = false;
			break;		
		}
		if (!player.IsMantling() && player.IsOnGround() && hadair == true)
		{
			//sqprint("Breaking due to mantle time and ground")
			AttemptingSuperGlide = false;
			break;	
		}
		if (player.IsMantling()){ didmantle = true; }
		if ( player.IsSliding()){ didslide = false }
		ResetJump(playerID);	
		
		wait 0.01
	}
	
	//sqprint("End of loop");
	ResetJump( playerID )
	RemovePlayerMovementEventCallback( player , ePlayerMovementEvents.JUMP, DidJump )
}


void function OnJumped( entity player ) 
{
	RecordPlayerJump( player )
}

const table<string,bool> disabledForTracking = 
{
	mp_ability_consumable = true,
	mp_weapon_jump_pad = true,
	mp_weapon_deployable_medic = true,
	mp_ability_crypto_drone = true,
	mp_ability_gibraltar_shield = true,
	mp_ability_heal = true,
	mp_ability_mirage_ultimate = true,
	mp_ability_phase_rewind = true,
	mp_ability_holopilot = true,
	mp_ability_phase_walk = true,
	mp_ability_revenant_shadow_pounce_free = true,
	mp_ability_sonar = true,
	mp_ability_grapple = true,
	mp_ability_emote_projector = true,
	mp_ability_area_sonar_scan = true,
	mp_ability_hunt_mode = true,
	mp_ability_care_package = true,
	mp_weapon_phase_tunnel = true,
	mp_weapon_grenade_bangalore = true,
	mp_weapon_grenade_creeping_bombardment = true,
	mp_weapon_trophy_defense_system = true,
	mp_weapon_bubble_bunker_master_chief = true,
	mp_ability_cloak = true
}

bool function Tracker_ShouldRecordWeaponShot( string weaponRef )
{
	if( weaponRef in disabledForTracking )
		return false 
		
	return true
}

void function WeaponAttack( entity player, entity weapon, string weaponRef, int ammoUsed, vector origin, vector dir ) 
{
	if( weaponRef in TrackerWepTable() )
	{	
		RecordPlayerShot( player, TrackerWepTable()[ weaponRef ] )
	}
	else
	{
		if( !Tracker_ShouldRecordWeaponShot( weaponRef ) )
			return 
			
		if( RegisterDamageDef( weaponRef, weapon ) )
			RecordPlayerShot( player, TrackerWepTable()[ weaponRef ] )
	}
}

bool function RegisterDamageDef( string weaponName, entity weapon )
{
	string nameFromClass = "";
	
	if( IsValid( weapon ) )
		nameFromClass = weapon.GetWeaponClassName()
	
	if( empty( weaponName ) )
	{
		sqerror( format("weaponName was empty in call to %s()", FUNC_NAME() ) )
		
		if( !empty( nameFromClass ) )
			weaponName = nameFromClass
		else 
			return false
	}
	
	if( weaponName in TrackerWepTable() )
	{
		sqerror( format("Weapon %s already exists in TrackerWepTable", weaponName ) )
		return false
	}
	
	int newIndex = TrackerWepTable().len()
	
	if( newIndex in DamageSourceIDToStringTable() )
	{
		sqerror( format("Index %d already exists in DamageSourceIDToStringTable, aborting", newIndex ) )
		return false
	}
	
	string errorString = format( "Appending new DamageDef with data: index[%d] = \"%s\" ----DEBUG: weaponName = %s, nameFromClass = %s ", newIndex, weaponName, weaponName, nameFromClass )
	LogError( errorString )
	
	#if DEVELOPER
		printw( errorString )
	#endif
	
	TrackerWepTable()[ weaponName ] <- newIndex
	DamageSourceIDToStringTable()[ newIndex ] <- weaponName
	
	return true
}

void function LogError( string errorString )
{
	file.errorArray.append( errorString )
}

array<string> function GetTrackerErrorArray()
{
	return file.errorArray
}

void function DEV_WriteAllTrackerErrors()
{
	if( file.errorArray.len() <= 0 )
		return
	
	string data = "\n\n|#error ------ PRINTING ERRORS ------\n\n";
	
	foreach ( error in file.errorArray )
		data += format( "|#error %s \n", error )
	
	if( file.LogOn && isLogging__internal() )
		LogEvent__internal( data, false )
}


//// end metrics
/////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////





void function PlayerDisconnectedCallback( entity player ) 
{	
    string reason = "Disconnection"
    PIN_PlayerLeft( player, reason )
}

void function PIN_GameStart()
{
	//stubbed
}


void function PIN_SetGameStartTime()
{

}

//make sure round_end isn't started from multiple sources in codebase at same time.
bool process_end_round_complete = true; 

void function PIN_RoundEnd( int roundnum )
{	
	if( process_end_round_complete == true )
	{
		__executeEventEnd_messages()
		thread FinishGameStatsRound()
	}
}

void function __UpdateLiveStats_internal( SerializedData metrics )
{
	if( Tracker_GetQueryBool( "verified" ) && !empty( metrics ) )
		SQ_UpdateLiveStats__internal( metrics )
}

//Modes where winning doesn't requiring fighting. 
const array<int> IGNORE_FIRST_BLOOD_PLAYLISTS =
[
	ePlaylists.fs_haloMod_ctf
]

void function FinishGameStatsRound()
{
	if( process_end_round_complete == true )
	{
		process_end_round_complete = false

		if ( file.LogOn && isLogging__internal() )
		{
			if( !file.bSafeLog )
			{
				stopLogging__internal( false )
				return
			}
			
			#if LOG_ERRORS
				DEV_WriteAllTrackerErrors()
			#endif
			
			LogEvent__internal
			(
				format( "#|Season: %d\n|| Game ended at %d\n\n %s", Tracker_GetQueryInt( "season" ), GetUnixTimestamp(), Tracker_BuildAllPlayerMetrics( true ) ),
				file.LogE
			)

			if( !Logging_ShipStats() )
				sqprint( "Shipping to stats server DISABLED -- check playlists file to enable --" )
				
			if( ( !IGNORE_FIRST_BLOOD_PLAYLISTS.contains( Playlist() ) && !Flag( "SurvivalCommentary_FirstBloodReached" ) ) || !file.bShouldShip )
			{
				sqprint( "No stats to ship...\n" )
				stopLogging__internal( false )
				
				if( file.bForceUpdatePlayerData )
					__UpdateMetricsNow()
			}
			else
			{
				bool ship = !file.bStatsShipped && Logging_ShipStats()
				stopLogging__internal( ship ) //IMPORTANT
				
				//update live global stats for match making (verified only)
				__UpdateMetricsNow()
				
				//send to discord:		
				if( DiscordHook_MatchesRecapEnabled() )
				{
					string recap = Tracker_WinnerByKillsAndDamage()
					thread __EndOfMatch( recap, file.DISCORD_MATCHES_WEBHOOK )
				}
				
				if( Logging_ShipStats() )
				{
					foreach( player in GetPlayerArray() )
					{
						if( !IsValid( player ) ) 
							continue
						
						LocalMsg( player, "#FS_STATS_SHIPPED", "#FS_STATS_SHIPPED_MSG", eMsgUI.DEFAULT, 4 )
					}
				}
			}
		}
		
		UpdateRoundStats_GlobalsCarryOver()	
		__DestroyStats()
		process_end_round_complete = true
		file.PIN_GameState_Start = false		
	} 
}

void function __UpdateMetricsNow()
{
	if( file.bStatsShipped )
	{
		printw( "Tried to ship stats more than once." )
		return
	}
		
	file.bStatsShipped = true
	__UpdateLiveStats_internal( Tracker_BuildAllPlayerMetrics( true ) )
}

void function PIN_GameEnd()
{	
	if ( process_end_round_complete == true )
	{
		svGlobal.levelEnt.Signal( "KillIntervalThread" ) 
		thread FinishGameStatsRound()
	}
}

void function PIN_AddPlayer( entity player )
{	
	if( !IsValid( player ) ) 
		return
	
	//HACK! Todo: Remove 
	if( file.bChatbotEnabled && player.GetPlayerName() == "["+ file.sBotName +"]" )
	{
		file.entityBotEnt = player 
		
		if( IsValid( file.entityBotEnt ) )
		{
			AddEntityCallback_OnPlayerRespawned( file.entityBotEnt, CheckForMessageBot )
			
			AddCallback_OnPlayerChangedTeam
			(
				void function( entity ent, int old, int new )
				{
					if( IsBotEnt( ent ) )
					{
						if( new != 119 )
							SetTeam( ent, 119 )
					}
				}
			)
			
			player.p.InDeathRecap = true
			mkos_Force_Rest( file.entityBotEnt )
			file.entityBotEnt.p.start_in_rest_setting = true;
			file.entityBotEnt.SetDamageNotifications( false )
			file.entityBotEnt.SetDeathNotifications( false )
			thread MessageIntervalThread()
		}
		else 
		{
			sqerror( "ServerBot Entity Error" )
		}
		
		return
	}//
	
	if( !file.global_stats || !bLog() )
		SetStatsReadyFlag( player, true )
	
	if( GetPlayerLeftFlag( player ) )
	{	
		//sqprint("R5RDEV_DEBUG_PRINT: Player had left previously flag triggered")
		UpdateFromLocalPersistence( player )
	}
	else 
	{	
		if( !Tracker_IsStatsReadyFor( player ) )
		{	
			waitthread WaitSignalOrTimeout( player, 15, "SyncDataFullyLoaded", "OnDestroy", "OnDisconnected" )
			
			if( !IsValid( player ) )
				return
		}
		
		if( Flowstate_IsLGDuels() )
			ResetLoadedWeapons( player )
	}
	
	if( file.restricted_server )
	{	
		thread Alert_Player_Access( player )
	}
	else 
	{
		if( player.p.start_in_rest_setting )
		{
			#if DEVELOPER
				sqprint("Player sent to rest from rest setting")
			#endif
			mkos_Force_Rest( player )
		}
	}
	
	if( file.LogOn && isLogging__internal() && IsValid( player ) )
	{	
		LogEvent__internal
		(
			format
			( 
				"^^,%s,0,%s,%d,,,,%i,,,,,%s\n",
				player.GetPlatformUID(),
				GetNumTeamsRemaining().tostring(),
				GetUnixTimestamp(),
				Tracker_DecideTimeRemaining(),
				player.GetPlayerName()
			),
			
			file.LogE
		)
	}	
}

void function BotInvis( entity bot )
{	
	if( !IsValid( bot ) )
		return
	
	bot.NotSolid()
	bot.Hide()
	SetTeam( bot, 119 )
}

void function PIN_PlayerLeft( entity player, string reason )
{
	string playerName = player.GetPlayerName()
	string OID = player.GetPlatformUID()
	
	SetPlayerLeftFlag( player )
	
	//string message = format("%s disconnected ", pname )
	//sqprint(message)

	if ( file.LogOn && file.bSafeLog ) 
	{
		if ( isLogging__internal() ) 
		{
			if ( file.update_discord_player_counts )
			{
				string count = ( GetNumHumanPlayers() - 1 ).tostring()
				thread PlayerCounts( "Left", playerName, OID, count )		
			}
			
			LogEvent__internal
			(
				format
				(
					"|&,%s,%i,%d,%s",
					OID,
					Tracker_DecideTimeRemaining(),
					GetUnixTimestamp(),
					playerName
					),
					
				file.LogE
			)
		}
	}
}

void function CheckForMessageBot( entity player ) //todo: remove after native solution
{
	BotInvis( player )
}

void function PIN_PlayerSpawned( entity player )
{
	/*
	string pname = player.GetPlayerName( )
	string message = format("%s spawned ", pname )
	sqprint(message)
	*/
}

void function PIN_PlayerDowned( entity victim, entity attacker, var damageInfo )
{
	/*
	string downedplayer = victim.GetPlayerName( )
	string attackingplayer = attacker.GetPlayerName( )
	string message = format("%s was downed by %s ", downedplayer, attackingplayer )
	sqprint(message)
	*/
}

void function PIN_PlayerRevived( entity injured, entity healer )
{
	/*
	string downedplayer = injured.GetPlayerName( )
	string revivingplayer = healer.GetPlayerName( )
	string message = format("%s was revived by %s ", downedplayer, revivingplayer )
	sqprint(message)
	*/
}

void function PIN_PlayerKilled( entity victim, entity attacker, var damageInfo )
{	
	if ( file.LogOn && isLogging__internal() && IsValid( victim ) && victim.IsPlayer() )
	{
		thread __EndFight( victim, attacker, damageInfo, Time() )
	}
}

void function Tracker_EndFight( entity victim, entity attacker, var damageInfo )
{
	if( !Flowstate_IsTrackerSupportedMode() || !file.LogOn || !isLogging__internal() )
		return
		
	thread __EndFight( victim, attacker, damageInfo, Time() )
}

void function PIN_PlanePath( vector startPos, vector endPos, float duration )
{

}

void function PIN_SetGameStartGetUnixTimestamp()
{
	/*
	int time = GetUnixTimestamp()
	string message = format(" deprecate Game start time: %d ", time )
	sqprint(message)
	*/
}

bool function CheckPlayerStartInRest( entity player )
{
	if  ( !IsValid( player ) ) 
		return false
	
	if ( file.gamemode_type_1v1 )
	{
		if ( player.p.start_in_rest_setting )
			mkos_Force_Rest( player )
	
		if ( isPlayerInRestingList( player ) )
			return true 
	}
	
	return false	
}


void function PIN_GameStartedForPlayer( entity player )
{	
	/*
	string pname = player.GetPlayerName( )

	if ( IsPlayerTracked(pname)) {
        return;
    }

	GameStartedForPlayer.push(pname);


	// useless, handled by onconnected
	string message = format("useless call; Game started for: %s ", pname )
	sqprint(message)
	*/
		
}


/* ######################################################################################### */

void function PIN_ItemPickup( entity player, entity pickup, string ref, int unitsPickedUp )
{
	//string pname = player.GetPlayerName( )
	//string message = format("%s picked up item %s", pname, ref )
	//sqprint(message)
}

void function PIN_CircleLocation( string type, vector origin, float radius, string action )
{

}

void function PIN_DamageDone( entity attacker, entity victim, float damageAmount )
{
	/* doesn't help without damageInfo

	string pname = attacker.GetPlayerName( )
	string vname = victim.GetPlayerName( )
	string message = format("%s did damage to %s", pname, vname)
	sqprint(message)
	*/
}

void function PIN_DamageDoneToPlayerForWeapon( entity attacker, string weaponclassname, float damageAmount, bool isHeadshot )
{
	/* useless
	string pname = attacker.GetPlayerName( )
	string message = format("%s did damge with weapon ", pname )
	sqprint(message)
	*/
}

void function PIN_PlayerEquip( entity player )
{	
	/* useless
	string pname = player.GetPlayerName( )
	string message = format("%s equiped something ", pname )
	sqprint(message)
	*/
}

void function PIN_PlayerUse( entity player, string ref, ... )
{	
	/*
	string pname = player.GetPlayerName( )
	string message = format("%s used %s ", pname, ref )
	sqprint(message)
	*/
}

void function PIN_PlayerOutResource( entity player, string ref )
{

}

//Todo: change determination based on mode
string function Tracker_WinnerByKillsAndDamage() 
{
    int Most_Kills 		= -1
    float Most_Damage 	= -1.0
    string winner 
    float winner_damage
    int winner_kills
    string winner_oid

    foreach ( player in PlayerMetricsArray ) 
	{
        int kills = player.kills
        float damage = player.damage

        if ( kills > Most_Kills || ( kills == Most_Kills && damage > Most_Damage ) ) 
		{
            Most_Kills = kills
            Most_Damage = damage

            winner = player.playername
            winner_oid = player.playerID
            winner_damage = damage
            winner_kills = kills
        }
    }

    if ( winner != "" ) 
	{
        string json = "{\"winner\":\"" + sanitize( winner ) + "\",\"winner_oid\":\"" + winner_oid + "\",\"winner_kills\":" + winner_kills.tostring() + ",\"winner_damage\":" + format("%.2f", winner_damage) + "}"
        return json
    }

    return ""
}


GameSummarySquadData function GameSummary_GetPlayerData( entity player )
{
	GameSummarySquadData data

	if ( !IsValid( player ) )
		return data

	data.uid = player.GetPlatformUID()
	data.kills = player.GetPlayerNetInt( "kills" )
	data.deaths = player.p.numberOfDeaths
	data.survivalTime = int( Time() - player.p.lastRespawnTime )
	data.damageDealt = int( player.p.playerDamageDealt )
	data.revivesGiven = player.p.revivesGiven
	data.respawnsGiven = player.p.respawnsGiven

	/*
    string metrics = format("Player Stats - Kills: %d, Deaths: %d, Survival Time: %d seconds, Damage Dealt: %d, Revives Given: %d, Respawns Given: %d",
                                 data.kills, data.deaths, data.survivalTime, data.damageDealt, data.revivesGiven, data.respawnsGiven);
    sqprint( metrics )
	*/
	
	return data
}

void function PIN_Interact(entity player, string sound, ... )
{	
	/* useless metric atm
	string pname = player.GetPlayerName( )
	string message = format("%s interacted ", pname )
	sqprint(message)
	*/
}

void function PIN_PlayerAbility( entity player, string name, int ability, entity tracked, table additionalData )
{	
	/* useless metric atm
	string pname = player.GetPlayerName( )
	string message = format("%s used: %s ", pname, name )
	sqprint(message)
	*/
}

void function PIN_PlayerAbilityReady( entity player, int ability )
{

}

void function PIN_AddToPlayerCountStat( entity player, string ability )
{

}

void function PIN_OnWeaponAttack( entity player, entity meleeAttackWeapon, string classname, int num, vector origin, vector lookDirection )
{
	/* no need, handled by ondamage
	string pname = player.GetPlayerName( )
	string message = format("%s meleed: ", pname )
	sqprint(message)
	*/
}

void function PIN_Ping( entity player, string pingType, entity pingEnt, vector position )
{	
	/* no need yet
	sqprint(format( "%s, %s, %s", string( player ), pingType, string( pingEnt ) ))
	string pname = player.GetPlayerName( )
	//string ping_what = pingEnt.tostring( )
	string message = format("%s pinged: at location: ", pname )
	sqprint(message)
	*/
}

void function PIN_OnPlayerHealed( entity player, ... )
{	
	/*
	//TODO:
	string who = player.GetPlayerName( )
	string message = format("%s healed", who )
	sqprint(message)
	*/
}

void function PIN_PlayerLandedOnGround( entity player )
{	
	/*
	get player vectors to build map
	
	string who = player.GetPlayerName( )
	string message = format("%s landed on ground", who )
	sqprint(message)
	*/
}

void function PIN_PlayerJumpedFromPlane( entity player, int len )
{
	/*
	get player vectors to build map
	
	string who = player.GetPlayerName( )
	string message = format("%s jumped from plane", who )
	sqprint(message)
	*/
}

void function PIN_Training( entity player, string status, string trainingStatus )
{
}

void function Tracker_Credits()
{
	if( Flowstate_IsTrackerSupportedMode() && isLogging__internal() )
	{
		foreach( player in GetPlayerArray() )
			LocalMsg( player, "#FS_SPACE", "#FS_TRACKER_CREDIT", eMsgUI.DEFAULT, 10 )
	}
}

float function Tracker_DecideTimeRemaining()
{
	float potentialTime = g_fCurrentRoundEndTime - Time()
	
	if( potentialTime < 0 )
		potentialTime = float( file.flowstateRoundtime )
		
	return potentialTime
}

void function Tracker_SetForceUpdatePlayerData()
{	
	file.bForceUpdatePlayerData = true
}

int function Tracker_GetStartUnixTime()
{ 
	return file.launchStartUnixTime 
}

string function statPrintUID( string uid )
{
	if( UIDisWorldSpawn( int( uid ) ) )
		return _GetHardcodedWorldspawnRef( int( uid ) )

	return uid
}
#endif //END TRACKER DEFINE


///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////

// SHARED

	//Simplified as per amos request with SetAutoReloadState()

	//gamemode dev is responsible for placement of this reload callback
	//internal check after game related / logging activities are done.

	void function g__InternalCheckReload()
	{
		mAssert( IsThreadTop(), "This function should be called with waitthread" )
		
		if( file.LogOn )
		{
			int max = 0
			while( !SQ_GetLogState__internal( eLogState.READY ) )
			{
				wait 0.1
				max++;
				
				if ( max >= 50 )
				{
					sqerror( format( "Timeout while waiting for log to finish in %s()...", FUNC_NAME() ) )
					break
				}
			}
		}
	
		SetAutoReloadState( true )
		wait 1.2
		SetAutoReloadState( false )
	}


///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////

//SHARED FUNC

void function SetAfkToRest( bool setting ){ file.afk_to_rest_enabled = setting }
bool function bAfkToRest(){ return file.afk_to_rest_enabled }

void function ClientCommand_RequestStat( entity player, array<string> args )
{
	#if DEVELOPER
		//PrintStringArray( args )
	#endif
	
	if( args.len() < 2 )
	{
		StatFailed( player )
		return
	}
		
	string lookupEHandle = args[ 0 ]
	if( !IsNumeric( lookupEHandle ) )
	{
		StatFailed( player )
		
		#if DEVELOPER
			printw( "lookupEHandle not numeric" )
		#endif 
		
		return 
	}
		
	entity lookupPlayer = GetEntityFromEncodedEHandle( lookupEHandle.tointeger() )
	if( !IsValid( lookupPlayer ) )
	{
		StatFailed( player )
		
		#if DEVELOPER 
			printw( "lookup player not valid" )
		#endif
		
		return
	}
	
	if( !Tracker_IsStatsReadyFor( player ) )
	{
		#if DEVELOPER 
			printw( "Tried to lookup stats on player ", player, "but stats are not available yet." )
		#endif 
		
		StatFailed( player )
		return 
	}
		
	string statname = args[ 1 ]
	if( empty( statname ) )
	{
		StatFailed( player )
		
		#if DEVELOPER 
			print( "Statname was empty" )
		#endif 
		
		return 
	}
		
	if( !Tracker_StatExists( statname ) )
	{
		#if DEVELOPER
			printw( "stat", statname, "does not exist." )
		#endif
		
		StatFailed( player )
		return
	}
		
	string lookupPlayerUid = lookupPlayer.GetPlatformUID()
	string type = typeof( Stats__RawGetStat( lookupPlayerUid, statname ) )
	
	switch( type )
	{
		case "bool":
		
			Remote_CallFunction_NonReplay( player, "Tracker_SetPlayerStatBool", lookupPlayer, GetPlayerStatBool( lookupPlayerUid, statname ) )
			break 
			
		case "int":
			
			Remote_CallFunction_NonReplay( player, "Tracker_SetPlayerStatInt", lookupPlayer, GetPlayerStatInt( lookupPlayerUid, statname ) )
			break 
		
		case "float":
			
			Remote_CallFunction_NonReplay( player, "Tracker_SetPlayerStatFloat", lookupPlayer, GetPlayerStatFloat( lookupPlayerUid, statname ) )
			break 
			
		default:
			StatFailed( player )

		#if DEVELOPER
			printw( "Invalid stat type requested by client. Type was:", type, "stat was:", statname )
		#endif
	}
}

void function StatFailed( entity player )
{
	Remote_CallFunction_ByRef( player, "Tracker_StatRequestFailed" )
}

#if HAS_TRACKER_DLL
//do nothing
#else
		array<int> function SQ_CreateServerBot__internal(){ return [-1] }
		
		int function EA_Verify__internal(){ return 0 }
		
		bool function isLogging__internal(){ return false }
		bool function SQ_GetLogState__internal( int state ){ return false }
	
		string function SQMatchID__internal(){ return "" }
		string function GetSyncData__internal( string UID ){ return "NA" }
		string function SQ_GetSetting__internal( string key ){ return "" }
		string function FetchGlobalSettingsFromR5RDEV__iternal( string query ){ return "" }
			
		void function InitializeLogThread__internal(){}
		void function LogEvent__internal( string data, bool encrypt ){}
		void function stopLogging__internal(){}	
		void function sqprint( string data ){ printt(data) }
		void function sqerror( string data ){ printt(data) }	
		void function _STATSHOOK_UpdatePlayerCount__internal(){}
		void function _STATSHOOK_EndOfMatch__internal(){}
		void function LoadSyncData__internal( string UID ){}
		void function SQ_UpdateLiveStats__internal(){}
		void function SQ_ResetStats__internal(){}
		void function LoadBatchSyncData__internal(){}
		void function CleanupLogs__internal(){}	
		void function SQ_ReloadConfig__internal(){}		
		void function SQ_ServerMsg__internal( string msg, int id ){}	
#endif

#if STUB

enum eLogState 
{ 
	READY = 1,
	BUSY = 2,
	SAFE = 3	
} 

struct {

	bool LogOn = false
	bool LogE = false
	bool bChatbotEnabled = false
	bool global_stats = false
	bool afk_to_rest_enabled = false
	string localFlowstate_MOTD = ""
	int launchStartUnixTime

} file

//flags
bool function bLog(){ return file.LogOn }
bool function bEnc(){ return file.LogE }
bool function bGlobalStats(){ return file.global_stats }
bool function bBotEnabled(){ return file.bChatbotEnabled }
void function Tracker_SetStartLog(){}

//persistence
string function Tracker_FetchPlayerData( string UID, string setting ){ return "" }
void function Tracker_SavePlayerData( string UID, string setting, ... ){}
void function SavePlayerData( entity player, string setting, ... ){}
bool function Tracker_StatExists( string stat ){ return false }
var function Stats__RawGetStat( string uid, string stat ){ return null }

//utility
bool function IsBotEnt( entity _ ){ return false } //needs to go immediately... 
void function SendServerMessage( string _ ){}
DamageEvent function Tracker_GetCurrentEventByPlayerHandle_expensive( int attackerHandle, bool attacker = true ){ DamageEvent e; e.lastHitTimestamp = 0.0; return e }
DamageEvent function Tracker_GetCurrentEventForAttackerOnVictim( int attackerHandle, int victimHandle ){ DamageEvent e; e.lastHitTimestamp = 0.0; return e }
bool function Tracker_IsRestrictedServer(){ return false }
void function Tracker_SetRestrictedServer( bool _ ){}
SerializedData function Tracker_BuildAllPlayerMetrics( bool _ ){ return "" }
array<entity> function ArrayRemoveBot( array<entity> _ ){ return _ }
int function Tracker_GetStartUnixTime(){ return file.launchStartUnixTime }

void function PIN_Init()
{
	#if CLIENT 
		return 
	#endif 
	
	if( IsLobby() )
		return

	file.launchStartUnixTime = GetUnixTimestamp()
	SetServerVar( "batch_fetch_complete", true ) //lets users use chat.
		
	AddCallback_OnClientConnected( PlayerConnectedCallback )
	file.afk_to_rest_enabled = GetCurrentPlaylistVarBool( "afk_to_rest_bool", false ) //later checked against mode/compatibility settings.
	
	if ( GetCurrentPlaylistVarBool( "cc_administration", false ) )
	{ 
		INIT_CC_MapNames()
		INIT_CC_GameTypes()
		INIT_CC_playeradmins()
		AddClientCommandCallback( "cc", ClientCommand_mkos_admin ) 
	}
	
	file.localFlowstate_MOTD = GetCurrentPlaylistVarString( "custom_MOTD", "" )
	
	if( GetCurrentPlaylistVarBool( "enable_motd", false ) )
	{
		if( !empty( file.localFlowstate_MOTD ) )
			AddCallback_OnClientConnected( ShowPlayerLocalMOTD )
		else 
			AddCallback_OnClientConnected( FireRemoteMotd )
	}
}

void function SendMotdToPlayer( entity player, string motd )
{
	MessageLong( player, "", "", eMsgUI.VAR_MOTD, 10, motd, "", "", true )
}

void function FireRemoteMotd( entity player )
{	
	thread
	(
		void function() : ( player )
		{
			if( !player.p.isConnected )
				waitthread WaitSignalOrTimeout( player, 20, "OnConnected", "OnDestroy", "OnDisconnected" )
			
			if( IsValid( player ) && player.p.isConnected )
			{
				//run ui script for motd
				Remote_CallFunction_UI( player, "UI_Callback_MOTD" )
					wait 5
					
				if( IsValid( player ) && player.p.isConnected )
					LocalMsg( player, "#FS_WELCOME", "", eMsgUI.QUICK, 10, player.p.name )//Extra welcome message //todo: move to client
			}
		}
	)()
}

void function ShowPlayerLocalMOTD( entity player )
{	
	thread
	(
		void function() : ( player )
		{
			if( !player.p.isConnected )
				waitthread WaitSignalOrTimeout( player, 20, "OnConnected", "OnDestroy", "OnDisconnected" )
			
				if( IsValid( player ) )
				{
					//run ui script for motd
					SendMotdToPlayer( player, file.localFlowstate_MOTD ) //LineBreak( file.localFlowstate_MOTD, 80 )
						wait 5
						
					if( IsValid( player ) )
						LocalMsg( player, "#FS_WELCOME", "", eMsgUI.QUICK, 10, player.p.name )//Extra welcome message
				}
		}
	)()
}

void function PIN_GameStart(){}
void function PIN_RoundEnd( int roundnum ){}
void function PIN_GameEnd(){}
void function PIN_AddPlayer( entity player ){}
void function PIN_PlayerLeft( entity player, string reason ){}
void function PIN_PlayerSpawned( entity player ){}
void function PIN_PlayerDowned( entity victim, entity attacker, var damageInfo ){}
void function PIN_PlayerRevived( entity injured, entity healer ){}
void function PIN_PlayerKilled( entity victim, entity attacker, var damageInfo ){}
void function PIN_PlanePath( vector startPos, vector endPos, float duration ){}
void function PIN_SetGameStartTime(){}
void function PIN_GameStartedForPlayer( entity player ){}
void function PIN_ItemPickup( entity player, entity pickup, string ref, int unitsPickedUp ){}
void function PIN_CircleLocation( string type, vector origin, float radius, string action ){}
void function PIN_DamageDone( entity attacker, entity victim, float damageAmount ){}
void function PIN_DamageDoneToPlayerForWeapon( entity attacker, string weaponclassname, float damageAmount, bool isHeadshot ){}
void function PIN_PlayerEquip( entity player ){}
void function PIN_PlayerUse( entity player, string ref, ... ){}
void function PIN_PlayerOutResource( entity player, string ref ){}

void function PlayerConnectedCallback( entity player )
{	
	if ( !IsValid( player ) ){ return }
	
	player.p.name = player.GetPlayerName()
	player.p.UID = player.GetPlatformUID()
	player.p.handle = player.GetEncodedEHandle()
}

GameSummarySquadData function GameSummary_GetPlayerData( entity player )
{
	GameSummarySquadData data

	if ( !IsValid( player ) )
		return data

	data.uid = player.GetPlatformUID()
	data.kills = player.GetPlayerNetInt( "kills" )
	data.deaths = player.p.numberOfDeaths
	data.survivalTime = int( Time() - player.p.lastRespawnTime )
	data.damageDealt = int( player.p.playerDamageDealt )
	data.revivesGiven = player.p.revivesGiven
	data.respawnsGiven = player.p.respawnsGiven

	return data
}

void function PIN_Interact(entity player, string sound, ... ){}
void function PIN_PlayerAbility( entity player, string name, int ability, entity tracked, table additionalData ){}
void function PIN_PlayerAbilityReady( entity player, int ability ){}
void function PIN_AddToPlayerCountStat( entity player, string ability ){}
void function PIN_OnWeaponAttack( entity player, entity meleeAttackWeapon, string classname, int num, vector origin, vector lookDirection ){}
void function PIN_Ping( entity player, string pingType, entity pingEnt, vector position ){}
void function PIN_OnPlayerHealed( entity player, ... ){}
void function PIN_PlayerLandedOnGround( entity player ){}
void function PIN_PlayerJumpedFromPlane( entity player, int len ){}
void function PIN_Training( entity player, string status, string trainingStatus ){}

#endif